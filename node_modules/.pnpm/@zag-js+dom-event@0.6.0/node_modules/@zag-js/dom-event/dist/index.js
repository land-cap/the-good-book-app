"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  addDomEvent: () => addDomEvent,
  fireBlurEvent: () => fireBlurEvent,
  fireCustomEvent: () => fireCustomEvent,
  getEventKey: () => getEventKey,
  getEventStep: () => getEventStep,
  getNativeEvent: () => getNativeEvent,
  getRelativePointPercent: () => getRelativePointPercent,
  getRelativePointValue: () => getRelativePointValue,
  isContextMenuEvent: () => isContextMenuEvent,
  isCtrlKey: () => isCtrlKey,
  isKeyboardClick: () => isKeyboardClick,
  isLeftClick: () => isLeftClick,
  isModifiedEvent: () => isModifiedEvent,
  isPrintableKey: () => isPrintableKey,
  isVirtualClick: () => isVirtualClick,
  isVirtualPointerEvent: () => isVirtualPointerEvent,
  requestPointerLock: () => requestPointerLock,
  trackPointerMove: () => trackPointerMove,
  trackVisualViewport: () => trackVisualViewport
});
module.exports = __toCommonJS(src_exports);

// src/add-dom-event.ts
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node?.addEventListener(eventName, handler, options);
  return () => {
    node?.removeEventListener(eventName, handler, options);
  };
};

// src/assertion.ts
function isKeyboardClick(e) {
  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
function isVirtualPointerEvent(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse";
}
function isVirtualClick(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return true;
  return e.detail === 0 && !e.pointerType;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isCtrlKey(e) && e.button === 0;
};
var isModifiedEvent = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isMac = () => /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var isCtrlKey = (e) => isMac() ? e.metaKey && !e.ctrlKey : e.ctrlKey && !e.metaKey;

// src/fire-event.ts
function fireCustomEvent(el, type, init) {
  if (!el)
    return;
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}
function fireBlurEvent(el, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.FocusEvent("blur", init);
  const allowed = el.dispatchEvent(event);
  const bubbleInit = { ...init, bubbles: true };
  el.dispatchEvent(new win.FocusEvent("focusout", bubbleInit));
  return allowed;
}

// src/get-event-key.ts
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}

// src/get-event-step.ts
var PAGE_KEYS = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var ARROW_KEYS = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = PAGE_KEYS.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}

// src/get-native-event.ts
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}

// src/get-element-offset.ts
function getElementOffset(element) {
  let left = 0;
  let top = 0;
  let el = element;
  if (el.parentNode) {
    do {
      left += el.offsetLeft;
      top += el.offsetTop;
    } while ((el = el.offsetParent) && el.nodeType < 9);
    el = element;
    do {
      left -= el.scrollLeft;
      top -= el.scrollTop;
    } while ((el = el.parentNode) && !/body/i.test(el.nodeName));
  }
  return {
    top,
    right: innerWidth - left - element.offsetWidth,
    bottom: innerHeight - top - element.offsetHeight,
    left
  };
}

// src/point-value.ts
var clamp = (value) => Math.max(0, Math.min(1, value));
function getRelativePointValue(absolutePoint, element) {
  const offset = getElementOffset(element);
  const x = absolutePoint.x - offset.left;
  const y = absolutePoint.y - offset.top;
  return {
    x,
    y,
    getDelta(origin) {
      return { x: x - origin.x, y: y - origin.y };
    }
  };
}
function getRelativePointPercent(absolutePoint, element) {
  const relativePoint = getRelativePointValue(absolutePoint, element);
  const x = clamp(relativePoint.x / element.offsetWidth);
  const y = clamp(relativePoint.y / element.offsetHeight);
  return {
    x,
    y,
    normalize(options = {}) {
      const { dir = "ltr", orientation = "horizontal" } = options;
      let newX = x;
      if (orientation === "horizontal" && dir === "rtl")
        newX = 1 - newX;
      return orientation === "horizontal" ? newX : y;
    }
  };
}

// src/request-pointer-lock.ts
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn?.(isLocked());
  }
  function onPointerError(event) {
    if (isLocked())
      fn?.(false);
    console.error("PointerLock error occured:", event);
    doc.exitPointerLock();
  }
  if (!supported)
    return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}

// src/track-pointer-move.ts
var import_text_selection = require("@zag-js/text-selection");
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const x = event.clientX;
    const y = event.clientY;
    const distance = Math.sqrt(x ** 2 + y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer)
      return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point: { x, y }, event });
  };
  const cleanups = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    (0, import_text_selection.disableTextSelection)({ doc })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup());
  };
}

// src/track-visual-viewport.ts
function trackVisualViewport(doc, fn) {
  const win = doc?.defaultView || window;
  const onResize = () => {
    fn?.(getViewportSize(win));
  };
  onResize();
  return addDomEvent(win.visualViewport ?? win, "resize", onResize);
}
function getViewportSize(win) {
  return {
    width: win.visualViewport?.width || win.innerWidth,
    height: win.visualViewport?.height || win.innerHeight
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addDomEvent,
  fireBlurEvent,
  fireCustomEvent,
  getEventKey,
  getEventStep,
  getNativeEvent,
  getRelativePointPercent,
  getRelativePointValue,
  isContextMenuEvent,
  isCtrlKey,
  isKeyboardClick,
  isLeftClick,
  isModifiedEvent,
  isPrintableKey,
  isVirtualClick,
  isVirtualPointerEvent,
  requestPointerLock,
  trackPointerMove,
  trackVisualViewport
});
