'use strict';

var path = require('path');
var core = require('@babel/core');
var types = require('@solid-devtools/debugger/types');
var t2 = require('@babel/types');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path__default = /*#__PURE__*/_interopDefault(path);
var t2__namespace = /*#__PURE__*/_interopNamespace(t2);

// src/vite/index.ts
var MARK_COMPONENT_GLOBAL = `_$markComponentLoc`;
var cwd = process.cwd();
var projectPathAst = core.template(`globalThis.${types.WINDOW_PROJECTPATH_PROPERTY} = %%loc%%;`)({
  loc: t2__namespace.stringLiteral(cwd)
});
var buildMarkComponent = core.template(`globalThis.${MARK_COMPONENT_GLOBAL}(%%loc%%);`);
var isUpperCase = (s) => /^[A-Z]/.test(s);
var getLocationAttribute = (filePath, line, column) => `${filePath}:${line}:${column}`;
function getNodeLocationAttribute(node, state, isJSX = false) {
  if (!node.loc || typeof state.filename !== "string")
    return;
  return getLocationAttribute(
    path__default.default.relative(cwd, state.filename),
    node.loc.start.line,
    // 2 is added to place the caret after the "<" character
    node.loc.start.column + (isJSX ? 2 : 0)
  );
}
var transformCurrentFile = false;
var jsxLocationPlugin = (config) => ({
  name: "@solid-devtools/location",
  visitor: {
    Program(path2, state) {
      transformCurrentFile = false;
      if (typeof state.filename !== "string" || !state.filename.includes(cwd))
        return;
      transformCurrentFile = true;
      path2.node.body.push(projectPathAst);
    },
    ...config.jsx && {
      JSXOpeningElement(path2, state) {
        const { openingElement } = path2.container;
        if (!transformCurrentFile || openingElement.name.type !== "JSXIdentifier")
          return;
        if (isUpperCase(openingElement.name.name))
          return;
        const location = getNodeLocationAttribute(openingElement, state, true);
        if (!location)
          return;
        openingElement.attributes.push(
          t2__namespace.jsxAttribute(t2__namespace.jsxIdentifier(types.LOCATION_ATTRIBUTE_NAME), t2__namespace.stringLiteral(location))
        );
      }
    },
    ...config.components && {
      FunctionDeclaration(path2, state) {
        if (!transformCurrentFile || !path2.node.id || !isUpperCase(path2.node.id.name))
          return;
        const location = getNodeLocationAttribute(path2.node, state);
        if (!location)
          return;
        path2.node.body.body.unshift(buildMarkComponent({ loc: t2__namespace.stringLiteral(location) }));
      },
      VariableDeclarator(path2, state) {
        const { init, id } = path2.node;
        if (!transformCurrentFile || !("name" in id) || !isUpperCase(id.name) || !init || init.type !== "FunctionExpression" && init.type !== "ArrowFunctionExpression" || init.body.type !== "BlockStatement")
          return;
        const location = getNodeLocationAttribute(path2.node, state);
        if (!location)
          return;
        init.body.body.unshift(buildMarkComponent({ loc: t2__namespace.stringLiteral(location) }));
      }
    }
  }
});
var location_default = jsxLocationPlugin;
var nameId = t2__namespace.identifier("name");
function equal(a, b) {
  if (a.type !== b.type)
    return false;
  switch (a.type) {
    case "Identifier":
    case "V8IntrinsicIdentifier":
      return a.name === b.name;
    case "PrivateName":
      return a.id === b.id;
    case "MemberExpression":
      return equal(a.object, b.object) && equal(a.property, b.property);
    default:
      return false;
  }
}
var optionsArg = {
  createSignal: 1,
  createMemo: 2,
  createStore: 1,
  createMutable: 1
};
var sources;
var namePlugin = {
  name: "@solid-devtools/name",
  visitor: {
    Program() {
      sources = {
        createSignal: [],
        createMemo: [],
        createStore: [],
        createMutable: []
      };
    },
    // Track imported references to createSignal/createMemo/createStore/createMutable
    ImportDeclaration(path2) {
      const node = path2.node;
      const source = node.source.value;
      let targets;
      switch (source) {
        case "solid-js":
          targets = ["createSignal", "createMemo"];
          break;
        case "solid-js/store":
          targets = ["createStore", "createMutable"];
          break;
        default:
          return;
      }
      for (const s of node.specifiers) {
        switch (s.type) {
          case "ImportNamespaceSpecifier":
            for (const target2 of targets) {
              sources[target2].push(t2__namespace.memberExpression(s.local, t2__namespace.identifier(target2)));
            }
            break;
          case "ImportSpecifier":
            let target;
            switch (s.imported.type) {
              case "Identifier":
                if (!targets.includes(s.imported.name))
                  continue;
                target = s.imported.name;
                break;
              case "StringLiteral":
                if (!targets.includes(s.imported.value))
                  continue;
                target = s.imported.value;
                break;
              default:
                continue;
            }
            sources[target].push(s.local);
            break;
        }
      }
    },
    VariableDeclaration(path2) {
      const declarations = path2.node.declarations;
      for (const declaration of declarations) {
        const init = declaration.init;
        if (!init)
          continue;
        if (init.type !== "CallExpression")
          continue;
        let target;
        for (const [someTarget, someSources] of Object.entries(sources)) {
          if (someSources.some((source) => equal(init.callee, source))) {
            target = someTarget;
            break;
          }
        }
        if (!target)
          continue;
        const id = declaration.id;
        let name;
        switch (id.type) {
          case "Identifier":
            name = id.name;
            break;
          case "ArrayPattern":
            if (!id.elements.length)
              continue;
            const first = id.elements[0];
            if (!first)
              continue;
            if (first.type !== "Identifier")
              continue;
            name = first.name;
            break;
          default:
            continue;
        }
        const nameProperty = t2__namespace.objectProperty(nameId, t2__namespace.stringLiteral(name));
        const argIndex = optionsArg[target];
        while (init.arguments.length < argIndex) {
          init.arguments.push(t2__namespace.identifier("undefined"));
        }
        if (init.arguments.length === argIndex) {
          init.arguments.push(t2__namespace.objectExpression([nameProperty]));
        } else {
          const options = init.arguments[argIndex];
          if (options.type !== "ObjectExpression")
            continue;
          if (options.properties.some(
            (property) => property.type === "ObjectProperty" && property.key.type === "Identifier" && property.key.name === nameId.name
          ))
            continue;
          options.properties.unshift(nameProperty);
          break;
        }
      }
    }
  }
};
var name_default = namePlugin;

// src/vite/index.ts
var CLIENT_MODULE = "solid-devtools";
var INJECT_SCRIPT_ID = "/__solid-devtools";
function getFileExtension(filename) {
  const index = filename.lastIndexOf(".");
  return index < 0 ? "" : filename.substring(index + 1);
}
var devtoolsPlugin = (_options = {}) => {
  const options = {
    autoname: _options.autoname ?? false,
    locator: _options.locator ? {
      targetIDE: false,
      jsxLocation: false,
      componentLocation: false,
      ..._options.locator === true ? {} : _options.locator
    } : void 0
    // SDT_DEV: _options.SDT_DEV ?? false,
  };
  const enabledJsxLocation = !!options.locator?.jsxLocation;
  const enabledComponentLocation = !!options.locator?.componentLocation;
  let enablePlugin = false;
  const projectRoot = process.cwd();
  let solidStartRootEntry;
  return {
    name: "solid-devtools",
    enforce: "pre",
    configResolved(config) {
      enablePlugin = config.command === "serve" && config.mode !== "production";
      if ("solidOptions" in config && typeof config.solidOptions === "object") {
        const solidOptions = config.solidOptions;
        solidStartRootEntry = path__default.default.normalize(solidOptions.rootEntry);
      }
    },
    transformIndexHtml() {
      if (enablePlugin)
        return [
          {
            tag: "script",
            attrs: { type: "module", src: INJECT_SCRIPT_ID },
            injectTo: "body-prepend"
          }
        ];
    },
    resolveId(id) {
      if (id === INJECT_SCRIPT_ID)
        return INJECT_SCRIPT_ID;
    },
    load(id) {
      if (!enablePlugin || id !== INJECT_SCRIPT_ID)
        return;
      const importPath = JSON.stringify(CLIENT_MODULE);
      let code = `import ${importPath};`;
      if (options.locator) {
        code += `
import { ${types.USE_LOCATOR}, ${types.MARK_COMPONENT} } from ${importPath};
    ${types.USE_LOCATOR}(${JSON.stringify(options.locator)});
    window.${MARK_COMPONENT_GLOBAL} = ${types.MARK_COMPONENT};`;
      }
      return code;
    },
    async transform(source, id, transformOptions) {
      if (transformOptions?.ssr || !enablePlugin)
        return;
      const extension = getFileExtension(id);
      if (!["js", "jsx", "ts", "tsx"].includes(extension))
        return;
      const isJSX = extension === "jsx" || extension === "tsx";
      const plugins = [];
      if ((enabledJsxLocation || enabledComponentLocation) && isJSX) {
        plugins.push(
          location_default({
            jsx: enabledJsxLocation,
            components: enabledComponentLocation
          })
        );
      }
      if (options.autoname) {
        plugins.push(name_default);
      }
      if (solidStartRootEntry && path__default.default.normalize(id) === solidStartRootEntry) {
        source = `import ${JSON.stringify(INJECT_SCRIPT_ID)}
${source}`;
      }
      if (plugins.length === 0)
        return { code: source };
      plugins.splice(0, 0, ["@babel/plugin-syntax-typescript", { isTSX: isJSX }]);
      const result = await core.transformAsync(source, {
        babelrc: false,
        configFile: false,
        root: projectRoot,
        filename: id,
        sourceFileName: id,
        plugins
      });
      return { code: result?.code ?? source };
    }
  };
};

module.exports = devtoolsPlugin;
