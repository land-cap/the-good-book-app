import { Accessor, Setter, AccessorArray, NoInfer, EffectFunction, onCleanup, SignalOptions, createSignal } from 'solid-js';
export { isServer } from 'solid-js/web';
export { EffectOptions, OnOptions, ResolvedChildren, ResolvedJSXElement } from 'solid-js/types/reactive/signal';

/**
 * Can be single or in an array
 */
type Many<T> = T | T[];
type Values<O extends Object> = O[keyof O];
type Noop = (...a: any[]) => void;
type Directive<P = true> = (el: Element, props: Accessor<P>) => void;
/**
 * Infers the type of the array elements
 */
type ItemsOf<T> = T extends (infer E)[] ? E : never;
type ItemsOfMany<T> = T extends any[] ? ItemsOf<T> : T;
type SetterParam<T> = Parameters<Setter<T>>[0];
/**
 * T or a reactive/non-reactive function returning T
 */
type MaybeAccessor<T> = T | Accessor<T>;
/**
 * Accessed value of a MaybeAccessor
 * @example
 * ```ts
 * MaybeAccessorValue<MaybeAccessor<string>>
 * // => string
 * MaybeAccessorValue<MaybeAccessor<() => string>>
 * // => string | (() => string)
 * MaybeAccessorValue<MaybeAccessor<string> | Function>
 * // => string | void
 * ```
 */
type MaybeAccessorValue<T extends MaybeAccessor<any>> = T extends () => any ? ReturnType<T> : T;
type OnAccessEffectFunction<S, Prev, Next extends Prev = Prev> = (input: AccessReturnTypes<S>, prevInput: AccessReturnTypes<S>, v: Prev) => Next;
type AccessReturnTypes<S> = S extends MaybeAccessor<any>[] ? {
    [I in keyof S]: AccessReturnTypes<S[I]>;
} : MaybeAccessorValue<S>;
/** Allows to make shallow overwrites to an interface */
type Modify<T, R> = Omit<T, keyof R> & R;
/** Allows to make nested overwrites to an interface */
type ModifyDeep<A extends AnyObject, B extends DeepPartialAny<A>> = {
    [K in keyof A]: B[K] extends never ? A[K] : B[K] extends AnyObject ? ModifyDeep<A[K], B[K]> : B[K];
} & (A extends AnyObject ? Omit<B, keyof A> : A);
/** Makes each property optional and turns each leaf property into any, allowing for type overrides by narrowing any. */
type DeepPartialAny<T> = {
    [P in keyof T]?: T[P] extends AnyObject ? DeepPartialAny<T[P]> : any;
};
/** Removes the `[...list]` functionality */
type NonIterable<T> = T & {
    [Symbol.iterator]: never;
};
/** Unwraps the type definition of an object, making it more readable */
type Simplify<T> = T extends object ? {
    [K in keyof T]: T[K];
} : T;
/** Unboxes type definition, making it more readable */
type UnboxLazy<T> = T extends () => infer U ? U : T;
/** Get the required keys of an object */
type RequiredKeys<T> = keyof {
    [K in keyof T as T extends {
        [_ in K]: unknown;
    } ? K : never]: 0;
};
/** Remove the first item of a tuple [1, 2, 3, 4] => [2, 3, 4] */
type Tail<T extends any[]> = ((...t: T) => void) extends (x: any, ...u: infer U) => void ? U : never;
/** `A | B => A & B` */
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type ExtractIfPossible<T, U> = Extract<T, U> extends never ? U : Extract<T, U>;
type AnyObject = Record<PropertyKey, any>;
type AnyStatic = [] | any[] | AnyObject;
type AnyFunction = (...args: any[]) => any;
type AnyClass = abstract new (...args: any) => any;
type PrimitiveValue = PropertyKey | boolean | bigint | null | undefined;
type FalsyValue = false | 0 | "" | null | undefined;
type Truthy<T> = Exclude<T, FalsyValue>;
type Falsy<T> = Extract<T, FalsyValue>;
type Position = {
    x: number;
    y: number;
};
type RawNarrow<T> = (T extends [] ? [] : never) | (T extends string | number | bigint | boolean ? T : never) | {
    [K in keyof T]: T[K] extends Function ? T[K] : RawNarrow<T[K]>;
};
type Narrow<T extends any> = T extends [] ? T : RawNarrow<T>;

/** no operation */
declare const noop: Noop;
declare const trueFn: () => boolean;
declare const falseFn: () => boolean;

declare const isClient: boolean;
declare const isDev: boolean;
declare const isProd: boolean;
/**
 * Check if the value is an instance of ___
 */
declare const ofClass: (v: any, c: AnyClass) => boolean;
/** Check if value is typeof "object" or "function" */
declare function isObject(value: any): value is AnyObject;
declare const compare: (a: any, b: any) => number;
/**
 * Check shallow array equality
 */
declare const arrayEquals: (a: readonly unknown[], b: readonly unknown[]) => boolean;
/**
 * Returns a function that will call all functions in the order they were chained with the same arguments.
 */
declare function chain<Args extends [] | any[]>(callbacks: {
    [Symbol.iterator](): IterableIterator<((...args: Args) => any) | undefined>;
}): (...args: Args) => void;
/**
 * Returns a function that will call all functions in the reversed order with the same arguments.
 */
declare function reverseChain<Args extends [] | any[]>(callbacks: (((...args: Args) => any) | undefined)[]): (...args: Args) => void;
declare const clamp: (n: number, min: number, max: number) => number;
/**
 * Accesses the value of a MaybeAccessor
 * @example
 * ```ts
 * access("foo") // => "foo"
 * access(() => "foo") // => "foo"
 * ```
 */
declare const access: <T extends unknown>(v: T) => MaybeAccessorValue<T>;
declare const asArray: <T>(value: T) => (T extends any[] ? T[number] : T)[];
/**
 * Access an array of MaybeAccessors
 * @example
 * const list = [1, 2, () => 3)] // T: MaybeAccessor<number>[]
 * const newList = accessArray(list) // T: number[]
 */
declare const accessArray: <A extends unknown>(list: readonly A[]) => MaybeAccessorValue<A>[];
/**
 * Run the function if the accessed value is not `undefined` nor `null`
 * @param value
 * @param fn
 */
declare const withAccess: <T, A extends MaybeAccessor<T>, V = MaybeAccessorValue<A>>(value: A, fn: (value: NonNullable<V>) => void) => void;
declare const asAccessor: <A extends unknown>(v: A) => Accessor<MaybeAccessorValue<A>>;
/** If value is a function – call it with a given arguments – otherwise get the value as is */
declare function accessWith<T>(valueOrFn: T, ...args: T extends AnyFunction ? Parameters<T> : never): T extends AnyFunction ? ReturnType<T> : T;
/**
 * Solid's `on` helper, but always defers and returns a provided initial value when if does instead of `undefined`.
 *
 * @param deps
 * @param fn
 * @param initialValue
 */
declare function defer<S, Next extends Prev, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: (input: S, prevInput: S, prev: undefined | NoInfer<Prev>) => Next, initialValue: Next): EffectFunction<undefined | NoInfer<Next>, NoInfer<Next>>;
declare function defer<S, Next extends Prev, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: (input: S, prevInput: S, prev: undefined | NoInfer<Prev>) => Next, initialValue?: undefined): EffectFunction<undefined | NoInfer<Next>>;
/**
 * Get entries of an object
 */
declare const entries: <T extends object>(obj: T) => [keyof T, T[keyof T]][];
/**
 * Get keys of an object
 */
declare const keys: <T extends object>(object: T) => (keyof T)[];
/**
 * Solid's `onCleanup` that is registered only if there is a root.
 */
declare const tryOnCleanup: typeof onCleanup;
declare const createCallbackStack: <A0 = void, A1 = void, A2 = void, A3 = void>() => {
    push: (...callbacks: ((arg0: A0, arg1: A1, arg2: A2, arg3: A3) => void)[]) => void;
    execute: (arg0: A0, arg1: A1, arg2: A2, arg3: A3) => void;
    clear: VoidFunction;
};
/**
 * Group synchronous function calls.
 * @param fn
 * @returns `fn`
 */
declare function createMicrotask<A extends any[] | []>(fn: (...a: A) => void): (...a: A) => void;
/**
 * A hydratable version of the {@link createSignal}. It will use the serverValue on the server and the update function on the client. If initialized during hydration it will use serverValue as the initial value and update it once hydration is complete.
 *
 * @param serverValue initial value of the state on the server
 * @param update called once on the client or on hydration to initialize the value
 * @param options {@link SignalOptions}
 * @returns
 * ```ts
 * [state: Accessor<T>, setState: Setter<T>]
 * ```
 * @see {@link createSignal}
 */
declare function createHydratableSignal<T>(serverValue: T, update: () => T, options?: SignalOptions<T>): ReturnType<typeof createSignal<T>>;
/** @deprecated use {@link createHydratableSignal} instead */
declare const createHydrateSignal: typeof createHydratableSignal;
type StaticStoreSetter<T extends Readonly<AnyStatic>> = {
    (setter: (prev: T) => Partial<T>): T;
    (state: Partial<T>): T;
    <K extends keyof T>(key: K, state: SetterParam<T[K]>): T;
};
/**
 * A shallowly wrapped reactive store object. It behaves similarly to the createStore, but with limited features to keep it simple. Designed to be used for reactive objects with static keys, but dynamic values, like reactive Event State, location, etc.
 * @param init initial value of the store
 * @returns
 * ```ts
 * [access: Readonly<T>, write: StaticStoreSetter<T>]
 * ```
 */
declare function createStaticStore<T extends Readonly<AnyStatic>>(init: T): [access: T, write: StaticStoreSetter<T>];
/**
 * A hydratable version of the {@link createStaticStore}. It will use the serverValue on the server and the update function on the client. If initialized during hydration it will use serverValue as the initial value and update it once hydration is complete.
 *
 * @param serverValue initial value of the state on the server
 * @param update called once on the client or on hydration to initialize the value
 * @returns
 * ```ts
 * [access: Readonly<T>, write: StaticStoreSetter<T>]
 * ```
 */
declare function createHydratableStaticStore<T extends Readonly<AnyStatic>>(serverValue: T, update: () => T): ReturnType<typeof createStaticStore<T>>;
/**
 * Handle items removed and added to the array by diffing it by refference.
 *
 * @param current new array instance
 * @param prev previous array copy
 * @param handleAdded called once for every added item to array
 * @param handleRemoved called once for every removed from array
 */
declare function handleDiffArray<T>(current: readonly T[], prev: readonly T[], handleAdded: (item: T) => void, handleRemoved: (item: T) => void): void;

export { AccessReturnTypes, AnyClass, AnyFunction, AnyObject, AnyStatic, DeepPartialAny, Directive, ExtractIfPossible, Falsy, FalsyValue, ItemsOf, ItemsOfMany, Many, MaybeAccessor, MaybeAccessorValue, Modify, ModifyDeep, Narrow, NonIterable, Noop, OnAccessEffectFunction, Position, PrimitiveValue, RequiredKeys, SetterParam, Simplify, StaticStoreSetter, Tail, Truthy, UnboxLazy, UnionToIntersection, Values, access, accessArray, accessWith, arrayEquals, asAccessor, asArray, chain, clamp, compare, createCallbackStack, createHydratableSignal, createHydratableStaticStore, createHydrateSignal, createMicrotask, createStaticStore, defer, entries, falseFn, handleDiffArray, isClient, isDev, isObject, isProd, keys, noop, ofClass, reverseChain, trueFn, tryOnCleanup, withAccess };
