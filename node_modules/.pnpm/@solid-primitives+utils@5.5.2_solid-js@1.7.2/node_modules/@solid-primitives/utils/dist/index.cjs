'use strict';

var solidJs = require('solid-js');
var web = require('solid-js/web');

// src/index.ts
exports.noop = () => void 0;
exports.trueFn = () => true;
exports.falseFn = () => false;
exports.isClient = !web.isServer;
exports.isDev = exports.isClient && !!solidJs.DEV;
exports.isProd = !exports.isDev;
exports.ofClass = (v, c) => v instanceof c || v && v.constructor === c;
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
exports.compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;
exports.arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);
function chain(callbacks) {
  return (...args) => {
    for (const callback of callbacks)
      callback && callback(...args);
  };
}
function reverseChain(callbacks) {
  return (...args) => {
    for (let i = callbacks.length - 1; i >= 0; i--) {
      const callback = callbacks[i];
      callback && callback(...args);
    }
  };
}
exports.clamp = (n, min, max) => Math.min(Math.max(n, min), max);
exports.access = (v) => typeof v === "function" && !v.length ? v() : v;
exports.asArray = (value) => Array.isArray(value) ? value : [value];
exports.accessArray = (list) => list.map((v) => exports.access(v));
exports.withAccess = (value, fn) => {
  const _value = exports.access(value);
  typeof _value != null && fn(_value);
};
exports.asAccessor = (v) => typeof v === "function" ? v : () => v;
function accessWith(valueOrFn, ...args) {
  return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}
function defer(deps, fn, initialValue) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let shouldDefer = true;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++)
        input[i] = deps[i]();
    } else
      input = deps();
    if (shouldDefer) {
      shouldDefer = false;
      prevInput = input;
      return initialValue;
    }
    const result = solidJs.untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
exports.entries = Object.entries;
exports.keys = Object.keys;
exports.tryOnCleanup = (fn) => solidJs.getOwner() ? solidJs.onCleanup(fn) : fn;
exports.createCallbackStack = () => {
  let stack = [];
  const clear = () => stack = [];
  return {
    push: (...callbacks) => stack.push(...callbacks),
    execute(arg0, arg1, arg2, arg3) {
      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));
      clear();
    },
    clear
  };
};
function createMicrotask(fn) {
  let calls = 0;
  let args;
  return (...a) => {
    args = a, calls++;
    queueMicrotask(() => --calls === 0 && fn(...args));
  };
}
function createHydratableSignal(serverValue, update, options) {
  if (web.isServer) {
    return solidJs.createSignal(serverValue, options);
  }
  if (solidJs.sharedConfig.context) {
    const [state, setState] = solidJs.createSignal(serverValue, options);
    solidJs.onMount(() => setState(() => update()));
    return [state, setState];
  }
  return solidJs.createSignal(update(), options);
}
exports.createHydrateSignal = createHydratableSignal;
function createStaticStore(init) {
  const copy = { ...init };
  const store = { ...init };
  const cache = /* @__PURE__ */ new Map();
  const getValue = (key) => {
    const saved = cache.get(key);
    if (saved)
      return saved[0]();
    const signal = solidJs.createSignal(copy[key], {
      internal: true
    });
    cache.set(key, signal);
    delete copy[key];
    return signal[0]();
  };
  const setValue = (key, value) => {
    const saved = cache.get(key);
    if (saved)
      return saved[1](value);
    if (key in copy)
      copy[key] = accessWith(value, [copy[key]]);
  };
  for (const key in init) {
    Object.defineProperty(store, key, { get: getValue.bind(void 0, key) });
  }
  const setter = (a, b) => {
    if (isObject(a)) {
      const entries2 = solidJs.untrack(
        () => Object.entries(accessWith(a, store))
      );
      solidJs.batch(() => {
        for (const [key, value] of entries2)
          setValue(key, () => value);
      });
    } else
      setValue(a, b);
    return store;
  };
  return [store, setter];
}
function createHydratableStaticStore(serverValue, update) {
  if (web.isServer)
    return createStaticStore(serverValue);
  if (solidJs.sharedConfig.context) {
    const [state, setState] = createStaticStore(serverValue);
    solidJs.onMount(() => setState(update()));
    return [state, setState];
  }
  return createStaticStore(update());
}
function handleDiffArray(current, prev, handleAdded, handleRemoved) {
  const currLength = current.length;
  const prevLength = prev.length;
  let i = 0;
  if (!prevLength) {
    for (; i < currLength; i++)
      handleAdded(current[i]);
    return;
  }
  if (!currLength) {
    for (; i < prevLength; i++)
      handleRemoved(prev[i]);
    return;
  }
  for (; i < prevLength; i++) {
    if (prev[i] !== current[i])
      break;
  }
  let prevEl;
  let currEl;
  prev = prev.slice(i);
  current = current.slice(i);
  for (prevEl of prev) {
    if (!current.includes(prevEl))
      handleRemoved(prevEl);
  }
  for (currEl of current) {
    if (!prev.includes(currEl))
      handleAdded(currEl);
  }
}

Object.defineProperty(exports, 'isServer', {
  enumerable: true,
  get: function () { return web.isServer; }
});
exports.accessWith = accessWith;
exports.chain = chain;
exports.createHydratableSignal = createHydratableSignal;
exports.createHydratableStaticStore = createHydratableStaticStore;
exports.createMicrotask = createMicrotask;
exports.createStaticStore = createStaticStore;
exports.defer = defer;
exports.handleDiffArray = handleDiffArray;
exports.isObject = isObject;
exports.reverseChain = reverseChain;
