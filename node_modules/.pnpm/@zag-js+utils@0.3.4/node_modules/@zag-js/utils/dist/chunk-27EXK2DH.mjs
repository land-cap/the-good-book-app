// src/array.ts
function toArray(v) {
  if (!v)
    return [];
  return Array.isArray(v) ? v : [v];
}
var fromLength = (length) => Array.from(Array(length).keys());
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var isEmpty = (v) => v.length === 0;
var has = (v, t) => v.indexOf(t) !== -1;
var add = (v, ...items) => v.concat(items);
var remove = (v, item) => removeAt(v, v.indexOf(item));
var removeAt = (v, i) => {
  if (i > -1)
    v.splice(i, 1);
  return v;
};
function clear(v) {
  while (v.length > 0)
    v.pop();
  return v;
}
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1)
    return step > 0 ? 0 : last2;
  if (next2 < 0)
    return loop ? last2 : 0;
  if (next2 >= len)
    return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function next(v, idx, opts = {}) {
  return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
function prev(v, index, opts = {}) {
  return v[prevIndex(v, index, opts)];
}
var chunk = (v, size) => {
  const res = [];
  return v.reduce((rows, value, index) => {
    if (index % size === 0)
      rows.push([value]);
    else
      last(rows)?.push(value);
    return rows;
  }, res);
};

export {
  toArray,
  fromLength,
  first,
  last,
  isEmpty,
  has,
  add,
  remove,
  removeAt,
  clear,
  nextIndex,
  next,
  prevIndex,
  prev,
  chunk
};
