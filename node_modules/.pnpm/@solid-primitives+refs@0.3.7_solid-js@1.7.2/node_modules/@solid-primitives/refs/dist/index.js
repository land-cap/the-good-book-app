import { filterInstance, remove, removeItems } from '@solid-primitives/immutable';
import { createSubRoot } from '@solid-primitives/rootless';
import { asArray, access } from '@solid-primitives/utils';
import { createMemo, onCleanup, getOwner, createSignal, createComputed, on, children, untrack, onMount } from 'solid-js';

// src/index.ts
function mergeRefs(setRef, propsRef) {
  return (el) => {
    setRef(el);
    propsRef?.(el);
  };
}
var mutableRemove = (list, item) => {
  const index = list.indexOf(item);
  list.splice(index, 1);
};
function getChangedItems(prevList, list) {
  const prev = prevList.slice();
  const added = [];
  for (const el of list) {
    const index = prev.indexOf(el);
    if (index !== -1)
      prev.splice(index, 1);
    else
      added.push(el);
  }
  return [added, prev];
}
var getAddedItems = (prevList, list) => list.filter((item) => !prevList.includes(item));
var getRemovedItems = (prevList, list) => prevList.filter((item) => !list.includes(item));
function resolveElements(value) {
  let resolved = getResolvedElements(value);
  if (Array.isArray(resolved) && !resolved.length)
    resolved = null;
  return resolved;
}
function getResolvedElements(value) {
  if (typeof value === "function" && !value.length)
    return getResolvedElements(value());
  if (Array.isArray(value)) {
    const results = [];
    for (const item of value) {
      const result = getResolvedElements(item);
      if (result)
        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return value instanceof HTMLElement ? value : null;
}
function elements(fn, ...types) {
  return createMemo(() => filterInstance(asArray(fn()), ...types.length ? types : [Element]));
}
function refs(fn, ...types) {
  const resolved = elements(fn, ...types);
  let prev = [];
  const memo = createMemo(() => {
    const list = resolved();
    const [added, removed] = getChangedItems(prev, list);
    prev = list;
    return { refs: list.slice(), added, removed };
  });
  return [() => memo().refs, () => memo().added, () => memo().removed];
}
var unmount = (el, handler) => {
  onCleanup(() => handler()(el));
};
function mapRemoved(list, mapFn) {
  let prevList = [];
  const saved = /* @__PURE__ */ new Set();
  const indexes = mapFn.length > 1 ? /* @__PURE__ */ new Map() : void 0;
  const owner = getOwner();
  const [items, setItems] = createSignal([]);
  createComputed(
    on(list, (_list) => {
      const { length } = prevList;
      const newList = asArray(_list).slice();
      if (!length)
        return setItems(prevList = newList);
      for (let pi = 0, ni = 0; pi < length; ) {
        const item = prevList[pi];
        if (newList.includes(item))
          pi++, ni++;
        else if (saved.has(item)) {
          const x = prevList.indexOf(newList[ni]);
          if (x !== -1 && x <= pi)
            ni++;
          else {
            newList.splice(ni, 0, item);
            indexes?.get(item)?.(ni);
            pi++;
          }
        } else
          mapRemovedElement(newList, item, pi), pi++;
      }
      setItems(prevList = newList);
    })
  );
  let toRemove = [];
  const executeToRemove = () => {
    if (!toRemove.length)
      return;
    setItems((p) => removeItems(p, ...toRemove));
    toRemove = [];
  };
  function mapRemovedElement(newList, item, i) {
    createSubRoot((dispose) => {
      let signal, mapped;
      if (indexes) {
        const [index, setIndex] = createSignal(i);
        const s = mapFn(item, index);
        const m = access(s);
        if (!m)
          return dispose();
        indexes.set(m, setIndex);
        signal = s, mapped = m;
      } else {
        const s = mapFn(item);
        const m = access(s);
        if (!m)
          return dispose();
        signal = s, mapped = m;
      }
      saved.add(mapped);
      newList.splice(i, 0, mapped);
      let prev = mapped;
      createComputed(on(signal, (signalValue) => {
        saved.delete(prev);
        if (indexes) {
          const set = indexes.get(prev);
          indexes.delete(prev);
          if (signalValue)
            set && indexes.set(signalValue, set);
          else {
            const listValue = items();
            for (i = listValue.indexOf(prev); i < listValue.length; i++) {
              indexes.get(listValue[i])?.((p) => --p);
            }
          }
        }
        if (!signalValue) {
          mutableRemove(prevList, prev);
          toRemove.push(prev);
          queueMicrotask(executeToRemove);
          return dispose();
        }
        saved.add(signalValue);
        setItems((p) => remove(p, prev, signalValue));
        prev = signalValue;
      }, { defer: true }));
    }, owner);
  }
  return items;
}
var Children = (props) => {
  const resolved = children(() => props.children);
  createComputed(on(resolved, props.get));
  onCleanup(() => props.get(void 0));
  return resolved;
};
var Refs = (props) => {
  const resolved = children(() => props.children);
  if (props.added || props.removed || props.onChange) {
    const [elementList, added, removed] = refs(resolved);
    const emit = (refValue, addedValue, removedValue) => untrack(() => {
      props.refs?.(refValue);
      props.added?.(addedValue);
      props.removed?.(removedValue);
      props.onChange?.({ refs: refValue, added: addedValue, removed: removedValue });
    });
    createComputed(() => emit(elementList(), added(), removed()));
    onCleanup(() => emit([], [], elementList()));
  } else if (props.refs) {
    const cb = props.refs;
    const refList = elements(resolved);
    createComputed(() => cb(refList()));
    onCleanup(() => cb([]));
  }
  return resolved;
};
var Ref = (props) => {
  const resolved = children(() => props.children);
  let prev;
  createComputed(() => {
    const el = (() => {
      let newEl = access(resolved());
      if (!(newEl instanceof Element))
        newEl = void 0;
      return newEl;
    })();
    untrack(() => {
      props.ref?.(el);
      if (el && prev !== el)
        onMount(() => props.onMount?.(el));
      if (prev && prev !== el && props.onUnmount)
        props.onUnmount(prev);
    });
    prev = el;
  });
  onCleanup(() => {
    if (prev) {
      props.ref?.(void 0);
      props.onUnmount?.(prev);
    }
  });
  return resolved;
};

export { Children, Ref, Refs, elements, getAddedItems, getChangedItems, getRemovedItems, mapRemoved, mergeRefs, refs, resolveElements, unmount };
