'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function normaliseOptions(options) {
  if ('leading' in options && 'lineGap' in options) {
    throw new Error('Only a single line height style can be provided. Please pass either `lineGap` OR `leading`.');
  }
  if ('capHeight' in options && 'fontSize' in options) {
    throw new Error('Please pass either `capHeight` OR `fontSize`, not both.');
  }
  const {
    fontMetrics
  } = options;
  const capHeightScale = fontMetrics.capHeight / fontMetrics.unitsPerEm;
  let specifiedFontSize;
  let specifiedCapHeight;
  if ('capHeight' in options) {
    specifiedFontSize = options.capHeight / capHeightScale;
    specifiedCapHeight = options.capHeight;
  } else if ('fontSize' in options) {
    specifiedFontSize = options.fontSize;
    specifiedCapHeight = options.fontSize * capHeightScale;
  } else {
    throw new Error('Please pass either `capHeight` OR `fontSize`.');
  }
  let specifiedLineHeight;
  if ('lineGap' in options) {
    specifiedLineHeight = specifiedCapHeight + options.lineGap;
  } else if ('leading' in options) {
    specifiedLineHeight = options.leading;
  }
  return {
    fontSize: specifiedFontSize,
    lineHeight: specifiedLineHeight,
    fontMetrics
  };
}

/*
   Rounding all values to a precision of `4` based on discovering that browser
   implementations of layout units fall between 1/60th and 1/64th of a pixel.

   Reference: https://trac.webkit.org/wiki/LayoutUnit
   (above wiki also mentions Mozilla - https://trac.webkit.org/wiki/LayoutUnit#Notes)
*/
const round = value => parseFloat(value.toFixed(4));

function precomputeValues(options) {
  const {
    fontSize,
    lineHeight,
    fontMetrics
  } = normaliseOptions(options);
  const absoluteDescent = Math.abs(fontMetrics.descent);
  const capHeightScale = fontMetrics.capHeight / fontMetrics.unitsPerEm;
  const descentScale = absoluteDescent / fontMetrics.unitsPerEm;
  const ascentScale = fontMetrics.ascent / fontMetrics.unitsPerEm;
  const lineGapScale = fontMetrics.lineGap / fontMetrics.unitsPerEm;
  const contentArea = fontMetrics.ascent + fontMetrics.lineGap + absoluteDescent;
  const lineHeightScale = contentArea / fontMetrics.unitsPerEm;
  const lineHeightNormal = lineHeightScale * fontSize;
  const allowForLineHeight = trim => {
    if (lineHeight) {
      const specifiedLineHeightOffset = (lineHeightNormal - lineHeight) / 2;
      return trim - specifiedLineHeightOffset / fontSize;
    }
    return trim;
  };
  const capHeightTrim = allowForLineHeight(ascentScale - capHeightScale + lineGapScale / 2) * -1;
  const baselineTrim = allowForLineHeight(descentScale + lineGapScale / 2) * -1;
  return {
    fontSize: "".concat(round(fontSize), "px"),
    lineHeight: lineHeight ? "".concat(round(lineHeight), "px") : 'normal',
    capHeightTrim: "".concat(round(capHeightTrim), "em"),
    baselineTrim: "".concat(round(baselineTrim), "em")
  };
}

const _createStyleObject = _ref => {
  let {
    lineHeight,
    fontSize,
    capHeightTrim,
    baselineTrim
  } = _ref;
  return {
    fontSize,
    lineHeight,
    '::before': {
      content: "''",
      marginBottom: capHeightTrim,
      display: 'table'
    },
    '::after': {
      content: "''",
      marginTop: baselineTrim,
      display: 'table'
    }
  };
};
function createStyleObject(args) {
  if ('capHeightTrim' in args) {
    return _createStyleObject(args);
  }
  return _createStyleObject(precomputeValues(args));
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

const _excluded$1 = ["::before", "::after"];
function createStyleString(ruleName, options) {
  const _createStyleObject = createStyleObject(options),
    {
      '::before': beforePseudo,
      '::after': afterPseudo
    } = _createStyleObject,
    rootStyles = _objectWithoutProperties(_createStyleObject, _excluded$1);
  const objToCSSRules = (stylesObj, psuedoName) => "\n.".concat(ruleName).concat(psuedoName ? "::".concat(psuedoName) : '', " {\n").concat(Object.keys(stylesObj).map(property => "  ".concat(property.replace(/[A-Z]/g, '-$&').toLowerCase(), ": ").concat(stylesObj[property].replace(/'/g, '"'))).join(';\n'), ";\n}");
  return [objToCSSRules(rootStyles), objToCSSRules(beforePseudo, 'before'), objToCSSRules(afterPseudo, 'after')].join('\n');
}

const getCapHeight = _ref => {
  let {
    fontSize,
    fontMetrics
  } = _ref;
  return round(fontSize * fontMetrics.capHeight / fontMetrics.unitsPerEm);
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, void 0, groups);
  };
  var _super = RegExp.prototype,
    _groups = new WeakMap();
  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);
    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
  }
  function buildGroups(result, re) {
    var g = _groups.get(re);
    return Object.keys(g).reduce(function (groups, name) {
      var i = g[name];
      if ("number" == typeof i) groups[name] = result[i];else {
        for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++;
        groups[name] = result[i[k]];
      }
      return groups;
    }, Object.create(null));
  }
  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);
    return result && (result.groups = buildGroups(result, this)), result;
  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if ("string" == typeof substitution) {
      var groups = _groups.get(this);
      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        return "$" + groups[name];
      }));
    }
    if ("function" == typeof substitution) {
      var _this = this;
      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;
        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
      });
    }
    return _super[Symbol.replace].call(this, str, substitution);
  }, _wrapRegExp.apply(this, arguments);
}

const _excluded = ["fontFamily", "src"];
const toPercentString = value => "".concat(round(value * 100), "%");
const toCssProperty = property => property.replace(/([A-Z])/g, property => "-".concat(property.toLowerCase()));
const calculateOverrideValues = _ref => {
  let {
    metrics,
    fallbackMetrics
  } = _ref;
  // Calculate size adjust
  const preferredFontXAvgRatio = metrics.xWidthAvg / metrics.unitsPerEm;
  const fallbackFontXAvgRatio = fallbackMetrics.xWidthAvg / fallbackMetrics.unitsPerEm;
  const sizeAdjust = preferredFontXAvgRatio && fallbackFontXAvgRatio ? preferredFontXAvgRatio / fallbackFontXAvgRatio : 1;
  const adjustedEmSquare = metrics.unitsPerEm * sizeAdjust;

  // Calculate metric overrides for preferred font
  const ascentOverride = metrics.ascent / adjustedEmSquare;
  const descentOverride = Math.abs(metrics.descent) / adjustedEmSquare;
  const lineGapOverride = metrics.lineGap / adjustedEmSquare;

  // Conditionally populate font face properties and format to percent
  const fontFace = {};
  if (ascentOverride) {
    fontFace['ascentOverride'] = toPercentString(ascentOverride);
  }
  if (descentOverride) {
    fontFace['descentOverride'] = toPercentString(descentOverride);
  }
  if (lineGapOverride) {
    fontFace['lineGapOverride'] = toPercentString(lineGapOverride);
  }
  if (sizeAdjust && sizeAdjust !== 1) {
    fontFace['sizeAdjust'] = toPercentString(sizeAdjust);
  }
  return fontFace;
};
const quoteIfNeeded = name => {
  var _quotedMatch$groups;
  const quotedMatch = name.match( /*#__PURE__*/_wrapRegExp(/^['"](.*)['"]$/, {
    name: 1
  }));
  if (quotedMatch && (_quotedMatch$groups = quotedMatch.groups) !== null && _quotedMatch$groups !== void 0 && _quotedMatch$groups.name) {
    // Escape double quotes in middle of name
    return "\"".concat(quotedMatch.groups.name.split("\"").join("\""), "\"");
  }
  if (/^"/.test(name)) {
    // Complete double quotes if incomplete and escape double quotes in middle
    const [, ...restName] = name;
    return "\"".concat(restName.map(x => x === "\"" ? "\"" : x).join(''), "\"");
  }
  if (!/^[a-zA-Z\d\-_]+$/.test(name)) {
    // Wrap in quotes if contains any characters that are not letters,
    // numbers, hyphens or underscores
    return "\"".concat(name.split("\"").join("\""), "\"");
  }
  return name;
};
const toCssString = fontFaces => {
  return fontFaces.map(_ref2 => {
    let {
        '@font-face': {
          fontFamily,
          src
        }
      } = _ref2,
      restFontFaceProperties = _objectWithoutProperties(_ref2['@font-face'], _excluded);
    const fontFace = ['@font-face {', "  font-family: ".concat(quoteIfNeeded(fontFamily), ";"), "  src: ".concat(src, ";")];
    Object.keys(restFontFaceProperties).forEach(property => {
      fontFace.push("  ".concat(toCssProperty(property), ": ").concat(restFontFaceProperties[property], ";"));
    });
    fontFace.push('}');
    return fontFace.join('\n');
  }).join('\n');
};
function createFontStack(_ref3) {
  let [metrics, ...fallbackMetrics] = _ref3;
  let optionsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    fontFaceFormat,
    fontFaceProperties
  } = _objectSpread2({
    fontFaceFormat: 'styleString'
  }, optionsArg);
  const {
    familyName
  } = metrics;
  const fontFamilies = [quoteIfNeeded(familyName)];
  const fontFaces = [];
  fallbackMetrics.forEach(fallback => {
    const fontFamily = "".concat(familyName, " Fallback").concat(fallbackMetrics.length > 1 ? ": ".concat(fallback.familyName) : '');
    fontFamilies.push(quoteIfNeeded(fontFamily));
    fontFaces.push({
      '@font-face': _objectSpread2(_objectSpread2(_objectSpread2({}, fontFaceProperties), {}, {
        fontFamily,
        src: "local('".concat(fallback.familyName, "')")
      }, calculateOverrideValues({
        metrics,
        fallbackMetrics: fallback
      })), fontFaceProperties !== null && fontFaceProperties !== void 0 && fontFaceProperties.sizeAdjust ? {
        sizeAdjust: fontFaceProperties.sizeAdjust
      } : {})
    });
  });
  return {
    fontFamily: fontFamilies.join(', '),
    fontFaces: {
      styleString: toCssString(fontFaces),
      styleObject: fontFaces
    }[fontFaceFormat]
  };
}

exports.createFontStack = createFontStack;
exports.createStyleObject = createStyleObject;
exports.createStyleString = createStyleString;
exports.getCapHeight = getCapHeight;
exports.precomputeValues = precomputeValues;
