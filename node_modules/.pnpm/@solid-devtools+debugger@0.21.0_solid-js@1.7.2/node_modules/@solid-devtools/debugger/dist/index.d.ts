import { createRoot, ParentComponent } from 'solid-js';
import { L as LocationAttr, C as Core, S as Solid, V as ValueUpdateListener, N as NodeType } from './index-7aa0ad20.js';
export { q as DEFAULT_MAIN_VIEW, t as DEFAULT_WALKER_MODE, D as DGraphUpdate, r as DebuggerModule, p as DevtoolsMainView, g as EncodedValue, E as EncodedValueMap, H as HighlightElementPayload, I as INFINITY, i as InspectorUpdate, h as InspectorUpdateMap, k as LOCATION_ATTRIBUTE_NAME, m as LocatorComponent, j as LocatorOptions, M as MARK_COMPONENT, A as Mapped, e as NAN, d as NEGATIVE_INFINITY, v as NODE_TYPE_NAMES, x as NodeID, P as PropGetterState, b as SerializedDGraph, c as StructureUpdates, n as TargetIDE, o as TargetURLFunction, T as ToggleInspectedValueData, s as TreeWalkerMode, U as UNDEFINED, l as USE_LOCATOR, y as ValueItemID, w as ValueItemType, f as ValueType, W as WINDOW_PROJECTPATH_PROPERTY, z as getValueItemId, u as useDebugger, a as useLocator } from './index-7aa0ad20.js';
import '@solid-devtools/shared/utils';
import '@solid-primitives/keyboard';
import 'solid-js/store/types/store';
import 'solid-js/store';
import 'solid-js/types/reactive/signal';
import '@solid-primitives/event-bus';

declare function markComponentLoc(location: LocationAttr): void;

/**
 * Helps the debugger find and reattach an reactive owner created by `createRoot` to it's detached parent.
 *
 * Call this synchronously inside `createRoot` callback body, whenever you are using `createRoot` yourself to dispose of computations early, or inside `<For>`/`<Index>` components to reattach their children to reactive graph visible by the devtools debugger.
 * @example
 * createRoot(dispose => {
 * 	// This reactive Owner disapears form the owner tree
 *
 * 	// Reattach the Owner to the tree:
 * 	attachDebugger();
 * });
 */
declare function attachDebugger(_owner?: Core.Owner): void;
/**
 * Unobserves currently observed root owners.
 * This is not reversable, and should be used only when you are sure that they won't be used anymore.
 */
declare function unobserveAllRoots(): void;
/**
 * Listens to `createRoot` calls and attaches debugger to them.
 */
declare function enableRootsAutoattach(): void;
/**
 * Sold's `createRoot` primitive that won't be tracked by the debugger.
 */
declare const createInternalRoot: typeof createRoot;

/**
 * Runs the callback on every Solid Graph Update – whenever computations update because of a signal change.
 * The listener is automatically cleaned-up on root dispose.
 *
 * This will listen to all updates of the reactive graph — including ones outside of the <Debugger> component, and debugger internal computations.
 */
declare function makeSolidUpdateListener(onUpdate: VoidFunction): VoidFunction;
/**
 * Patches the "fn" prop of SolidComputation. Will execute the {@link onRun} callback whenever the computation is executed.
 * @param owner computation to patch
 * @param onRun execution handler
 *
 * {@link onRun} is provided with `execute()` function, and a `prev` value. `execute` is the computation handler function, it needs to be called inside {@link onRun} to calculate the next value or run side-effects.
 *
 * @example
 * ```ts
 * interceptComputationRerun(owner, (fn, prev) => {
 * 	// do something before execution
 * 	fn()
 * 	// do something after execution
 * })
 * ```
 */
declare function interceptComputationRerun(owner: Solid.Computation, onRun: <T>(execute: () => T, prev: T) => void): void;
/**
 * Patches the owner/signal value, firing the callback on each update immediately as it happened.
 */
declare function observeValueUpdate(node: Solid.SignalState, onUpdate: ValueUpdateListener, symbol: symbol): void;
declare function removeValueUpdateObserver(node: Solid.SignalState, symbol: symbol): void;
declare function makeValueUpdateListener(node: Solid.SignalState, onUpdate: ValueUpdateListener, symbol: symbol): void;

declare const getOwner: () => Solid.Owner | null;
declare const isSolidComputation: (o: Readonly<Solid.Owner>) => o is Solid.Computation;
declare const isSolidMemo: (o: Readonly<Solid.Owner>) => o is Solid.Memo;
declare const isSolidOwner: (o: Readonly<Solid.Owner | Solid.Store | Solid.Signal>) => o is Solid.Owner;
declare const isSolidRoot: (o: Readonly<Solid.Owner>) => o is Solid.Root;
declare const isSolidStore: (o: Readonly<Solid.Signal | Solid.Store>) => o is Solid.Store;
declare function getNodeName(o: Readonly<Solid.Signal | Solid.Owner | Solid.Store>): string;
declare function getNodeType(o: Readonly<Solid.Signal | Solid.Owner | Solid.Store>): NodeType;
declare const getOwnerType: (o: Readonly<Solid.Owner>) => NodeType;
declare function lookupOwner(owner: Solid.Owner, predicate: (owner: Solid.Owner) => boolean): Solid.Owner | null;
/**
 * Attach onCleanup callback to a reactive owner
 * @param prepend add the callback to the front of the stack, instead of pushing, fot it to be called before other cleanup callbacks.
 * @returns a function to remove the cleanup callback
 */
declare function onOwnerCleanup(owner: Solid.Owner, fn: VoidFunction, prepend?: boolean, symbol?: symbol): VoidFunction;
/**
 * Attach onCleanup callback to the parent of a reactive owner if it has one.
 * @param prepend add the callback to the front of the stack, instead of pushing, fot it to be called before other cleanup callbacks.
 * @returns a function to remove the cleanup callback
 */
declare function onParentCleanup(owner: Solid.Owner, fn: VoidFunction, prepend?: boolean, symbol?: symbol): VoidFunction;
declare function getFunctionSources(fn: () => unknown): Solid.Signal[];

declare const Debugger: ParentComponent;

export { Core, Debugger, LocationAttr, NodeType, Solid, ValueUpdateListener, attachDebugger, createInternalRoot, enableRootsAutoattach, getFunctionSources, getNodeName, getNodeType, getOwner, getOwnerType, interceptComputationRerun, isSolidComputation, isSolidMemo, isSolidOwner, isSolidRoot, isSolidStore, lookupOwner, makeSolidUpdateListener, makeValueUpdateListener, markComponentLoc, observeValueUpdate, onOwnerCleanup, onParentCleanup, removeValueUpdateObserver, unobserveAllRoots };
