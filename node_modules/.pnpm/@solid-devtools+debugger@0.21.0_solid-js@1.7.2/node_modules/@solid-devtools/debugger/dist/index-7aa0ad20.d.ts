import { ToDyscriminatedUnion } from '@solid-devtools/shared/utils';
import { KbdKey } from '@solid-primitives/keyboard';
import * as solid_js_store_types_store from 'solid-js/store/types/store';
import * as solid_js_store from 'solid-js/store';
import * as solid_js_types_reactive_signal from 'solid-js/types/reactive/signal';
import * as _solid_primitives_event_bus from '@solid-primitives/event-bus';
import * as solid_js from 'solid-js';

/**
 * Main modules and views of the devtools. Used for "routing".
 */
declare enum DevtoolsMainView {
    Structure = "structure"
}
declare const DEFAULT_MAIN_VIEW = DevtoolsMainView.Structure;
declare enum DebuggerModule {
    Locator = "locator",
    Structure = "structure",
    Dgraph = "dgraph"
}
declare enum TreeWalkerMode {
    Owners = "owners",
    Components = "components",
    DOM = "dom"
}
declare const DEFAULT_WALKER_MODE = TreeWalkerMode.Components;
declare enum NodeType {
    Root = "root",
    Component = "component",
    Element = "element",
    Effect = "effect",
    Render = "render",
    Memo = "memo",
    Computation = "computation",
    Refresh = "refresh",
    Context = "context",
    Signal = "signal",
    Store = "store"
}
declare const NODE_TYPE_NAMES: Readonly<Record<NodeType, string>>;
declare enum ValueItemType {
    Signal = "signal",
    Prop = "prop",
    Value = "value"
}

declare namespace SerializedDGraph {
    type Node = {
        name: string;
        depth: number;
        type: Exclude<NodeType, NodeType.Root | NodeType.Component>;
        sources: readonly NodeID[] | undefined;
        observers: readonly NodeID[] | undefined;
        graph: NodeID | undefined;
    };
    type Graph = Record<NodeID, Node>;
}

type DGraphUpdate = SerializedDGraph.Graph | null;

type StructureUpdates = {
    /** Partial means that the updates are based on the previous structure state */
    partial: boolean;
    /** Removed roots */
    removed: NodeID[];
    /** Record: `rootId` -- Record of updated nodes by `nodeId` */
    updated: Partial<Record<NodeID, Partial<Record<NodeID, Mapped.Owner>>>>;
};

type StoreNodeProperty = `${NodeID}:${string}`;

type ToggleInspectedValueData = {
    id: ValueItemID;
    selected: boolean;
};

declare const INFINITY = "Infinity";
declare const NEGATIVE_INFINITY = "NegativeInfinity";
declare const NAN = "NaN";
declare const UNDEFINED = "undefined";
declare enum ValueType {
    Number = "number",
    Boolean = "boolean",
    String = "string",
    Null = "null",
    Symbol = "symbol",
    Array = "array",
    Object = "object",
    Function = "function",
    Getter = "getter",
    Element = "element",
    Instance = "instance",
    Store = "store",
    Unknown = "unknown"
}
type EncodedValueDataMap = {
    [ValueType.Null]: null | typeof UNDEFINED;
    [ValueType.Array]: number | number[];
    [ValueType.Object]: number | {
        [key: string]: number;
    };
    [ValueType.Number]: number | typeof INFINITY | typeof NEGATIVE_INFINITY | typeof NAN;
    [ValueType.Boolean]: boolean;
    [ValueType.String]: string;
    [ValueType.Symbol]: string;
    [ValueType.Function]: string;
    [ValueType.Getter]: string;
    [ValueType.Element]: `${NodeID}:${string}`;
    [ValueType.Instance]: string;
    [ValueType.Store]: `${NodeID}:${number}`;
    [ValueType.Unknown]: never;
};
type EncodedValueMap = {
    [T in ValueType]: [type: T, data: EncodedValueDataMap[T]];
};
type EncodedValue<T extends ValueType = ValueType> = EncodedValueMap[T];
declare enum PropGetterState {
    /** getter is being observed, so it's value is up-to-date */
    Live = "live",
    /** getter is not observed, so it's value may be outdated */
    Stale = "stale"
}
type InspectorUpdateMap = {
    /** the value of a valueItem was updated */
    value: [id: ValueItemID, value: EncodedValue[]];
    /** a valueItem was expanded or collapsed, sends it's appropriable value */
    inspectToggle: [id: ValueItemID, value: EncodedValue[]];
    /** update to a store-node */
    store: [store: StoreNodeProperty, value: EncodedValue[] | null | number];
    /** List of new keys â€” all of the values are getters, so they won't change */
    propKeys: {
        added: string[];
        removed: string[];
    };
    /** state of getter props (STALE | LIVE) */
    propState: {
        [key in string]: PropGetterState;
    };
};
type InspectorUpdate = {
    [T in keyof InspectorUpdateMap]: [type: T, data: InspectorUpdateMap[T]];
}[keyof InspectorUpdateMap];

type LocationAttr = `${string}:${number}:${number}`;
type LocatorComponent = {
    id: NodeID;
    name: string;
    element: HTMLElement;
    location?: LocationAttr | undefined;
};
type TargetIDE = 'vscode' | 'webstorm' | 'atom' | 'vscode-insiders';
type SourceLocation = {
    filePath: string;
    line: number;
    column: number;
};
type SourceCodeData = SourceLocation & {
    projectPath: string;
    element: HTMLElement | string;
};
type TargetURLFunction = (data: SourceCodeData) => string | void;

type NodeID = `#${string}`;
type ValueItemID = `${ValueItemType.Signal}:${NodeID}` | `${ValueItemType.Prop}:${string}` | ValueItemType.Value;
declare const getValueItemId: <T extends ValueItemType>(type: T, id: T extends ValueItemType.Value ? undefined : string) => ValueItemID;
type ValueUpdateListener = (newValue: unknown, oldValue: unknown) => void;
declare namespace Core {
    type Owner = solid_js_types_reactive_signal.Owner;
    type SignalState = solid_js_types_reactive_signal.SignalState<unknown>;
    type Computation = solid_js_types_reactive_signal.Computation<unknown>;
    type Memo = solid_js_types_reactive_signal.Memo<unknown>;
    type RootFunction<T> = solid_js_types_reactive_signal.RootFunction<T>;
    type EffectFunction = solid_js_types_reactive_signal.EffectFunction<unknown>;
    type Component = solid_js_types_reactive_signal.DevComponent<{
        [key: string]: unknown;
    }>;
    namespace Store {
        type StoreNode = solid_js_store.StoreNode;
        type NotWrappable = solid_js_store_types_store.NotWrappable;
        type OnStoreNodeUpdate = solid_js_store_types_store.OnStoreNodeUpdate;
    }
}
declare module 'solid-js/types/reactive/signal' {
    interface SignalState<T> {
        sdtName?: string;
    }
    interface Owner {
        sdtName?: string;
        sdtType?: NodeType;
        sdtSubRoots?: Solid.Root[] | null;
    }
    interface Computation<Init, Next> {
        sdtType?: NodeType;
        onValueUpdate?: Record<symbol, ValueUpdateListener>;
    }
}
declare namespace Solid {
    interface SignalState {
        graph?: Owner;
        value: unknown;
        observers?: Computation[] | null;
        onValueUpdate?: Record<symbol, ValueUpdateListener>;
    }
    interface Signal extends Core.SignalState, SignalState {
        graph?: Owner;
        value: unknown;
        observers: Computation[] | null;
    }
    type OnStoreNodeUpdate = Core.Store.OnStoreNodeUpdate & {
        storePath: readonly (string | number)[];
        storeSymbol: symbol;
    };
    interface Store {
        value: Core.Store.StoreNode;
    }
    interface Root extends Core.Owner {
        owned: Computation[] | null;
        owner: Owner | null;
        sourceMap?: Record<string, Signal | Store>;
        isDisposed?: boolean;
        sdtAttached?: Owner;
        isInternal?: true;
        value?: undefined;
        sources?: undefined;
        fn?: undefined;
        state?: undefined;
        sourceSlots?: undefined;
        updatedAt?: undefined;
        pure?: undefined;
    }
    interface Computation extends Core.Computation {
        name: string;
        value: unknown;
        owned: Computation[] | null;
        owner: Owner | null;
        sourceMap?: Record<string, Signal>;
        sources: Signal[] | null;
    }
    interface Memo extends Signal, Computation {
        name: string;
    }
    interface Component extends Memo {
        props: Record<string, unknown>;
        componentName: string;
        location?: LocationAttr;
    }
    type Owner = Computation | Root;
}
declare namespace Mapped {
    interface Owner {
        id: NodeID;
        type: Exclude<NodeType, NodeType.Refresh | NodeType.Signal | NodeType.Store>;
        children: Owner[];
        name?: string;
        hmr?: true;
        frozen?: true;
    }
    interface Signal {
        type: NodeType.Signal | NodeType.Memo | NodeType.Store;
        name: string;
        id: NodeID;
        value: EncodedValue[];
    }
    type Props = {
        proxy: boolean;
        record: {
            [key: string]: {
                getter: false | PropGetterState;
                value: EncodedValue[] | null;
            };
        };
    };
    interface OwnerDetails {
        id: NodeID;
        name: string;
        type: NodeType;
        props?: Props;
        signals: Signal[];
        /** for computations */
        value?: EncodedValue[];
        location?: LocationAttr;
    }
}

type LocatorOptions = {
    /** Choose in which IDE the component source code should be revealed. */
    targetIDE?: false | TargetIDE | TargetURLFunction;
    /**
     * Holding which key should enable the locator overlay?
     * @default 'Alt'
     */
    key?: false | KbdKey;
};
type HighlightElementPayload = ToDyscriminatedUnion<{
    node: {
        id: NodeID;
    };
    element: {
        id: NodeID;
    };
}> | null;
declare const WINDOW_PROJECTPATH_PROPERTY = "$sdt_projectPath";
declare const LOCATION_ATTRIBUTE_NAME = "data-source-loc";
declare const MARK_COMPONENT = "markComponentLoc";
declare const USE_LOCATOR = "useLocator";

declare namespace Debugger {
    type InspectedState = {
        readonly ownerId: NodeID | null;
        readonly signalId: NodeID | null;
        /** closest note to inspected signal/owner on the owner structure */
        readonly treeWalkerOwnerId: NodeID | null;
    };
    type OutputChannels = {
        ResetPanel: void;
        InspectedState: InspectedState;
        InspectedNodeDetails: Mapped.OwnerDetails;
        StructureUpdates: StructureUpdates;
        NodeUpdates: NodeID[];
        InspectorUpdate: InspectorUpdate[];
        LocatorModeChange: boolean;
        HoveredComponent: {
            nodeId: NodeID;
            state: boolean;
        };
        InspectedComponent: NodeID;
        DgraphUpdate: DGraphUpdate;
    };
    type InputChannels = {
        ResetState: void;
        InspectNode: {
            ownerId: NodeID | null;
            signalId: NodeID | null;
        } | null;
        InspectValue: ToggleInspectedValueData;
        HighlightElementChange: HighlightElementPayload;
        OpenLocation: void;
        TreeViewModeChange: TreeWalkerMode;
        ViewChange: DevtoolsMainView;
        ToggleModule: {
            module: DebuggerModule;
            enabled: boolean;
        };
    };
}
declare const useDebugger: () => {
    enabled: solid_js.Accessor<boolean>;
    toggleEnabled: (enabled: boolean) => undefined;
    on: _solid_primitives_event_bus.EmitterOn<Debugger.OutputChannels>;
    listen: _solid_primitives_event_bus.EmitterListen<Debugger.OutputChannels>;
    emit: <K extends keyof Debugger.InputChannels>(event: K, ..._: void extends Debugger.InputChannels[K] ? [payload?: Debugger.InputChannels[K] | undefined] : [payload: Debugger.InputChannels[K]]) => void;
};
declare const useLocator: (options: LocatorOptions) => void;

export { Mapped as A, Debugger as B, Core as C, DGraphUpdate as D, EncodedValueMap as E, HighlightElementPayload as H, INFINITY as I, LocationAttr as L, MARK_COMPONENT as M, NodeType as N, PropGetterState as P, Solid as S, ToggleInspectedValueData as T, UNDEFINED as U, ValueUpdateListener as V, WINDOW_PROJECTPATH_PROPERTY as W, useLocator as a, SerializedDGraph as b, StructureUpdates as c, NEGATIVE_INFINITY as d, NAN as e, ValueType as f, EncodedValue as g, InspectorUpdateMap as h, InspectorUpdate as i, LocatorOptions as j, LOCATION_ATTRIBUTE_NAME as k, USE_LOCATOR as l, LocatorComponent as m, TargetIDE as n, TargetURLFunction as o, DevtoolsMainView as p, DEFAULT_MAIN_VIEW as q, DebuggerModule as r, TreeWalkerMode as s, DEFAULT_WALKER_MODE as t, useDebugger as u, NODE_TYPE_NAMES as v, ValueItemType as w, NodeID as x, ValueItemID as y, getValueItemId as z };
