import { ComponentProps, JSX, Component } from 'solid-js';

type DOMElements = keyof JSX.IntrinsicElements;
type ElementType = DOMElements | Component<any>;
type PropsOf<T extends ElementType> = ComponentProps<T> & {
    as?: ElementType;
};
type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
/**
 * Assign property types from right to left.
 * Think `Object.assign` for types.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
type Assign<A, B> = DistributiveOmit<A, keyof B> & B;
type MergeWithAs<Default extends ElementType, Component extends ElementType, PermanentProps extends Record<never, never>, DefaultProps extends Record<never, never>, ComponentProps extends Record<never, never>> = 
/**
 * The following code is copied from the library react-polymorphed by nasheomirro.
 * Thank your for creating this TypeScript gold!
 *
 * doing this makes sure typescript infers events. Without the
 * extends check typescript won't do an additional inference phase,
 * but somehow we can trick typescript into doing so. Note that the check needs to be relating
 * to the generic for this to work.
 */
any extends Component ? Assign<DefaultProps, PermanentProps & {
    as?: Default | ElementType;
}> | Assign<ComponentProps, PermanentProps & {
    as?: Component;
}> : never;
type ComponentWithAs<Component extends ElementType, Props extends Record<never, never> = Record<never, never>> = {
    <AsComponent extends ElementType = Component>(props: MergeWithAs<Component, AsComponent, Props, ComponentProps<Component>, ComponentProps<AsComponent>>): JSX.Element;
};
type HTMLPolymorphicComponents<Props extends Record<never, never> = Record<never, never>> = {
    [Tag in DOMElements]: ComponentWithAs<Tag, Props>;
};
type HTMLPolymorphicProps<T extends ElementType> = Omit<ComponentProps<T>, 'ref'> & {
    as?: ElementType;
};
type PolymorphFactory<Props extends Record<never, never> = Record<never, never>, Options = never> = {
    <T extends ElementType, P extends Record<never, never> = Props>(component: T, option?: Options): ComponentWithAs<T, P>;
};
interface PolyFactoryParam<Component extends ElementType, Props extends Record<never, never>, Options> {
    styled?: (component: Component, options?: Options) => ComponentWithAs<Component, Props>;
}
/**
 * Create a polymorphic factory, which is an object of JSX elements to render React Components accepting the `as` prop.
 *
 * @example
 * const poly = polymorphicFactory()
 * <poly.div /> // => renders div
 * <poly.main /> // => renders main
 * <poly.section as="main" /> => // renders main
 */
declare function polymorphicFactory<Props extends Record<never, never>, Options = never, Component extends ElementType = ElementType>({ styled }?: PolyFactoryParam<Component, Props, Options>): PolymorphFactory<Props, Options> & HTMLPolymorphicComponents<Props>;

export { Assign, ComponentWithAs, HTMLPolymorphicComponents, HTMLPolymorphicProps, PropsOf, polymorphicFactory };
