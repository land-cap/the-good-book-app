"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/combobox.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("combobox").parts(
  "root",
  "label",
  "input",
  "positioner",
  "control",
  "trigger",
  "content",
  "clearTrigger",
  "option",
  "optionGroup"
);
var parts = anatomy.build();

// src/combobox.connect.ts
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query2 = require("@zag-js/dom-query");
var import_popper = require("@zag-js/popper");

// src/combobox.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var import_utils = require("@zag-js/utils");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => ctx.ids?.root ?? `combobox:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `combobox:${ctx.id}:label`,
  getControlId: (ctx) => ctx.ids?.control ?? `combobox:${ctx.id}:control`,
  getInputId: (ctx) => ctx.ids?.input ?? `combobox:${ctx.id}:input`,
  getContentId: (ctx) => ctx.ids?.content ?? `combobox:${ctx.id}:listbox`,
  getPositionerId: (ctx) => `combobox:${ctx.id}:popper`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `combobox:${ctx.id}:toggle-btn`,
  getClearTriggerId: (ctx) => ctx.ids?.clearTrigger ?? `combobox:${ctx.id}:clear-btn`,
  getOptionId: (ctx, id, index) => ctx.ids?.option?.(id, index) ?? [`combobox:${ctx.id}:option:${id}`, index].filter((v) => v != null).join(":"),
  getActiveOptionEl: (ctx) => ctx.focusedId ? dom.getById(ctx, ctx.focusedId) : null,
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getInputEl: (ctx) => dom.getById(ctx, dom.getInputId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom.getById(ctx, dom.getClearTriggerId(ctx)),
  getElements: (ctx) => (0, import_dom_query.queryAll)(dom.getContentEl(ctx), "[role=option]:not([aria-disabled=true])"),
  getFocusedOptionEl: (ctx) => {
    if (!ctx.focusedId)
      return null;
    const selector = `[role=option][id=${CSS.escape(ctx.focusedId)}]`;
    return dom.getContentEl(ctx)?.querySelector(selector);
  },
  getFirstEl: (ctx) => (0, import_utils.first)(dom.getElements(ctx)),
  getLastEl: (ctx) => (0, import_utils.last)(dom.getElements(ctx)),
  getPrevEl: (ctx, id) => (0, import_dom_query.prevById)(dom.getElements(ctx), id, ctx.loop),
  getNextEl: (ctx, id) => (0, import_dom_query.nextById)(dom.getElements(ctx), id, ctx.loop),
  isInputFocused: (ctx) => dom.getDoc(ctx).activeElement === dom.getInputEl(ctx),
  getOptionData: (el) => ({
    value: el?.getAttribute("data-value") ?? "",
    label: el?.getAttribute("data-label") ?? ""
  }),
  getOptionCount: (ctx) => {
    const listbox = dom.getContentEl(ctx);
    const count = listbox?.querySelector("[role=option]")?.getAttribute("aria-setsize");
    if (count != null)
      return parseInt(count);
    return listbox?.querySelectorAll("[role=option]").length ?? 0;
  },
  getMatchingOptionEl: (ctx, value) => {
    if (!value)
      return null;
    const selector = `[role=option][data-value="${CSS.escape(value)}"`;
    const listbox = dom.getContentEl(ctx);
    if (!listbox)
      return null;
    return listbox.querySelector(selector);
  },
  focusInput: (ctx) => {
    const input = dom.getInputEl(ctx);
    if (dom.getDoc(ctx).activeElement !== input) {
      input?.focus();
    }
    if (ctx.selectInputOnFocus) {
      input?.select();
    }
  },
  getClosestSectionLabel(ctx) {
    if (!ctx.focusedId)
      return;
    const group = dom.getActiveOptionEl(ctx)?.closest("[data-part=option-group]");
    return group?.getAttribute("aria-label");
  },
  getValueLabel: (ctx, value) => {
    const el = dom.getMatchingOptionEl(ctx, value);
    return dom.getOptionData(el).label;
  }
});

// src/combobox.connect.ts
function connect(state, send, normalize) {
  const translations = state.context.translations;
  const isDisabled = state.context.disabled;
  const isInteractive = state.context.isInteractive;
  const isInvalid = state.context.invalid;
  const isReadOnly = state.context.readOnly;
  const isOpen = state.hasTag("open");
  const isFocused = state.hasTag("focused");
  const isIdle = state.hasTag("idle");
  const autofill = isOpen && state.context.navigationData && state.context.autoComplete;
  const showClearButton = (!isIdle || state.context.isHovering) && !state.context.isInputValueEmpty;
  const value = autofill ? state.context.navigationData?.label : state.context.inputValue;
  const popperStyles = (0, import_popper.getPlacementStyles)({
    placement: state.context.currentPlacement
  });
  const api = {
    /**
     * Whether the combobox is focused
     */
    isFocused,
    /**
     * Whether the combobox content or listbox is open
     */
    isOpen,
    /**
     * Whether the combobox input is empty
     */
    isInputValueEmpty: state.context.isInputValueEmpty,
    /**
     * The current value of the combobox input
     */
    inputValue: state.context.inputValue,
    /**
     * The currently focused option (by pointer or keyboard)
     */
    focusedOption: state.context.focusedOptionData,
    /**
     * The currently selected option value
     */
    selectedValue: state.context.selectionData?.value,
    /**
     * Function to set the combobox value
     */
    setValue(value2) {
      let data;
      if (typeof value2 === "string") {
        data = { value: value2, label: dom.getValueLabel(state.context, value2) };
      } else {
        data = value2;
      }
      send({ type: "SET_VALUE", ...data });
    },
    /**
     * Function to set the combobox input value
     */
    setInputValue(value2) {
      send({ type: "SET_INPUT_VALUE", value: value2 });
    },
    /**
     * Function to clear the combobox input value and selected value
     */
    clearValue() {
      send("CLEAR_VALUE");
    },
    /**
     * Function to focus the combobox input
     */
    focus() {
      dom.getInputEl(state.context)?.focus();
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      id: dom.getRootId(state.context),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid),
      "data-readonly": (0, import_dom_query2.dataAttr)(isReadOnly)
    }),
    labelProps: normalize.label({
      ...parts.label.attrs,
      htmlFor: dom.getInputId(state.context),
      id: dom.getLabelId(state.context),
      "data-readonly": (0, import_dom_query2.dataAttr)(isReadOnly),
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid),
      "data-focus": (0, import_dom_query2.dataAttr)(isFocused)
    }),
    controlProps: normalize.element({
      ...parts.control.attrs,
      id: dom.getControlId(state.context),
      "data-expanded": (0, import_dom_query2.dataAttr)(isOpen),
      "data-focus": (0, import_dom_query2.dataAttr)(isFocused),
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid),
      onPointerOver() {
        if (!isInteractive)
          return;
        send("POINTER_OVER");
      },
      onPointerLeave() {
        if (!isInteractive)
          return;
        send("POINTER_LEAVE");
      }
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      id: dom.getPositionerId(state.context),
      "data-expanded": (0, import_dom_query2.dataAttr)(isOpen),
      hidden: !isOpen,
      style: popperStyles.floating
    }),
    inputProps: normalize.input({
      ...parts.input.attrs,
      "aria-invalid": (0, import_dom_query2.ariaAttr)(isInvalid),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid),
      name: state.context.name,
      form: state.context.form,
      disabled: isDisabled,
      autoFocus: state.context.autoFocus,
      autoComplete: "off",
      autoCorrect: "off",
      autoCapitalize: "none",
      spellCheck: "false",
      readOnly: isReadOnly,
      placeholder: state.context.placeholder,
      id: dom.getInputId(state.context),
      type: "text",
      role: "combobox",
      defaultValue: value,
      "data-value": value,
      "aria-autocomplete": state.context.autoComplete ? "both" : "list",
      "aria-controls": isOpen ? dom.getContentId(state.context) : void 0,
      "aria-expanded": isOpen,
      "aria-activedescendant": state.context.focusedId ?? void 0,
      onClick() {
        if (!isInteractive)
          return;
        send("CLICK_INPUT");
      },
      onFocus() {
        if (isDisabled)
          return;
        send("FOCUS");
      },
      onChange(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (evt.isComposing)
          return;
        send({ type: "CHANGE", value: event.currentTarget.value });
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (evt.ctrlKey || evt.shiftKey || evt.isComposing)
          return;
        let prevent = false;
        const keymap = {
          ArrowDown(event2) {
            send(event2.altKey ? "ALT_ARROW_DOWN" : "ARROW_DOWN");
            prevent = true;
          },
          ArrowUp() {
            send(event.altKey ? "ALT_ARROW_UP" : "ARROW_UP");
            prevent = true;
          },
          Home(event2) {
            const isCtrlKey = event2.ctrlKey || event2.metaKey;
            if (isCtrlKey)
              return;
            send({ type: "HOME", preventDefault: () => event2.preventDefault() });
          },
          End(event2) {
            const isCtrlKey = event2.ctrlKey || event2.metaKey;
            if (isCtrlKey)
              return;
            send({ type: "END", preventDefault: () => event2.preventDefault() });
          },
          Enter() {
            send("ENTER");
            prevent = true;
          },
          Escape() {
            send("ESCAPE");
            prevent = true;
          },
          Tab() {
            send("TAB");
          }
        };
        const key = (0, import_dom_event.getEventKey)(event, state.context);
        const exec = keymap[key];
        exec?.(event);
        if (prevent) {
          event.preventDefault();
        }
      }
    }),
    triggerProps: normalize.button({
      ...parts.trigger.attrs,
      id: dom.getTriggerId(state.context),
      "aria-haspopup": "listbox",
      type: "button",
      tabIndex: -1,
      "aria-label": translations.triggerLabel,
      "aria-expanded": isOpen,
      "aria-controls": isOpen ? dom.getContentId(state.context) : void 0,
      disabled: isDisabled,
      "data-readonly": (0, import_dom_query2.dataAttr)(isReadOnly),
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
      onPointerDown(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isInteractive || !(0, import_dom_event.isLeftClick)(evt) || evt.pointerType === "touch")
          return;
        send("CLICK_BUTTON");
        event.preventDefault();
      },
      onPointerUp(event) {
        if (event.pointerType !== "touch")
          return;
        send("CLICK_BUTTON");
      }
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      id: dom.getContentId(state.context),
      role: "listbox",
      hidden: !isOpen,
      "aria-labelledby": dom.getLabelId(state.context),
      onPointerDown(event) {
        event.preventDefault();
      }
    }),
    clearTriggerProps: normalize.button({
      ...parts.clearTrigger.attrs,
      id: dom.getClearTriggerId(state.context),
      type: "button",
      tabIndex: -1,
      disabled: isDisabled,
      "aria-label": translations.clearTriggerLabel,
      hidden: !showClearButton,
      onPointerDown(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isInteractive || !(0, import_dom_event.isLeftClick)(evt))
          return;
        send("CLEAR_VALUE");
        event.preventDefault();
      }
    }),
    getOptionState(props) {
      const { value: value2, index, disabled } = props;
      const id = dom.getOptionId(state.context, value2, index);
      const focused = state.context.focusedId === id;
      const checked = state.context.selectionData?.value === value2;
      return { disabled, focused, checked };
    },
    getOptionProps(props) {
      const { value: value2, label, index, count } = props;
      const id = dom.getOptionId(state.context, value2, index);
      const optionState = api.getOptionState(props);
      return normalize.element({
        ...parts.option.attrs,
        id,
        role: "option",
        tabIndex: -1,
        "data-highlighted": (0, import_dom_query2.dataAttr)(optionState.focused),
        "data-disabled": (0, import_dom_query2.dataAttr)(optionState.disabled),
        "data-checked": (0, import_dom_query2.dataAttr)(optionState.checked),
        "aria-selected": optionState.focused,
        "aria-disabled": optionState.disabled,
        "aria-posinset": count && index != null ? index + 1 : void 0,
        "aria-setsize": count,
        "data-value": value2,
        "data-label": label,
        // Prefer `pointermove` to `pointerenter` to avoid interrupting the keyboard navigation
        // NOTE: for perf, we may want to move these handlers to the listbox
        onPointerMove() {
          if (optionState.disabled)
            return;
          send({ type: "POINTEROVER_OPTION", id, value: value2, label });
        },
        onPointerUp() {
          if (optionState.disabled)
            return;
          send({ type: "CLICK_OPTION", src: "pointerup", id, value: value2, label });
        },
        onClick() {
          if (optionState.disabled)
            return;
          send({ type: "CLICK_OPTION", src: "click", id, value: value2, label });
        },
        onAuxClick(event) {
          if (optionState.disabled)
            return;
          event.preventDefault();
          send({ type: "CLICK_OPTION", src: "auxclick", id, value: value2, label });
        }
      });
    },
    getOptionGroupProps(props) {
      const { label } = props;
      return normalize.element({
        ...parts.optionGroup.attrs,
        role: "group",
        "aria-label": label
      });
    }
  };
  return api;
}

// src/combobox.machine.ts
var import_aria_hidden = require("@zag-js/aria-hidden");
var import_core = require("@zag-js/core");
var import_dom_query3 = require("@zag-js/dom-query");
var import_mutation_observer = require("@zag-js/mutation-observer");
var import_interact_outside = require("@zag-js/interact-outside");
var import_live_region = require("@zag-js/live-region");
var import_popper2 = require("@zag-js/popper");
var import_utils2 = require("@zag-js/utils");
var { and, not } = import_core.guards;
function machine(userContext) {
  const ctx = (0, import_utils2.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "combobox",
      initial: ctx.autoFocus ? "focused" : "idle",
      context: {
        loop: true,
        openOnClick: false,
        ariaHidden: true,
        focusedId: null,
        focusedOptionData: null,
        navigationData: null,
        selectionData: null,
        inputValue: "",
        liveRegion: null,
        focusOnClear: true,
        selectInputOnFocus: false,
        selectOnTab: true,
        isHovering: false,
        isKeyboardEvent: false,
        allowCustomValue: false,
        isCustomValue: (data) => data.inputValue !== data.previousValue,
        inputBehavior: "none",
        selectionBehavior: "set",
        ...ctx,
        positioning: {
          placement: "bottom",
          flip: false,
          sameWidth: true,
          ...ctx.positioning
        },
        translations: {
          triggerLabel: "Toggle suggestions",
          clearTriggerLabel: "Clear value",
          navigationHint: "use the up and down keys to navigate. Press the enter key to select",
          countAnnouncement: (count) => `${count} ${count === 1 ? "option" : "options"} available`,
          ...ctx.translations
        }
      },
      computed: {
        isInputValueEmpty: (ctx2) => ctx2.inputValue.length === 0,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),
        autoComplete: (ctx2) => ctx2.inputBehavior === "autocomplete",
        autoHighlight: (ctx2) => ctx2.inputBehavior === "autohighlight"
      },
      watch: {
        inputValue: "invokeOnInputChange",
        navigationData: "invokeOnHighlight",
        selectionData: ["invokeOnSelect", "blurInputIfNeeded"],
        focusedId: "setSectionLabel"
      },
      entry: ["setupLiveRegion"],
      exit: ["removeLiveRegion"],
      activities: ["syncInputValue"],
      on: {
        SET_VALUE: {
          actions: ["setInputValue", "setSelectionData"]
        },
        SET_INPUT_VALUE: {
          actions: "setInputValue"
        },
        CLEAR_VALUE: [
          {
            guard: "focusOnClear",
            target: "focused",
            actions: ["clearInputValue", "clearSelectedValue"]
          },
          {
            actions: ["clearInputValue", "clearSelectedValue"]
          }
        ],
        POINTER_OVER: {
          actions: "setIsHovering"
        },
        POINTER_LEAVE: {
          actions: "clearIsHovering"
        }
      },
      states: {
        idle: {
          tags: ["idle"],
          entry: ["scrollToTop", "clearFocusedOption"],
          on: {
            CLICK_BUTTON: {
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            },
            CLICK_INPUT: {
              guard: "openOnClick",
              target: "interacting",
              actions: "invokeOnOpen"
            },
            FOCUS: "focused"
          }
        },
        focused: {
          tags: ["focused"],
          entry: ["focusInput", "scrollToTop", "clearFocusedOption"],
          activities: ["trackInteractOutside"],
          on: {
            CHANGE: {
              target: "suggesting",
              actions: "setInputValue"
            },
            BLUR: "idle",
            ESCAPE: {
              guard: and("isCustomValue", not("allowCustomValue")),
              actions: "revertInputValue"
            },
            CLICK_INPUT: {
              guard: "openOnClick",
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            },
            CLICK_BUTTON: {
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            },
            POINTER_OVER: {
              actions: "setIsHovering"
            },
            ARROW_UP: [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              {
                target: "interacting",
                actions: ["focusLastOption", "invokeOnOpen"]
              }
            ],
            ARROW_DOWN: [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              {
                target: "interacting",
                actions: ["focusFirstOption", "invokeOnOpen"]
              }
            ],
            ALT_ARROW_DOWN: {
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            }
          }
        },
        suggesting: {
          tags: ["open", "focused"],
          activities: [
            "trackInteractOutside",
            "scrollOptionIntoView",
            "computePlacement",
            "trackOptionNodes",
            "hideOtherElements"
          ],
          entry: ["focusInput", "invokeOnOpen"],
          on: {
            ARROW_DOWN: {
              target: "interacting",
              actions: "focusNextOption"
            },
            ARROW_UP: {
              target: "interacting",
              actions: "focusPrevOption"
            },
            ALT_ARROW_UP: "focused",
            HOME: {
              target: "interacting",
              actions: ["focusFirstOption", "preventDefault"]
            },
            END: {
              target: "interacting",
              actions: ["focusLastOption", "preventDefault"]
            },
            ENTER: [
              {
                guard: and("hasFocusedOption", "autoComplete"),
                target: "focused",
                actions: "selectActiveOption"
              },
              {
                guard: "hasFocusedOption",
                target: "focused",
                actions: "selectOption"
              }
            ],
            CHANGE: [
              {
                guard: "autoHighlight",
                actions: ["clearFocusedOption", "setInputValue", "focusFirstOption"]
              },
              {
                actions: ["clearFocusedOption", "setInputValue"]
              }
            ],
            ESCAPE: {
              target: "focused",
              actions: "invokeOnClose"
            },
            POINTEROVER_OPTION: [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "setActiveOption"
              },
              {
                target: "interacting",
                actions: ["setActiveOption", "setNavigationData"]
              }
            ],
            BLUR: {
              target: "idle",
              actions: "invokeOnClose"
            },
            CLICK_BUTTON: {
              target: "focused",
              actions: "invokeOnClose"
            },
            CLICK_OPTION: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            }
          }
        },
        interacting: {
          tags: ["open", "focused"],
          activities: ["scrollOptionIntoView", "trackInteractOutside", "computePlacement", "hideOtherElements"],
          entry: "focusMatchingOption",
          on: {
            HOME: {
              actions: ["focusFirstOption", "preventDefault"]
            },
            END: {
              actions: ["focusLastOption", "preventDefault"]
            },
            ARROW_DOWN: [
              {
                guard: and("autoComplete", "isLastOptionFocused"),
                actions: ["clearFocusedOption", "scrollToTop"]
              },
              { actions: "focusNextOption" }
            ],
            ARROW_UP: [
              {
                guard: and("autoComplete", "isFirstOptionFocused"),
                actions: "clearFocusedOption"
              },
              {
                actions: "focusPrevOption"
              }
            ],
            ALT_UP: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            },
            CLEAR_FOCUS: {
              actions: "clearFocusedOption"
            },
            TAB: {
              guard: "selectOnTab",
              target: "idle",
              actions: ["selectOption", "invokeOnClose"]
            },
            ENTER: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            },
            CHANGE: [
              {
                guard: "autoComplete",
                target: "suggesting",
                actions: ["commitNavigationData", "setInputValue"]
              },
              {
                target: "suggesting",
                actions: ["clearFocusedOption", "setInputValue"]
              }
            ],
            POINTEROVER_OPTION: [
              {
                guard: "autoComplete",
                actions: "setActiveOption"
              },
              {
                actions: ["setActiveOption", "setNavigationData"]
              }
            ],
            CLICK_OPTION: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            },
            ESCAPE: {
              target: "focused",
              actions: "invokeOnClose"
            },
            CLICK_BUTTON: {
              target: "focused",
              actions: "invokeOnClose"
            },
            BLUR: {
              target: "idle",
              actions: "invokeOnClose"
            }
          }
        }
      }
    },
    {
      guards: {
        openOnClick: (ctx2) => !!ctx2.openOnClick,
        isInputValueEmpty: (ctx2) => ctx2.isInputValueEmpty,
        focusOnClear: (ctx2) => !!ctx2.focusOnClear,
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        autoComplete: (ctx2) => ctx2.autoComplete,
        autoHighlight: (ctx2) => ctx2.autoHighlight,
        isFirstOptionFocused: (ctx2) => dom.getFirstEl(ctx2)?.id === ctx2.focusedId,
        isLastOptionFocused: (ctx2) => dom.getLastEl(ctx2)?.id === ctx2.focusedId,
        isCustomValue: (ctx2) => !!ctx2.isCustomValue?.({ inputValue: ctx2.inputValue, previousValue: ctx2.selectionData?.value }),
        allowCustomValue: (ctx2) => !!ctx2.allowCustomValue,
        hasFocusedOption: (ctx2) => !!ctx2.focusedId,
        selectOnTab: (ctx2) => !!ctx2.selectOnTab
      },
      activities: {
        syncInputValue: (ctx2) => {
          const input = dom.getInputEl(ctx2);
          return (0, import_mutation_observer.observeAttributes)(input, ["data-value"], () => {
            if (!input)
              return;
            const value = input.dataset.value || "";
            input.value = value;
            input.selectionStart = value.length;
            input.selectionEnd = value.length;
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          return (0, import_interact_outside.trackInteractOutside)(dom.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)];
              return ignore.some((el) => (0, import_dom_query3.contains)(el, target));
            },
            onInteractOutside(event) {
              ctx2.onInteractOutside?.(event);
              if (event.defaultPrevented)
                return;
              send({ type: "BLUR", src: "interact-outside" });
            }
          });
        },
        hideOtherElements(ctx2) {
          if (!ctx2.ariaHidden)
            return;
          return (0, import_aria_hidden.ariaHidden)([dom.getInputEl(ctx2), dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)]);
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          return (0, import_popper2.getPlacement)(dom.getControlEl(ctx2), dom.getPositionerEl(ctx2), {
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        // in event the options are fetched (async), we still want to auto-highlight the first option
        trackOptionNodes(ctx2, evt, meta) {
          if (!ctx2.autoHighlight)
            return;
          const focusFirstOption = meta.getAction("focusFirstOption");
          const exec = () => focusFirstOption(ctx2, evt, meta);
          exec();
          return (0, import_mutation_observer.observeChildren)(dom.getContentEl(ctx2), exec);
        },
        scrollOptionIntoView(ctx2, _evt, { getState }) {
          const input = dom.getInputEl(ctx2);
          return (0, import_mutation_observer.observeAttributes)(input, ["aria-activedescendant"], () => {
            const evt = getState().event;
            const isKeyboardEvent = /(ARROW_UP|ARROW_DOWN|HOME|END|TAB)/.test(evt.type);
            if (!isKeyboardEvent)
              return;
            const option = dom.getActiveOptionEl(ctx2);
            option?.scrollIntoView({ block: "nearest" });
            if (ctx2.autoComplete) {
              dom.focusInput(ctx2);
            }
          });
        }
      },
      actions: {
        setupLiveRegion(ctx2) {
          ctx2.liveRegion = (0, import_live_region.createLiveRegion)({
            level: "assertive",
            document: dom.getDoc(ctx2)
          });
        },
        removeLiveRegion(ctx2) {
          ctx2.liveRegion?.destroy();
        },
        setActiveOption(ctx2, evt) {
          const { label, id, value } = evt;
          ctx2.focusedId = id;
          ctx2.focusedOptionData = { label, value };
        },
        setNavigationData(ctx2, evt) {
          const { label, value } = evt;
          ctx2.navigationData = { label, value };
        },
        clearNavigationData(ctx2) {
          ctx2.navigationData = null;
        },
        commitNavigationData(ctx2) {
          if (!ctx2.navigationData)
            return;
          ctx2.inputValue = ctx2.navigationData.label;
          ctx2.navigationData = null;
        },
        clearFocusedOption(ctx2) {
          ctx2.focusedId = null;
          ctx2.focusedOptionData = null;
          ctx2.navigationData = null;
        },
        selectActiveOption(ctx2) {
          if (!ctx2.focusedOptionData)
            return;
          ctx2.selectionData = ctx2.focusedOptionData;
          ctx2.inputValue = ctx2.focusedOptionData.label;
        },
        selectOption(ctx2, evt) {
          const isOptionEvent = !!evt.value && !!evt.label;
          ctx2.selectionData = isOptionEvent ? {
            label: evt.label,
            value: evt.value
          } : ctx2.navigationData;
          let value;
          if (!ctx2.selectionData)
            return;
          if (ctx2.selectionBehavior === "set") {
            value = ctx2.selectionData.label;
          }
          if (ctx2.selectionBehavior === "clear") {
            value = "";
          }
          if (value != null) {
            ctx2.inputValue = value;
          }
        },
        blurInputIfNeeded(ctx2) {
          if (ctx2.autoComplete || !ctx2.blurOnSelect)
            return;
          (0, import_dom_query3.raf)(() => {
            dom.getInputEl(ctx2)?.blur();
          });
        },
        focusInput(ctx2, evt) {
          if (evt.type === "CHANGE")
            return;
          dom.focusInput(ctx2);
        },
        setInputValue(ctx2, evt) {
          const value = evt.type === "SET_VALUE" ? evt.label : evt.value;
          ctx2.inputValue = value;
        },
        clearInputValue(ctx2) {
          ctx2.inputValue = "";
        },
        revertInputValue(ctx2) {
          if (!ctx2.selectionData)
            return;
          ctx2.inputValue = ctx2.selectionData.label;
        },
        setSelectionData(ctx2, evt) {
          const { label, value } = evt;
          ctx2.selectionData = { label, value };
        },
        clearSelectedValue(ctx2) {
          ctx2.selectionData = null;
        },
        scrollToTop(ctx2) {
          const listbox = dom.getContentEl(ctx2);
          if (!listbox)
            return;
          listbox.scrollTop = 0;
        },
        invokeOnInputChange(ctx2) {
          ctx2.onInputChange?.({ value: ctx2.inputValue });
        },
        invokeOnHighlight(ctx2) {
          const { label, value } = ctx2.navigationData ?? {};
          const relatedTarget = dom.getMatchingOptionEl(ctx2, value);
          ctx2.onHighlight?.({ label, value, relatedTarget });
        },
        invokeOnSelect(ctx2) {
          const { label, value } = ctx2.selectionData ?? {};
          const relatedTarget = dom.getMatchingOptionEl(ctx2, value);
          ctx2.onSelect?.({ label, value, relatedTarget });
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        highlightFirstOption(ctx2) {
          (0, import_dom_query3.raf)(() => {
            setHighlight(ctx2, dom.getFirstEl(ctx2));
          });
        },
        focusFirstOption(ctx2) {
          (0, import_dom_query3.raf)(() => {
            setFocus(ctx2, dom.getFirstEl(ctx2));
          });
        },
        focusLastOption(ctx2) {
          (0, import_dom_query3.raf)(() => {
            setFocus(ctx2, dom.getLastEl(ctx2));
          });
        },
        focusNextOption(ctx2) {
          (0, import_dom_query3.raf)(() => {
            const option = dom.getNextEl(ctx2, ctx2.focusedId ?? "");
            setFocus(ctx2, option);
          });
        },
        focusPrevOption(ctx2) {
          (0, import_dom_query3.raf)(() => {
            let option = dom.getPrevEl(ctx2, ctx2.focusedId ?? "");
            setFocus(ctx2, option);
          });
        },
        focusMatchingOption(ctx2) {
          (0, import_dom_query3.raf)(() => {
            const option = dom.getMatchingOptionEl(ctx2, ctx2.selectionData?.value);
            option?.scrollIntoView({ block: "nearest" });
            setFocus(ctx2, option);
          });
        },
        announceOptionCount(ctx2) {
          (0, import_dom_query3.raf)(() => {
            const count = dom.getOptionCount(ctx2);
            if (!count)
              return;
            const text = ctx2.translations.countAnnouncement(count);
            ctx2.liveRegion?.announce(text);
          });
        },
        setIsHovering(ctx2) {
          ctx2.isHovering = true;
        },
        clearIsHovering(ctx2) {
          ctx2.isHovering = false;
        },
        preventDefault(_ctx, evt) {
          evt.preventDefault();
        },
        setSectionLabel(ctx2) {
          const label = dom.getClosestSectionLabel(ctx2);
          if (!label)
            return;
          ctx2.sectionLabel = label;
        }
      }
    }
  );
}
function setHighlight(ctx, option) {
  if (!option)
    return;
  const data = dom.getOptionData(option);
  ctx.focusedId = option.id;
  ctx.focusedOptionData = data;
  return data;
}
function setFocus(ctx, option) {
  if (!option || option.id === ctx.focusedId)
    return;
  const data = setHighlight(ctx, option);
  ctx.navigationData = data;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
