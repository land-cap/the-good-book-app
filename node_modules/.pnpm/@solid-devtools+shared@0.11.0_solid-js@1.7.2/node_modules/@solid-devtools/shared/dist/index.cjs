"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  primitives: () => primitives_exports,
  utils: () => utils_exports
});
module.exports = __toCommonJS(src_exports);

// src/primitives.ts
var primitives_exports = {};
__export(primitives_exports, {
  atom: () => atom,
  createConsumers: () => createConsumers,
  createDerivedSignal: () => createDerivedSignal,
  createHover: () => createHover,
  createPingedSignal: () => createPingedSignal,
  createShallowStore: () => createShallowStore,
  defer: () => defer,
  handleTupleUpdate: () => handleTupleUpdate,
  handleTupleUpdates: () => handleTupleUpdates,
  makeHoverElementListener: () => makeHoverElementListener,
  untrackedCallback: () => untrackedCallback,
  useIsMobile: () => useIsMobile,
  useIsTouch: () => useIsTouch
});
var import_event_listener = require("@solid-primitives/event-listener");
var import_media = require("@solid-primitives/media");
var import_rootless = require("@solid-primitives/rootless");
var import_utils = require("@solid-primitives/utils");
var import_solid_js = require("solid-js");
var untrackedCallback = (fn) => (...a) => (0, import_solid_js.untrack)(fn.bind(void 0, ...a));
var useIsTouch = (0, import_rootless.createSharedRoot)(() => (0, import_media.createMediaQuery)("(hover: none)"));
var useIsMobile = (0, import_rootless.createSharedRoot)(() => (0, import_media.createMediaQuery)("(max-width: 640px)"));
function createHover(handle) {
  let state = false;
  let mounted = true;
  const mql = window.matchMedia("(hover: none)");
  let isTouch = mql.matches;
  (0, import_event_listener.makeEventListener)(mql, "change", ({ matches }) => {
    if (isTouch = matches)
      handle(state = false);
  });
  (0, import_solid_js.onCleanup)(() => {
    mounted = false;
    if (state)
      handle(state = false);
  });
  const onChange = (newState) => {
    if (isTouch || !mounted)
      return;
    state !== newState && handle(state = newState);
  };
  return {
    onMouseEnter: () => onChange(true),
    onMouseLeave: () => setTimeout(() => onChange(false))
  };
}
function createConsumers(initial = []) {
  const [consumers, setConsumers] = (0, import_solid_js.createSignal)([...initial], { name: "consumers" });
  const enabled = (0, import_solid_js.createMemo)(() => consumers().some((consumer) => consumer()));
  return [
    enabled,
    (consumer) => {
      setConsumers((p) => [...p, consumer]);
      (0, import_utils.tryOnCleanup)(() => setConsumers((p) => p.filter((c) => c !== consumer)));
    }
  ];
}
function createDerivedSignal(fallback, options) {
  const [source, setSource] = (0, import_solid_js.createSignal)();
  return [
    (0, import_solid_js.createMemo)(
      () => {
        const sourceRef = source();
        return sourceRef ? sourceRef() : fallback;
      },
      void 0,
      options
    ),
    (newSource) => {
      if (newSource && (0, import_solid_js.getOwner)())
        (0, import_solid_js.onCleanup)(() => setSource((p) => p === newSource ? void 0 : p));
      return setSource(() => newSource);
    }
  ];
}
function makeHoverElementListener(onHover) {
  let last = null;
  const handleHover = (e) => {
    const { target } = e;
    if (target === last || !(target instanceof HTMLElement) && target !== null)
      return;
    onHover(last = target);
  };
  (0, import_event_listener.makeEventListener)(window, "mouseover", handleHover);
  (0, import_event_listener.makeEventListener)(document, "mouseleave", handleHover.bind(void 0, { target: null }));
}
function defer(deps, fn, initialValue) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let shouldDefer = true;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++)
        input[i] = deps[i]();
    } else
      input = deps();
    if (shouldDefer) {
      shouldDefer = false;
      prevInput = input;
      return initialValue;
    }
    const result = (0, import_solid_js.untrack)(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function atom(value, options) {
  const [state, setState] = (0, import_solid_js.createSignal)(value, { internal: true, ...options });
  return (...args) => args.length === 1 ? setState(args[0]) : state();
}
function createPingedSignal(timeout = 400) {
  const [isUpdated, setIsUpdated] = (0, import_solid_js.createSignal)(false);
  let timeoutId;
  const ping = () => {
    setIsUpdated(true);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => setIsUpdated(false), timeout);
  };
  (0, import_solid_js.onCleanup)(() => clearTimeout(timeoutId));
  return [isUpdated, ping];
}
function createShallowStore(storeValue) {
  const signals = {};
  const [keys, setKeys] = (0, import_solid_js.createSignal)(Object.keys(storeValue), { internal: true });
  let hasKeysChanged = false;
  const setValue = (key, setterParam) => {
    const saved = signals[key];
    const newValue = saved ? saved[1](setterParam) : (0, import_utils.accessWith)(setterParam, storeValue[key]);
    if (newValue === void 0) {
      delete storeValue[key];
      hasKeysChanged = true;
    } else {
      storeValue[key] = newValue;
    }
  };
  const setter = (a, b) => {
    (0, import_solid_js.batch)(() => {
      if (typeof a === "object" || typeof a === "function")
        (0, import_solid_js.untrack)(() => {
          for (const [key, newValue] of (0, import_utils.entries)((0, import_utils.accessWith)(a, store)))
            setValue(key, () => newValue);
        });
      else
        setValue(a, b);
      if (hasKeysChanged) {
        hasKeysChanged = false;
        setKeys(Object.keys(storeValue));
      }
    });
    return store;
  };
  const store = new Proxy(storeValue, {
    get(target, key) {
      if (key === import_solid_js.$TRACK) {
        keys();
        return true;
      }
      let signal = signals[key];
      if (!signal) {
        if (!(0, import_solid_js.getListener)()) {
          return storeValue[key];
        }
        signal = (0, import_solid_js.createSignal)(storeValue[key], { internal: true });
        signals[key] = signal;
      }
      return signal[0]();
    },
    has(target, key) {
      if (key === import_solid_js.$TRACK)
        return true;
      this.get(target, key, target);
      return key in target;
    },
    set() {
      console.warn("Cannot mutate a Store directly");
      return true;
    },
    deleteProperty() {
      console.warn("Cannot mutate a Store directly");
      return true;
    },
    ownKeys: () => keys().slice(),
    getOwnPropertyDescriptor() {
      console.warn("getOwnPropertyDescriptor is not yet implemented for shallow stores");
      return void 0;
    }
  });
  return [store, setter];
}
function handleTupleUpdate(handlers) {
  return (update) => handlers[update[0]](update[1]);
}
function handleTupleUpdates(handlers) {
  function runUpdates(updates) {
    for (const [key, value] of updates)
      handlers[key](value);
  }
  return (updates) => (0, import_solid_js.batch)(runUpdates.bind(void 0, updates));
}

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  XOR: () => XOR,
  arrayRefEquals: () => arrayRefEquals,
  asArray: () => asArray,
  callArrayProp: () => callArrayProp,
  createCallbackStack: () => createCallbackStack,
  dedupeArray: () => dedupeArray,
  dedupeArrayById: () => dedupeArrayById,
  error: () => error,
  findIndexById: () => findIndexById,
  findItemById: () => findItemById,
  formatTime: () => formatTime,
  info: () => info,
  isRecord: () => isRecord,
  log: () => log,
  mutateFilter: () => mutateFilter,
  mutateRemove: () => mutateRemove,
  pushToArrayProp: () => pushToArrayProp,
  splitOnColon: () => splitOnColon,
  trimString: () => trimString,
  warn: () => warn,
  whileArray: () => whileArray
});
var getLogLabel = () => [
  `%csolid-devtools`,
  "color: #fff; background: #2c4f7c; padding: 1px 4px;"
];
function info(data) {
  console.info(...getLogLabel(), data);
  return data;
}
function log(...args) {
  console.log(...getLogLabel(), ...args);
  return;
}
function warn(...args) {
  console.warn(...getLogLabel(), ...args);
  return;
}
function error(...args) {
  console.error(...getLogLabel(), ...args);
  return;
}
function formatTime(d = new Date()) {
  return ("0" + d.getHours()).slice(-2) + ":" + ("0" + d.getMinutes()).slice(-2) + ":" + ("0" + d.getSeconds()).slice(-2);
}
var asArray = (value) => Array.isArray(value) ? value : [value];
var createCallbackStack = () => {
  let stack = [];
  const clear = () => stack = [];
  return {
    push: (...callbacks) => stack.push(...callbacks),
    execute(arg0, arg1, arg2, arg3) {
      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));
      clear();
    },
    clear
  };
};
function callArrayProp(object, key, ...args) {
  const arr = object[key];
  if (arr)
    for (const cb of arr)
      cb(...args);
}
function pushToArrayProp(object, key, value) {
  let arr = object[key];
  if (arr)
    arr.push(value);
  else
    arr = object[key] = [value];
  return arr;
}
function mutateFilter(array, predicate) {
  const temp = array.filter(predicate);
  array.length = 0;
  array.push.apply(array, temp);
}
function mutateRemove(array, item) {
  array.splice(array.indexOf(item), 1);
}
var dedupeArray = (array) => Array.from(new Set(array));
var arrayRefEquals = (a, b) => a === b || a.length === b.length && a.every((e) => b.includes(e));
function trimString(str, maxLength) {
  if (str.length <= maxLength)
    return str;
  return str.slice(0, maxLength) + "\u2026";
}
function findIndexById(array, id) {
  for (let i = 0; i < array.length; i++)
    if (array[i].id === id)
      return i;
  return -1;
}
function findItemById(array, id) {
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    if (item.id === id)
      return item;
  }
}
var splitOnColon = (str) => {
  const splitIndex = str.indexOf(":");
  if (splitIndex === -1)
    return [str, null];
  return [str.slice(0, splitIndex), str.slice(splitIndex + 1)];
};
function whileArray(toCheck, callback) {
  let index = 0;
  let current = toCheck[index++];
  while (current) {
    const result = callback(current, toCheck);
    if (result !== void 0)
      return result;
    current = toCheck[index++];
  }
}
var isRecord = (value) => typeof value === "object" && value !== null && Object.getPrototypeOf(value) === Object.prototype;
var XOR = (a, b) => (a || b) && !(a && b);
function dedupeArrayById(input) {
  const ids = /* @__PURE__ */ new Set();
  const deduped = [];
  for (let i = input.length - 1; i >= 0; i--) {
    const update = input[i];
    if (ids.has(update.id))
      continue;
    ids.add(update.id);
    deduped.push(update);
  }
  return deduped;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  primitives,
  utils
});
