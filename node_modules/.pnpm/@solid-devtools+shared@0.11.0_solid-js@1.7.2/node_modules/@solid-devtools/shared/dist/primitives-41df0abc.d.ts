import { AnyFunction, AnyStatic, StaticStoreSetter } from '@solid-primitives/utils';
import { Accessor, MemoOptions, AccessorArray, NoInfer, EffectFunction, SignalOptions } from 'solid-js';
import { Primitive } from 'type-fest';

type WritableDeep<T> = 0 extends 1 & T ? T : T extends Primitive ? T : unknown extends T ? T : {
    -readonly [K in keyof T]: WritableDeep<T[K]>;
};
declare const untrackedCallback: <Fn extends AnyFunction>(fn: Fn) => Fn;
declare const useIsTouch: () => Accessor<boolean>;
declare const useIsMobile: () => Accessor<boolean>;
declare function createHover(handle: (hovering: boolean) => void): {
    onMouseEnter: VoidFunction;
    onMouseLeave: VoidFunction;
};
/**
 * Reactive array reducer — if at least one consumer (boolean signal) is enabled — the returned result will the `true`.
 *
 * For **IOC**
 */
declare function createConsumers(initial?: readonly Accessor<boolean>[]): [needed: Accessor<boolean>, addConsumer: (consumer: Accessor<boolean>) => void];
type DerivedSignal<T> = [
    value: Accessor<T>,
    setSource: (source?: Accessor<T>) => Accessor<T> | undefined
];
/**
 * For **IOC**
 */
declare function createDerivedSignal<T>(): DerivedSignal<T>;
declare function createDerivedSignal<T>(fallback: T, options?: MemoOptions<T>): DerivedSignal<T>;
declare function makeHoverElementListener(onHover: (el: HTMLElement | null) => void): void;
/**
 * Solid's `on` helper, but always defers and returns a provided initial value when if does instead of `undefined`.
 *
 * @param deps
 * @param fn
 * @param initialValue
 */
declare function defer<S, Next extends Prev, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: (input: S, prevInput: S, prev: undefined | NoInfer<Prev>) => Next, initialValue: Next): EffectFunction<undefined | NoInfer<Next>, NoInfer<Next>>;
declare function defer<S, Next extends Prev, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: (input: S, prevInput: S, prev: undefined | NoInfer<Prev>) => Next, initialValue?: undefined): EffectFunction<undefined | NoInfer<Next>>;
type Atom<T> = (<U extends T>(value: (prev: T) => U) => U) & (<U extends T>(value: Exclude<U, Function>) => U) & (<U extends T>(value: Exclude<U, Function> | ((prev: T) => U)) => U) & Accessor<T>;
declare function atom<T>(value: T, options?: SignalOptions<T>): Atom<T>;
declare function atom<T>(value?: undefined, options?: SignalOptions<T | undefined>): Atom<T | undefined>;
/**
 * Creates a signal that will be activated for a given amount of time on every "ping" — a call to the listener function.
 */
declare function createPingedSignal(timeout?: number): [isUpdated: Accessor<boolean>, ping: VoidFunction];
declare function createShallowStore<T extends Readonly<AnyStatic>>(storeValue: T): [T, StaticStoreSetter<T>];
declare function handleTupleUpdate<T extends readonly [PropertyKey, any], O = {
    readonly [K in T as K[0]]: (value: K[1]) => void;
}>(handlers: O): (update: T) => void;
declare function handleTupleUpdates<T extends readonly [PropertyKey, any], O = {
    readonly [K in T as K[0]]: (value: K[1]) => void;
}>(handlers: O): (updates: T[]) => void;

type primitives_Atom<T> = Atom<T>;
type primitives_DerivedSignal<T> = DerivedSignal<T>;
type primitives_WritableDeep<T> = WritableDeep<T>;
declare const primitives_atom: typeof atom;
declare const primitives_createConsumers: typeof createConsumers;
declare const primitives_createDerivedSignal: typeof createDerivedSignal;
declare const primitives_createHover: typeof createHover;
declare const primitives_createPingedSignal: typeof createPingedSignal;
declare const primitives_createShallowStore: typeof createShallowStore;
declare const primitives_defer: typeof defer;
declare const primitives_handleTupleUpdate: typeof handleTupleUpdate;
declare const primitives_handleTupleUpdates: typeof handleTupleUpdates;
declare const primitives_makeHoverElementListener: typeof makeHoverElementListener;
declare const primitives_untrackedCallback: typeof untrackedCallback;
declare const primitives_useIsMobile: typeof useIsMobile;
declare const primitives_useIsTouch: typeof useIsTouch;
declare namespace primitives {
  export {
    primitives_Atom as Atom,
    primitives_DerivedSignal as DerivedSignal,
    primitives_WritableDeep as WritableDeep,
    primitives_atom as atom,
    primitives_createConsumers as createConsumers,
    primitives_createDerivedSignal as createDerivedSignal,
    primitives_createHover as createHover,
    primitives_createPingedSignal as createPingedSignal,
    primitives_createShallowStore as createShallowStore,
    primitives_defer as defer,
    primitives_handleTupleUpdate as handleTupleUpdate,
    primitives_handleTupleUpdates as handleTupleUpdates,
    primitives_makeHoverElementListener as makeHoverElementListener,
    primitives_untrackedCallback as untrackedCallback,
    primitives_useIsMobile as useIsMobile,
    primitives_useIsTouch as useIsTouch,
  };
}

export { Atom as A, DerivedSignal as D, WritableDeep as W, useIsTouch as a, useIsMobile as b, createHover as c, createConsumers as d, createDerivedSignal as e, defer as f, atom as g, createPingedSignal as h, createShallowStore as i, handleTupleUpdate as j, handleTupleUpdates as k, makeHoverElementListener as m, primitives as p, untrackedCallback as u };
