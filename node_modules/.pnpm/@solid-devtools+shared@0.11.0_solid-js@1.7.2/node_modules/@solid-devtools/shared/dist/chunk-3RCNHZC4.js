import {
  __export
} from "./chunk-UICA3PK6.js";

// src/primitives.ts
var primitives_exports = {};
__export(primitives_exports, {
  atom: () => atom,
  createConsumers: () => createConsumers,
  createDerivedSignal: () => createDerivedSignal,
  createHover: () => createHover,
  createPingedSignal: () => createPingedSignal,
  createShallowStore: () => createShallowStore,
  defer: () => defer,
  handleTupleUpdate: () => handleTupleUpdate,
  handleTupleUpdates: () => handleTupleUpdates,
  makeHoverElementListener: () => makeHoverElementListener,
  untrackedCallback: () => untrackedCallback,
  useIsMobile: () => useIsMobile,
  useIsTouch: () => useIsTouch
});
import { makeEventListener } from "@solid-primitives/event-listener";
import { createMediaQuery } from "@solid-primitives/media";
import { createSharedRoot } from "@solid-primitives/rootless";
import {
  accessWith,
  entries,
  tryOnCleanup
} from "@solid-primitives/utils";
import {
  $TRACK,
  batch,
  createMemo,
  createSignal,
  getListener,
  getOwner,
  onCleanup,
  untrack
} from "solid-js";
var untrackedCallback = (fn) => (...a) => untrack(fn.bind(void 0, ...a));
var useIsTouch = createSharedRoot(() => createMediaQuery("(hover: none)"));
var useIsMobile = createSharedRoot(() => createMediaQuery("(max-width: 640px)"));
function createHover(handle) {
  let state = false;
  let mounted = true;
  const mql = window.matchMedia("(hover: none)");
  let isTouch = mql.matches;
  makeEventListener(mql, "change", ({ matches }) => {
    if (isTouch = matches)
      handle(state = false);
  });
  onCleanup(() => {
    mounted = false;
    if (state)
      handle(state = false);
  });
  const onChange = (newState) => {
    if (isTouch || !mounted)
      return;
    state !== newState && handle(state = newState);
  };
  return {
    onMouseEnter: () => onChange(true),
    onMouseLeave: () => setTimeout(() => onChange(false))
  };
}
function createConsumers(initial = []) {
  const [consumers, setConsumers] = createSignal([...initial], { name: "consumers" });
  const enabled = createMemo(() => consumers().some((consumer) => consumer()));
  return [
    enabled,
    (consumer) => {
      setConsumers((p) => [...p, consumer]);
      tryOnCleanup(() => setConsumers((p) => p.filter((c) => c !== consumer)));
    }
  ];
}
function createDerivedSignal(fallback, options) {
  const [source, setSource] = createSignal();
  return [
    createMemo(
      () => {
        const sourceRef = source();
        return sourceRef ? sourceRef() : fallback;
      },
      void 0,
      options
    ),
    (newSource) => {
      if (newSource && getOwner())
        onCleanup(() => setSource((p) => p === newSource ? void 0 : p));
      return setSource(() => newSource);
    }
  ];
}
function makeHoverElementListener(onHover) {
  let last = null;
  const handleHover = (e) => {
    const { target } = e;
    if (target === last || !(target instanceof HTMLElement) && target !== null)
      return;
    onHover(last = target);
  };
  makeEventListener(window, "mouseover", handleHover);
  makeEventListener(document, "mouseleave", handleHover.bind(void 0, { target: null }));
}
function defer(deps, fn, initialValue) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let shouldDefer = true;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++)
        input[i] = deps[i]();
    } else
      input = deps();
    if (shouldDefer) {
      shouldDefer = false;
      prevInput = input;
      return initialValue;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function atom(value, options) {
  const [state, setState] = createSignal(value, { internal: true, ...options });
  return (...args) => args.length === 1 ? setState(args[0]) : state();
}
function createPingedSignal(timeout = 400) {
  const [isUpdated, setIsUpdated] = createSignal(false);
  let timeoutId;
  const ping = () => {
    setIsUpdated(true);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => setIsUpdated(false), timeout);
  };
  onCleanup(() => clearTimeout(timeoutId));
  return [isUpdated, ping];
}
function createShallowStore(storeValue) {
  const signals = {};
  const [keys, setKeys] = createSignal(Object.keys(storeValue), { internal: true });
  let hasKeysChanged = false;
  const setValue = (key, setterParam) => {
    const saved = signals[key];
    const newValue = saved ? saved[1](setterParam) : accessWith(setterParam, storeValue[key]);
    if (newValue === void 0) {
      delete storeValue[key];
      hasKeysChanged = true;
    } else {
      storeValue[key] = newValue;
    }
  };
  const setter = (a, b) => {
    batch(() => {
      if (typeof a === "object" || typeof a === "function")
        untrack(() => {
          for (const [key, newValue] of entries(accessWith(a, store)))
            setValue(key, () => newValue);
        });
      else
        setValue(a, b);
      if (hasKeysChanged) {
        hasKeysChanged = false;
        setKeys(Object.keys(storeValue));
      }
    });
    return store;
  };
  const store = new Proxy(storeValue, {
    get(target, key) {
      if (key === $TRACK) {
        keys();
        return true;
      }
      let signal = signals[key];
      if (!signal) {
        if (!getListener()) {
          return storeValue[key];
        }
        signal = createSignal(storeValue[key], { internal: true });
        signals[key] = signal;
      }
      return signal[0]();
    },
    has(target, key) {
      if (key === $TRACK)
        return true;
      this.get(target, key, target);
      return key in target;
    },
    set() {
      console.warn("Cannot mutate a Store directly");
      return true;
    },
    deleteProperty() {
      console.warn("Cannot mutate a Store directly");
      return true;
    },
    ownKeys: () => keys().slice(),
    getOwnPropertyDescriptor() {
      console.warn("getOwnPropertyDescriptor is not yet implemented for shallow stores");
      return void 0;
    }
  });
  return [store, setter];
}
function handleTupleUpdate(handlers) {
  return (update) => handlers[update[0]](update[1]);
}
function handleTupleUpdates(handlers) {
  function runUpdates(updates) {
    for (const [key, value] of updates)
      handlers[key](value);
  }
  return (updates) => batch(runUpdates.bind(void 0, updates));
}

export {
  untrackedCallback,
  useIsTouch,
  useIsMobile,
  createHover,
  createConsumers,
  createDerivedSignal,
  makeHoverElementListener,
  defer,
  atom,
  createPingedSignal,
  createShallowStore,
  handleTupleUpdate,
  handleTupleUpdates,
  primitives_exports
};
