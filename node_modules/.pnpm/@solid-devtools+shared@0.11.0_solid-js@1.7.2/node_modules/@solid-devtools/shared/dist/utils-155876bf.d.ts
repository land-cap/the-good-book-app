declare function info<T>(data: T): T;
declare function log(...args: any[]): undefined;
declare function warn(...args: any[]): undefined;
declare function error(...args: any[]): undefined;
declare function formatTime(d?: Date): string;
declare const asArray: <T>(value: T) => (T extends any[] ? T[number] : T)[];
declare const createCallbackStack: <A0 = void, A1 = void, A2 = void, A3 = void>() => {
    push: (...callbacks: ((arg0: A0, arg1: A1, arg2: A2, arg3: A3) => void)[]) => void;
    execute: (arg0: A0, arg1: A1, arg2: A2, arg3: A3) => void;
    clear: VoidFunction;
};
declare function callArrayProp<K extends PropertyKey, T extends (...args: Args) => void, Args extends unknown[]>(object: {
    [_ in K]?: T[];
}, key: K, ...args: Args): void;
declare function pushToArrayProp<K extends PropertyKey, T>(object: {
    [_ in K]?: T[];
}, key: K, value: T): T[];
declare function mutateFilter<T, S extends T>(array: T[], predicate: (value: T, index: number, array: T[]) => value is S): void;
declare function mutateFilter<T>(array: T[], predicate: (value: T, index: number, array: T[]) => unknown): void;
declare function mutateRemove<T>(array: T[], item: T): void;
declare const dedupeArray: <T>(array: readonly T[]) => T[];
/** Checks if both arrays contain the same values. Order doesn't matter. */
declare const arrayRefEquals: <T>(a: readonly T[], b: readonly T[]) => boolean;
/** function that trims too long string */
declare function trimString(str: string, maxLength: number): string;
declare function findIndexById<T extends {
    id: string;
}>(array: T[], id: string): number;
declare function findItemById<T extends {
    id: string;
}>(array: T[], id: string): T | undefined;
declare const splitOnColon: <T extends string>(str: T) => T extends `${infer L}:${infer R}` ? [L, R] : [T, null];
declare function whileArray<T, U>(toCheck: T[], callback: (item: T, toCheck: T[]) => U | undefined): U | undefined;
declare const isRecord: (value: unknown) => value is Record<string, unknown>;
declare const XOR: (a: unknown, b: unknown) => unknown;
type ToDyscriminatedUnion<T extends {}, TK extends PropertyKey = 'type', DK extends void | PropertyKey = void> = {
    [K in keyof T]: {
        [k in TK]: K;
    } & (DK extends PropertyKey ? {
        [k in DK]: T[K];
    } : T[K]);
}[keyof T];
declare function dedupeArrayById<T extends {
    id: unknown;
}>(input: T[]): T[];

type utils_ToDyscriminatedUnion<T extends {}, TK extends PropertyKey = 'type', DK extends void | PropertyKey = void> = ToDyscriminatedUnion<T, TK, DK>;
declare const utils_XOR: typeof XOR;
declare const utils_arrayRefEquals: typeof arrayRefEquals;
declare const utils_asArray: typeof asArray;
declare const utils_callArrayProp: typeof callArrayProp;
declare const utils_createCallbackStack: typeof createCallbackStack;
declare const utils_dedupeArray: typeof dedupeArray;
declare const utils_dedupeArrayById: typeof dedupeArrayById;
declare const utils_error: typeof error;
declare const utils_findIndexById: typeof findIndexById;
declare const utils_findItemById: typeof findItemById;
declare const utils_formatTime: typeof formatTime;
declare const utils_info: typeof info;
declare const utils_isRecord: typeof isRecord;
declare const utils_log: typeof log;
declare const utils_mutateFilter: typeof mutateFilter;
declare const utils_mutateRemove: typeof mutateRemove;
declare const utils_pushToArrayProp: typeof pushToArrayProp;
declare const utils_splitOnColon: typeof splitOnColon;
declare const utils_trimString: typeof trimString;
declare const utils_warn: typeof warn;
declare const utils_whileArray: typeof whileArray;
declare namespace utils {
  export {
    utils_ToDyscriminatedUnion as ToDyscriminatedUnion,
    utils_XOR as XOR,
    utils_arrayRefEquals as arrayRefEquals,
    utils_asArray as asArray,
    utils_callArrayProp as callArrayProp,
    utils_createCallbackStack as createCallbackStack,
    utils_dedupeArray as dedupeArray,
    utils_dedupeArrayById as dedupeArrayById,
    utils_error as error,
    utils_findIndexById as findIndexById,
    utils_findItemById as findItemById,
    utils_formatTime as formatTime,
    utils_info as info,
    utils_isRecord as isRecord,
    utils_log as log,
    utils_mutateFilter as mutateFilter,
    utils_mutateRemove as mutateRemove,
    utils_pushToArrayProp as pushToArrayProp,
    utils_splitOnColon as splitOnColon,
    utils_trimString as trimString,
    utils_warn as warn,
    utils_whileArray as whileArray,
  };
}

export { ToDyscriminatedUnion as T, XOR as X, asArray as a, callArrayProp as b, createCallbackStack as c, mutateRemove as d, error as e, formatTime as f, dedupeArray as g, arrayRefEquals as h, info as i, findIndexById as j, findItemById as k, log as l, mutateFilter as m, whileArray as n, isRecord as o, pushToArrayProp as p, dedupeArrayById as q, splitOnColon as s, trimString as t, utils as u, warn as w };
