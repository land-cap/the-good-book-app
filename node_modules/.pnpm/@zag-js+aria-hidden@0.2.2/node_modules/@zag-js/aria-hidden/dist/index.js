"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ariaHidden: () => ariaHidden
});
module.exports = __toCommonJS(src_exports);
var elementCountMap = /* @__PURE__ */ new WeakMap();
function isLiveRegion(node, win) {
  return node instanceof win.HTMLElement && node.dataset.liveAnnouncer === "true";
}
function ariaHidden(targets, rootEl) {
  const exclude = targets.filter(Boolean);
  if (exclude.length === 0)
    return;
  const doc = exclude[0].ownerDocument || document;
  const win = doc.defaultView ?? window;
  const visibleNodes = new Set(exclude);
  const hiddenNodes = /* @__PURE__ */ new Set();
  const root = rootEl ?? doc.body;
  const walker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node2) {
      if (isLiveRegion(node2, win)) {
        visibleNodes.add(node2);
      }
      if (visibleNodes.has(node2) || hiddenNodes.has(node2.parentElement)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (node2 instanceof win.HTMLElement && node2.getAttribute("role") === "row") {
        return NodeFilter.FILTER_SKIP;
      }
      if (exclude.some((target) => node2.contains(target))) {
        return NodeFilter.FILTER_SKIP;
      }
      return NodeFilter.FILTER_ACCEPT;
    }
  });
  const hide = (node2) => {
    let refCount = elementCountMap.get(node2) ?? 0;
    if (node2.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node2.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node2);
    elementCountMap.set(node2, refCount + 1);
  };
  let node = walker.nextNode();
  while (node != null) {
    hide(node);
    node = walker.nextNode();
  }
  const observer = new win.MutationObserver((changes) => {
    for (let change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0)
        continue;
      if (![...visibleNodes, ...hiddenNodes].some((node2) => node2.contains(change.target))) {
        for (const node2 of change.addedNodes) {
          if (isLiveRegion(node2, win)) {
            visibleNodes.add(node2);
          } else if (node2 instanceof win.Element) {
            hide(node2);
          }
        }
      }
    }
  });
  observer.observe(root, { childList: true, subtree: true });
  return () => {
    observer.disconnect();
    for (let node2 of hiddenNodes) {
      let count = elementCountMap.get(node2);
      if (count === 1) {
        node2.removeAttribute("aria-hidden");
        elementCountMap.delete(node2);
        continue;
      }
      if (count !== void 0) {
        elementCountMap.set(node2, count - 1);
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ariaHidden
});
