// src/pressable.utils.ts
import { isHTMLElement } from "@zag-js/dom-query";
function isValidKeyboardEvent(event) {
  const { key, target } = event;
  const element = target;
  const { tagName, isContentEditable } = element;
  const role = element.getAttribute("role");
  if (tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable)
    return false;
  return (key === "Enter" || key === " ") && // A link with a valid href should be handled natively,
  // unless it also has role='button' and was triggered using Space.
  (!isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
  !(role === "link" && key !== "Enter");
}
function isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function shouldPreventDefaultKeyboard(target) {
  return !((target.tagName === "INPUT" || target.tagName === "BUTTON") && target.type === "submit");
}
function shouldPreventDefault(target) {
  return !isHTMLElement(target) || !target.draggable;
}
function isOverTarget(point, target) {
  if (!target)
    return;
  let rect = target.getBoundingClientRect();
  let pointRect = getPointClientRect(point);
  return areRectanglesOverlapping(rect, pointRect);
}
function getPointClientRect(point) {
  let offsetX = point.width ? point.width / 2 : point.radiusX || 0;
  let offsetY = point.height ? point.height / 2 : point.radiusY || 0;
  return {
    top: point.clientY - offsetY,
    right: point.clientX + offsetX,
    bottom: point.clientY + offsetY,
    left: point.clientX - offsetX
  };
}
function areRectanglesOverlapping(a, b) {
  if (a.left > b.right || b.left > a.right) {
    return false;
  }
  if (a.top > b.bottom || b.top > a.bottom) {
    return false;
  }
  return true;
}

export {
  isValidKeyboardEvent,
  isHTMLAnchorLink,
  shouldPreventDefaultKeyboard,
  shouldPreventDefault,
  isOverTarget,
  getPointClientRect,
  areRectanglesOverlapping
};
