"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/pressable.connect.ts
var pressable_connect_exports = {};
__export(pressable_connect_exports, {
  connect: () => connect
});
module.exports = __toCommonJS(pressable_connect_exports);
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query3 = require("@zag-js/dom-query");

// src/pressable.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getPressableId: (ctx) => `pressable:${ctx.id}`,
  getPressableEl: (ctx) => dom.getById(ctx, dom.getPressableId(ctx))
});

// src/pressable.utils.ts
var import_dom_query2 = require("@zag-js/dom-query");
function isValidKeyboardEvent(event) {
  const { key, target } = event;
  const element = target;
  const { tagName, isContentEditable } = element;
  const role = element.getAttribute("role");
  if (tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable)
    return false;
  return (key === "Enter" || key === " ") && // A link with a valid href should be handled natively,
  // unless it also has role='button' and was triggered using Space.
  (!isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
  !(role === "link" && key !== "Enter");
}
function isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function shouldPreventDefaultKeyboard(target) {
  return !((target.tagName === "INPUT" || target.tagName === "BUTTON") && target.type === "submit");
}
function shouldPreventDefault(target) {
  return !(0, import_dom_query2.isHTMLElement)(target) || !target.draggable;
}

// src/pressable.connect.ts
function connect(state, send, normalize) {
  const isPressed = state.hasTag("pressed");
  const isDisabled = state.context.disabled;
  return {
    /**
     * Whether the element is pressed.
     */
    isPressed,
    pressableProps: normalize.element({
      id: dom.getPressableId(state.context),
      "data-disabled": (0, import_dom_query3.dataAttr)(isDisabled),
      "data-pressed": (0, import_dom_query3.dataAttr)(isPressed),
      onKeyDown(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isValidKeyboardEvent(evt))
          return;
        if (!(0, import_dom_query3.contains)(event.currentTarget, event.target))
          return;
        if (!event.repeat) {
          send({ type: "KEY_DOWN", event, pointerType: "keyboard" });
        }
        if (shouldPreventDefaultKeyboard(event.target)) {
          event.preventDefault();
        }
      },
      onKeyUp(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isValidKeyboardEvent(evt) || event.repeat)
          return;
        if (!(0, import_dom_query3.contains)(event.currentTarget, event.target))
          return;
        send({ type: "KEY_UP", event, pointerType: "keyboard" });
      },
      onClick(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!(0, import_dom_query3.contains)(event.currentTarget, event.target) || event.button !== 0)
          return;
        const ctx = state.context;
        if (ctx.disabled) {
          event.preventDefault();
        }
        const isVirtual = ctx.pointerType === "virtual" || (0, import_dom_event.isVirtualClick)(evt);
        if (!ctx.ignoreClickAfterPress && isVirtual) {
          send({ type: "CLICK", event, pointerType: "virtual" });
        }
      },
      onPointerDown(event) {
        if (state.context.disabled) {
          return;
        }
        if (event.button !== 0 || !(0, import_dom_query3.contains)(event.currentTarget, event.target)) {
          return;
        }
        if (shouldPreventDefault(event.currentTarget)) {
          event.preventDefault();
        }
        const evt = (0, import_dom_event.getNativeEvent)(event);
        const pointerType = (0, import_dom_event.isVirtualPointerEvent)(evt) ? "virtual" : event.pointerType;
        send({ type: "POINTER_DOWN", event, pointerType });
      },
      onMouseDown(event) {
        if (event.button !== 0)
          return;
        if (shouldPreventDefault(event.currentTarget)) {
          event.preventDefault();
        }
      },
      onDragStart(event) {
        send({ type: "DRAG_START", event });
      }
    })
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  connect
});
