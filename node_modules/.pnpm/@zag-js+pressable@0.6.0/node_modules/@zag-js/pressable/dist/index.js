"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/pressable.connect.ts
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query3 = require("@zag-js/dom-query");

// src/pressable.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getPressableId: (ctx) => `pressable:${ctx.id}`,
  getPressableEl: (ctx) => dom.getById(ctx, dom.getPressableId(ctx))
});

// src/pressable.utils.ts
var import_dom_query2 = require("@zag-js/dom-query");
function isValidKeyboardEvent(event) {
  const { key, target } = event;
  const element = target;
  const { tagName, isContentEditable } = element;
  const role = element.getAttribute("role");
  if (tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable)
    return false;
  return (key === "Enter" || key === " ") && // A link with a valid href should be handled natively,
  // unless it also has role='button' and was triggered using Space.
  (!isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
  !(role === "link" && key !== "Enter");
}
function isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function shouldPreventDefaultKeyboard(target) {
  return !((target.tagName === "INPUT" || target.tagName === "BUTTON") && target.type === "submit");
}
function shouldPreventDefault(target) {
  return !(0, import_dom_query2.isHTMLElement)(target) || !target.draggable;
}
function isOverTarget(point, target) {
  if (!target)
    return;
  let rect = target.getBoundingClientRect();
  let pointRect = getPointClientRect(point);
  return areRectanglesOverlapping(rect, pointRect);
}
function getPointClientRect(point) {
  let offsetX = point.width ? point.width / 2 : point.radiusX || 0;
  let offsetY = point.height ? point.height / 2 : point.radiusY || 0;
  return {
    top: point.clientY - offsetY,
    right: point.clientX + offsetX,
    bottom: point.clientY + offsetY,
    left: point.clientX - offsetX
  };
}
function areRectanglesOverlapping(a, b) {
  if (a.left > b.right || b.left > a.right) {
    return false;
  }
  if (a.top > b.bottom || b.top > a.bottom) {
    return false;
  }
  return true;
}

// src/pressable.connect.ts
function connect(state, send, normalize) {
  const isPressed = state.hasTag("pressed");
  const isDisabled = state.context.disabled;
  return {
    /**
     * Whether the element is pressed.
     */
    isPressed,
    pressableProps: normalize.element({
      id: dom.getPressableId(state.context),
      "data-disabled": (0, import_dom_query3.dataAttr)(isDisabled),
      "data-pressed": (0, import_dom_query3.dataAttr)(isPressed),
      onKeyDown(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isValidKeyboardEvent(evt))
          return;
        if (!(0, import_dom_query3.contains)(event.currentTarget, event.target))
          return;
        if (!event.repeat) {
          send({ type: "KEY_DOWN", event, pointerType: "keyboard" });
        }
        if (shouldPreventDefaultKeyboard(event.target)) {
          event.preventDefault();
        }
      },
      onKeyUp(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isValidKeyboardEvent(evt) || event.repeat)
          return;
        if (!(0, import_dom_query3.contains)(event.currentTarget, event.target))
          return;
        send({ type: "KEY_UP", event, pointerType: "keyboard" });
      },
      onClick(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!(0, import_dom_query3.contains)(event.currentTarget, event.target) || event.button !== 0)
          return;
        const ctx = state.context;
        if (ctx.disabled) {
          event.preventDefault();
        }
        const isVirtual = ctx.pointerType === "virtual" || (0, import_dom_event.isVirtualClick)(evt);
        if (!ctx.ignoreClickAfterPress && isVirtual) {
          send({ type: "CLICK", event, pointerType: "virtual" });
        }
      },
      onPointerDown(event) {
        if (state.context.disabled) {
          return;
        }
        if (event.button !== 0 || !(0, import_dom_query3.contains)(event.currentTarget, event.target)) {
          return;
        }
        if (shouldPreventDefault(event.currentTarget)) {
          event.preventDefault();
        }
        const evt = (0, import_dom_event.getNativeEvent)(event);
        const pointerType = (0, import_dom_event.isVirtualPointerEvent)(evt) ? "virtual" : event.pointerType;
        send({ type: "POINTER_DOWN", event, pointerType });
      },
      onMouseDown(event) {
        if (event.button !== 0)
          return;
        if (shouldPreventDefault(event.currentTarget)) {
          event.preventDefault();
        }
      },
      onDragStart(event) {
        send({ type: "DRAG_START", event });
      }
    })
  };
}

// src/pressable.machine.ts
var import_core = require("@zag-js/core");
var import_dom_event2 = require("@zag-js/dom-event");
var import_dom_query4 = require("@zag-js/dom-query");
var import_text_selection = require("@zag-js/text-selection");
var import_utils = require("@zag-js/utils");
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "pressable",
      initial: "idle",
      context: {
        ...ctx,
        ignoreClickAfterPress: false,
        activePointerId: null,
        target: null,
        pointerType: null,
        pointerdownEvent: null,
        cleanups: (0, import_core.ref)([]),
        wasPressedDown: false
      },
      exit: ["restoreTextSelection", "removeDocumentListeners"],
      states: {
        idle: {
          entry: ["removeDocumentListeners", "resetContext", "restoreTextSelection", "resetIgnoreClick"],
          on: {
            POINTER_DOWN: [
              {
                guard: "isVirtualPointerEvent",
                actions: "setPointerType"
              },
              {
                target: "pressed:in",
                actions: [
                  "setPressedDown",
                  "setPointerType",
                  "setPointerId",
                  "setTarget",
                  "focusIfNeeded",
                  "disableTextSelection",
                  "invokeOnPressStart",
                  "trackDocumentPointerEvents"
                ]
              }
            ],
            KEY_DOWN: {
              target: "pressed:in",
              actions: ["setTarget", "invokeOnPressStart", "trackDocumentKeyup"]
            },
            CLICK: {
              actions: ["focusIfNeeded", "invokeOnPressStart", "invokeOnPressEnd", "invokeOnPress", "resetIgnoreClick"]
            }
          }
        },
        "pressed:in": {
          tags: "pressed",
          entry: "preventContextMenu",
          after: {
            500: {
              guard: "wasPressedDown",
              actions: ["clearPressedDown", "invokeOnLongPress"]
            }
          },
          on: {
            POINTER_LEAVE: [
              {
                guard: "cancelOnPointerExit",
                target: "idle",
                actions: ["clearPressedDown", "invokeOnPressEnd"]
              },
              {
                target: "pressed:out",
                actions: ["invokeOnPressEnd"]
              }
            ],
            DOC_POINTER_UP: [
              {
                guard: "wasPressedDown",
                target: "idle",
                actions: ["clearPressedDown", "invokeOnPressUp", "invokeOnPressEnd", "invokeOnPress"]
              },
              {
                target: "idle",
                actions: ["clearPressedDown", "invokeOnPressUp", "invokeOnPressEnd"]
              }
            ],
            DOC_KEY_UP: {
              target: "idle",
              actions: ["clearPressedDown", "invokeOnPressEnd", "triggerClick"]
            },
            KEY_UP: {
              target: "idle",
              actions: ["clearPressedDown", "invokeOnPressUp"]
            },
            DOC_POINTER_CANCEL: { target: "idle", actions: "clearPressedDown" },
            DRAG_START: { target: "idle", actions: "clearPressedDown" }
          }
        },
        "pressed:out": {
          on: {
            POINTER_ENTER: {
              target: "pressed:in",
              actions: "invokeOnPressStart"
            },
            DOC_POINTER_UP: {
              target: "idle"
            },
            DOC_POINTER_CANCEL: "idle",
            DRAG_START: "idle"
          }
        }
      }
    },
    {
      guards: {
        isVirtualPointerEvent: (_ctx, evt) => evt.pointerType === "virtual",
        cancelOnPointerExit: (ctx2) => !!ctx2.cancelOnPointerExit,
        wasPressedDown: (ctx2) => ctx2.wasPressedDown
      },
      actions: {
        trackDocumentPointerEvents(ctx2, _evt, { send }) {
          const doc = dom.getDoc(ctx2);
          const onPointerMove = (event) => {
            if (event.pointerId !== ctx2.activePointerId)
              return;
            const isOver = isOverTarget(event, ctx2.target);
            send({ type: isOver ? "POINTER_ENTER" : "POINTER_LEAVE", event });
          };
          const onPointerUp = (event) => {
            if (event.pointerId !== ctx2.activePointerId || event.button !== 0)
              return;
            send({ type: "DOC_POINTER_UP", event });
          };
          const onPointerCancel = (event) => {
            send({ type: "DOC_POINTER_CANCEL", event });
          };
          const cleanup = [
            (0, import_dom_event2.addDomEvent)(doc, "pointermove", onPointerMove, false),
            (0, import_dom_event2.addDomEvent)(doc, "pointerup", onPointerUp, false),
            (0, import_dom_event2.addDomEvent)(doc, "pointercancel", onPointerCancel, false)
          ];
          if (ctx2.pointerType !== "touch") {
            cleanup.push((0, import_dom_event2.addDomEvent)(doc, "contextmenu", onPointerCancel, false));
          }
          ctx2.cleanups.push(...cleanup);
        },
        trackDocumentKeyup(ctx2, _evt, { send }) {
          const doc = dom.getDoc(ctx2);
          const onKeyup = (event) => {
            if (!isValidKeyboardEvent(event))
              return;
            if (shouldPreventDefaultKeyboard(event.target)) {
              event.preventDefault();
            }
            send({ type: "DOC_KEY_UP", event });
          };
          const cleanup = (0, import_dom_event2.addDomEvent)(doc, "keyup", onKeyup, false);
          ctx2.cleanups.push(cleanup);
        },
        removeDocumentListeners(ctx2) {
          ctx2.cleanups.forEach((fn) => fn?.());
          ctx2.cleanups = (0, import_core.ref)([]);
        },
        resetContext(ctx2) {
          ctx2.activePointerId = null;
          ctx2.pointerType = null;
          ctx2.pointerdownEvent = null;
        },
        restoreTextSelection(ctx2) {
          if (ctx2.allowTextSelectionOnPress || !ctx2.target)
            return;
          (0, import_text_selection.restoreTextSelection)({ target: ctx2.target, doc: dom.getDoc(ctx2) });
        },
        setPointerToVirtual(ctx2) {
          ctx2.pointerType = "virtual";
        },
        setPointerType(ctx2, { event }) {
          ctx2.pointerType = event.pointerType;
        },
        setPointerId(ctx2, { event }) {
          ctx2.activePointerId = event.pointerId;
          ctx2.pointerdownEvent = (0, import_core.ref)(event);
        },
        setTarget(ctx2, { event }) {
          ctx2.target = (0, import_core.ref)(event.currentTarget);
        },
        focusIfNeeded(ctx2, { event }) {
          if (ctx2.disabled || ctx2.preventFocusOnPress)
            return;
          event.currentTarget.focus({ preventScroll: true });
        },
        invokeOnPressStart(ctx2, evt) {
          if (ctx2.disabled)
            return;
          let { event: originalEvent, pressEvent, pointerType } = evt;
          const event = pressEvent || originalEvent;
          ctx2.onPressStart?.({
            type: "pressstart",
            pointerType: pointerType || ctx2.pointerType,
            target: event.currentTarget,
            originalEvent: event
          });
        },
        disableTextSelection(ctx2) {
          if (!ctx2.target || ctx2.allowTextSelectionOnPress)
            return;
          (0, import_text_selection.disableTextSelection)({ target: ctx2.target, doc: dom.getDoc(ctx2) });
        },
        invokeOnPressUp(ctx2, { event, pointerType }) {
          if (ctx2.disabled)
            return;
          ctx2.onPressUp?.({
            type: "pressup",
            pointerType: pointerType || ctx2.pointerType,
            target: event.currentTarget,
            originalEvent: event
          });
        },
        invokeOnPressEnd(ctx2, { event, pointerType }) {
          ctx2.ignoreClickAfterPress = true;
          ctx2.onPressEnd?.({
            type: "pressend",
            pointerType: pointerType || ctx2.pointerType,
            target: event.currentTarget,
            originalEvent: event
          });
        },
        invokeOnPress(ctx2, { event, pointerType }) {
          if (ctx2.disabled)
            return;
          ctx2.onPress?.({
            type: "press",
            pointerType: pointerType || ctx2.pointerType,
            target: event.currentTarget,
            originalEvent: event
          });
        },
        triggerClick(ctx2, { event }) {
          let target = event.target;
          if (!(0, import_dom_query4.isHTMLElement)(ctx2.target)) {
            return;
          }
          const isAnchor = isHTMLAnchorLink(ctx2.target) || ctx2.target.getAttribute("role") === "link";
          if (ctx2.target.contains(target) && isAnchor) {
            ctx2.target.click();
          }
        },
        dispatchPointerCancel(ctx2) {
          if (!ctx2.target)
            return;
          const win = dom.getWin(ctx2);
          const evt = new win.PointerEvent("pointercancel", { bubbles: true });
          ctx2.target.dispatchEvent(evt);
        },
        invokeOnLongPress(ctx2, { pointerType }) {
          if (!ctx2.target)
            return;
          ctx2.onLongPress?.({
            type: "longpress",
            pointerType: pointerType || ctx2.pointerType,
            target: ctx2.target,
            originalEvent: ctx2.pointerdownEvent
          });
        },
        resetIgnoreClick(ctx2) {
          ctx2.ignoreClickAfterPress = false;
        },
        setPressedDown(ctx2) {
          ctx2.wasPressedDown = true;
        },
        clearPressedDown(ctx2) {
          ctx2.wasPressedDown = false;
        },
        preventContextMenu(ctx2) {
          if (ctx2.pointerType !== "touch" || !ctx2.onLongPress)
            return;
          const onContextMenu = (event) => event.preventDefault();
          const cleanup = (0, import_dom_event2.addDomEvent)(ctx2.target, "contextmenu", onContextMenu, { once: true });
          const onPointerUp = () => void setTimeout(cleanup, 30);
          (0, import_dom_event2.addDomEvent)(dom.getWin(ctx2), "pointerup", onPointerUp, { once: true });
        }
      }
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  connect,
  machine
});
