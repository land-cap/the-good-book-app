import {
  DEV as DEV2,
  unwrap
} from "./chunk-GP4UHQVM.js";
import {
  Portal,
  className,
  insert,
  isServer,
  template
} from "./chunk-5WKUAD65.js";
import {
  $PROXY,
  $TRACK,
  DEV,
  Index,
  Show,
  batch,
  createComponent,
  createComputed,
  createEffect,
  createMemo,
  createRenderEffect,
  createRoot,
  createSignal,
  getListener,
  getOwner,
  mergeProps,
  on,
  onCleanup,
  onMount,
  runWithOwner,
  sharedConfig,
  untrack
} from "./chunk-UR4ZDNLI.js";
import {
  __publicField
} from "./chunk-ENY474MH.js";

// node_modules/.pnpm/solid-devtools@0.26.0_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.1.4/node_modules/solid-devtools/dist/chunk-6DJR4ASJ.js
var makePostMessage = () => (name, details) => postMessage({ name, details }, "*");
var listeners = {};
function startListeningWindowMessages() {
  if (typeof window === "undefined")
    return;
  addEventListener("message", (event) => {
    var _a2;
    const name = (_a2 = event.data) == null ? void 0 : _a2.name;
    if (typeof name !== "string")
      return;
    const arr = listeners[name];
    if (arr)
      arr.forEach((f) => f(event.data.details));
    const arr2 = listeners["*"];
    if (arr2)
      arr2.forEach((f) => f({ name, details: event.data.details }));
  });
}
function makeMessageListener() {
  return (...args) => {
    const name = typeof args[0] === "string" ? args[0] : "*";
    const handler = typeof args[0] === "string" ? args[1] : args[0];
    let arr = listeners[name];
    if (!arr)
      arr = listeners[name] = [];
    arr.push(handler);
    return () => listeners[name] = arr.filter((l) => l !== handler);
  };
}

// node_modules/.pnpm/@solid-devtools+debugger@0.21.0_solid-js@1.7.2/node_modules/@solid-devtools/debugger/dist/chunk-4JABOMAE.js
var INFINITY = "Infinity";
var NEGATIVE_INFINITY = "NegativeInfinity";
var NAN = "NaN";
var UNDEFINED = "undefined";
var ValueType = ((ValueType2) => {
  ValueType2["Number"] = "number";
  ValueType2["Boolean"] = "boolean";
  ValueType2["String"] = "string";
  ValueType2["Null"] = "null";
  ValueType2["Symbol"] = "symbol";
  ValueType2["Array"] = "array";
  ValueType2["Object"] = "object";
  ValueType2["Function"] = "function";
  ValueType2["Getter"] = "getter";
  ValueType2["Element"] = "element";
  ValueType2["Instance"] = "instance";
  ValueType2["Store"] = "store";
  ValueType2["Unknown"] = "unknown";
  return ValueType2;
})(ValueType || {});
var PropGetterState = ((PropGetterState2) => {
  PropGetterState2["Live"] = "live";
  PropGetterState2["Stale"] = "stale";
  return PropGetterState2;
})(PropGetterState || {});
var WINDOW_PROJECTPATH_PROPERTY = "$sdt_projectPath";
var LOCATION_ATTRIBUTE_NAME = "data-source-loc";
var DevtoolsMainView = ((DevtoolsMainView2) => {
  DevtoolsMainView2["Structure"] = "structure";
  return DevtoolsMainView2;
})(DevtoolsMainView || {});
var DebuggerModule = ((DebuggerModule2) => {
  DebuggerModule2["Locator"] = "locator";
  DebuggerModule2["Structure"] = "structure";
  DebuggerModule2["Dgraph"] = "dgraph";
  return DebuggerModule2;
})(DebuggerModule || {});
var TreeWalkerMode = ((TreeWalkerMode2) => {
  TreeWalkerMode2["Owners"] = "owners";
  TreeWalkerMode2["Components"] = "components";
  TreeWalkerMode2["DOM"] = "dom";
  return TreeWalkerMode2;
})(TreeWalkerMode || {});
var DEFAULT_WALKER_MODE = "components";
var NodeType = ((NodeType2) => {
  NodeType2["Root"] = "root";
  NodeType2["Component"] = "component";
  NodeType2["Element"] = "element";
  NodeType2["Effect"] = "effect";
  NodeType2["Render"] = "render";
  NodeType2["Memo"] = "memo";
  NodeType2["Computation"] = "computation";
  NodeType2["Refresh"] = "refresh";
  NodeType2["Context"] = "context";
  NodeType2["Signal"] = "signal";
  NodeType2["Store"] = "store";
  return NodeType2;
})(NodeType || {});
var ValueItemType = ((ValueItemType2) => {
  ValueItemType2["Signal"] = "signal";
  ValueItemType2["Prop"] = "prop";
  ValueItemType2["Value"] = "value";
  return ValueItemType2;
})(ValueItemType || {});

// node_modules/.pnpm/@solid-devtools+shared@0.11.0_solid-js@1.7.2/node_modules/@solid-devtools/shared/dist/chunk-UICA3PK6.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/.pnpm/@solid-devtools+shared@0.11.0_solid-js@1.7.2/node_modules/@solid-devtools/shared/dist/chunk-ADTTRVSK.js
var utils_exports = {};
__export(utils_exports, {
  XOR: () => XOR,
  arrayRefEquals: () => arrayRefEquals,
  asArray: () => asArray,
  callArrayProp: () => callArrayProp,
  createCallbackStack: () => createCallbackStack,
  dedupeArray: () => dedupeArray,
  dedupeArrayById: () => dedupeArrayById,
  error: () => error,
  findIndexById: () => findIndexById,
  findItemById: () => findItemById,
  formatTime: () => formatTime,
  info: () => info,
  isRecord: () => isRecord,
  log: () => log,
  mutateFilter: () => mutateFilter,
  mutateRemove: () => mutateRemove,
  pushToArrayProp: () => pushToArrayProp,
  splitOnColon: () => splitOnColon,
  trimString: () => trimString,
  warn: () => warn,
  whileArray: () => whileArray
});
var getLogLabel = () => [
  `%csolid-devtools`,
  "color: #fff; background: #2c4f7c; padding: 1px 4px;"
];
function info(data) {
  console.info(...getLogLabel(), data);
  return data;
}
function log(...args) {
  console.log(...getLogLabel(), ...args);
  return;
}
function warn(...args) {
  console.warn(...getLogLabel(), ...args);
  return;
}
function error(...args) {
  console.error(...getLogLabel(), ...args);
  return;
}
function formatTime(d = new Date()) {
  return ("0" + d.getHours()).slice(-2) + ":" + ("0" + d.getMinutes()).slice(-2) + ":" + ("0" + d.getSeconds()).slice(-2);
}
var asArray = (value) => Array.isArray(value) ? value : [value];
var createCallbackStack = () => {
  let stack = [];
  const clear = () => stack = [];
  return {
    push: (...callbacks) => stack.push(...callbacks),
    execute(arg0, arg1, arg2, arg3) {
      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));
      clear();
    },
    clear
  };
};
function callArrayProp(object, key, ...args) {
  const arr = object[key];
  if (arr)
    for (const cb of arr)
      cb(...args);
}
function pushToArrayProp(object, key, value) {
  let arr = object[key];
  if (arr)
    arr.push(value);
  else
    arr = object[key] = [value];
  return arr;
}
function mutateFilter(array, predicate) {
  const temp = array.filter(predicate);
  array.length = 0;
  array.push.apply(array, temp);
}
function mutateRemove(array, item) {
  array.splice(array.indexOf(item), 1);
}
var dedupeArray = (array) => Array.from(new Set(array));
var arrayRefEquals = (a, b) => a === b || a.length === b.length && a.every((e) => b.includes(e));
function trimString(str, maxLength) {
  if (str.length <= maxLength)
    return str;
  return str.slice(0, maxLength) + "â€¦";
}
function findIndexById(array, id) {
  for (let i = 0; i < array.length; i++)
    if (array[i].id === id)
      return i;
  return -1;
}
function findItemById(array, id) {
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    if (item.id === id)
      return item;
  }
}
var splitOnColon = (str) => {
  const splitIndex = str.indexOf(":");
  if (splitIndex === -1)
    return [str, null];
  return [str.slice(0, splitIndex), str.slice(splitIndex + 1)];
};
function whileArray(toCheck, callback) {
  let index = 0;
  let current = toCheck[index++];
  while (current) {
    const result = callback(current, toCheck);
    if (result !== void 0)
      return result;
    current = toCheck[index++];
  }
}
var isRecord = (value) => typeof value === "object" && value !== null && Object.getPrototypeOf(value) === Object.prototype;
var XOR = (a, b) => (a || b) && !(a && b);
function dedupeArrayById(input) {
  const ids = /* @__PURE__ */ new Set();
  const deduped = [];
  for (let i = input.length - 1; i >= 0; i--) {
    const update = input[i];
    if (ids.has(update.id))
      continue;
    ids.add(update.id);
    deduped.push(update);
  }
  return deduped;
}

// node_modules/.pnpm/@solid-primitives+scheduled@1.3.2_solid-js@1.7.2/node_modules/@solid-primitives/scheduled/dist/index.js
var throttle = (callback, wait) => {
  if (isServer) {
    return Object.assign(() => void 0, { clear: () => void 0 });
  }
  let isThrottled = false, timeoutId, lastArgs;
  const throttled = (...args) => {
    lastArgs = args;
    if (isThrottled)
      return;
    isThrottled = true;
    timeoutId = setTimeout(() => {
      callback(...lastArgs);
      isThrottled = false;
    }, wait);
  };
  const clear = () => {
    clearTimeout(timeoutId);
    isThrottled = false;
  };
  if (getOwner())
    onCleanup(clear);
  return Object.assign(throttled, { clear });
};
var scheduleIdle = isServer ? () => Object.assign(() => void 0, { clear: () => void 0 }) : (
  // requestIdleCallback is not supported in Safari
  window.requestIdleCallback ? (callback, maxWait) => {
    let isDeferred = false, id, lastArgs;
    const deferred = (...args) => {
      lastArgs = args;
      if (isDeferred)
        return;
      isDeferred = true;
      id = requestIdleCallback(
        () => {
          callback(...lastArgs);
          isDeferred = false;
        },
        { timeout: maxWait }
      );
    };
    const clear = () => {
      cancelIdleCallback(id);
      isDeferred = false;
    };
    if (getOwner())
      onCleanup(clear);
    return Object.assign(deferred, { clear });
  } : (
    // fallback to setTimeout (throttle)
    (callback) => throttle(callback)
  )
);

// node_modules/.pnpm/@solid-primitives+utils@6.1.0_solid-js@1.7.2/node_modules/@solid-primitives/utils/dist/chunk/G4OJDHGR.js
var noop = () => void 0;
var isClient = !isServer;
var isDev = isClient && !!DEV;
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
var isNonNullable = (i) => i != null;
var filterNonNullable = (arr) => arr.filter(isNonNullable);
var access = (v) => typeof v === "function" && !v.length ? v() : v;
var asArray2 = (value) => Array.isArray(value) ? value : value ? [value] : [];
function accessWith(valueOrFn, ...args) {
  return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}
var tryOnCleanup = isDev ? (fn) => getOwner() ? onCleanup(fn) : fn : onCleanup;
function createHydratableSignal(serverValue, update, options) {
  if (isServer) {
    return createSignal(serverValue, options);
  }
  if (sharedConfig.context) {
    const [state, setState] = createSignal(serverValue, options);
    onMount(() => setState(() => update()));
    return [state, setState];
  }
  return createSignal(update(), options);
}
function handleDiffArray(current, prev, handleAdded, handleRemoved) {
  const currLength = current.length;
  const prevLength = prev.length;
  let i = 0;
  if (!prevLength) {
    for (; i < currLength; i++)
      handleAdded(current[i]);
    return;
  }
  if (!currLength) {
    for (; i < prevLength; i++)
      handleRemoved(prev[i]);
    return;
  }
  for (; i < prevLength; i++) {
    if (prev[i] !== current[i])
      break;
  }
  let prevEl;
  let currEl;
  prev = prev.slice(i);
  current = current.slice(i);
  for (prevEl of prev) {
    if (!current.includes(prevEl))
      handleRemoved(prevEl);
  }
  for (currEl of current) {
    if (!prev.includes(currEl))
      handleAdded(currEl);
  }
}

// node_modules/.pnpm/@solid-primitives+event-listener@2.2.10_solid-js@1.7.2/node_modules/@solid-primitives/event-listener/dist/index.js
function makeEventListener(target, type, handler, options) {
  target.addEventListener(type, handler, options);
  return tryOnCleanup(target.removeEventListener.bind(target, type, handler, options));
}

// node_modules/.pnpm/@solid-primitives+static-store@0.0.2_solid-js@1.7.2/node_modules/@solid-primitives/static-store/dist/index.js
function createStaticStore(init) {
  const copy = { ...init }, store = { ...init }, cache = {};
  const getValue = (key) => {
    let signal = cache[key];
    if (!signal) {
      if (!getListener())
        return copy[key];
      cache[key] = signal = createSignal(copy[key], { internal: true });
      delete copy[key];
    }
    return signal[0]();
  };
  for (const key in init) {
    Object.defineProperty(store, key, { get: () => getValue(key), enumerable: true });
  }
  const setValue = (key, value) => {
    const signal = cache[key];
    if (signal)
      return signal[1](value);
    if (key in copy)
      copy[key] = accessWith(value, [copy[key]]);
  };
  return [
    store,
    (a, b) => {
      if (isObject(a)) {
        const entries3 = untrack(
          () => Object.entries(accessWith(a, store))
        );
        batch(() => {
          for (const [key, value] of entries3)
            setValue(key, () => value);
        });
      } else
        setValue(a, b);
      return store;
    }
  ];
}
function createHydratableStaticStore(serverValue, update) {
  if (isServer)
    return createStaticStore(serverValue);
  if (sharedConfig.context) {
    const [state, setState] = createStaticStore(serverValue);
    onMount(() => setState(update()));
    return [state, setState];
  }
  return createStaticStore(update());
}

// node_modules/.pnpm/@solid-primitives+rootless@1.3.2_solid-js@1.7.2/node_modules/@solid-primitives/rootless/dist/index.js
function createSingletonRoot(factory, detachedOwner = getOwner()) {
  let listeners2 = 0, value, disposeRoot;
  return () => {
    listeners2++;
    onCleanup(() => {
      listeners2--;
      queueMicrotask(() => {
        if (!listeners2 && disposeRoot) {
          disposeRoot();
          disposeRoot = value = void 0;
        }
      });
    });
    if (!disposeRoot) {
      createRoot((dispose) => value = factory(disposeRoot = dispose), detachedOwner);
    }
    return value;
  };
}
var createSharedRoot = createSingletonRoot;
function createHydratableSingletonRoot(factory) {
  const owner = getOwner();
  const singleton = createSingletonRoot(factory, owner);
  return () => isServer || sharedConfig.context ? createRoot(factory, owner) : singleton();
}

// node_modules/.pnpm/@solid-primitives+media@2.1.6_solid-js@1.7.2/node_modules/@solid-primitives/media/dist/index.js
function createMediaQuery(query, serverFallback = false) {
  if (isServer) {
    return () => serverFallback;
  }
  const mql = window.matchMedia(query);
  const [state, setState] = createHydratableSignal(serverFallback, () => mql.matches);
  const update = () => setState(mql.matches);
  makeEventListener(mql, "change", update);
  return state;
}
function createPrefersDark(serverFallback) {
  return createMediaQuery("(prefers-color-scheme: dark)", serverFallback);
}
var usePrefersDark = createHydratableSingletonRoot(
  createPrefersDark.bind(void 0, false)
);

// node_modules/.pnpm/@solid-primitives+utils@5.5.2_solid-js@1.7.2/node_modules/@solid-primitives/utils/dist/index.js
function isObject2(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
var access2 = (v) => typeof v === "function" && !v.length ? v() : v;
function accessWith2(valueOrFn, ...args) {
  return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}
function defer2(deps, fn, initialValue) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let shouldDefer = true;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++)
        input[i] = deps[i]();
    } else
      input = deps();
    if (shouldDefer) {
      shouldDefer = false;
      prevInput = input;
      return initialValue;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
var entries2 = Object.entries;
var tryOnCleanup2 = (fn) => getOwner() ? onCleanup(fn) : fn;
function createStaticStore2(init) {
  const copy = { ...init };
  const store = { ...init };
  const cache = /* @__PURE__ */ new Map();
  const getValue = (key) => {
    const saved = cache.get(key);
    if (saved)
      return saved[0]();
    const signal = createSignal(copy[key], {
      internal: true
    });
    cache.set(key, signal);
    delete copy[key];
    return signal[0]();
  };
  const setValue = (key, value) => {
    const saved = cache.get(key);
    if (saved)
      return saved[1](value);
    if (key in copy)
      copy[key] = accessWith2(value, [copy[key]]);
  };
  for (const key in init) {
    Object.defineProperty(store, key, { get: getValue.bind(void 0, key) });
  }
  const setter = (a, b) => {
    if (isObject2(a)) {
      const entries22 = untrack(
        () => Object.entries(accessWith2(a, store))
      );
      batch(() => {
        for (const [key, value] of entries22)
          setValue(key, () => value);
      });
    } else
      setValue(a, b);
    return store;
  };
  return [store, setter];
}

// node_modules/.pnpm/@solid-devtools+shared@0.11.0_solid-js@1.7.2/node_modules/@solid-devtools/shared/dist/chunk-3RCNHZC4.js
var primitives_exports = {};
__export(primitives_exports, {
  atom: () => atom,
  createConsumers: () => createConsumers,
  createDerivedSignal: () => createDerivedSignal,
  createHover: () => createHover,
  createPingedSignal: () => createPingedSignal,
  createShallowStore: () => createShallowStore,
  defer: () => defer3,
  handleTupleUpdate: () => handleTupleUpdate,
  handleTupleUpdates: () => handleTupleUpdates,
  makeHoverElementListener: () => makeHoverElementListener,
  untrackedCallback: () => untrackedCallback,
  useIsMobile: () => useIsMobile,
  useIsTouch: () => useIsTouch
});
var untrackedCallback = (fn) => (...a) => untrack(fn.bind(void 0, ...a));
var useIsTouch = createSharedRoot(() => createMediaQuery("(hover: none)"));
var useIsMobile = createSharedRoot(() => createMediaQuery("(max-width: 640px)"));
function createHover(handle) {
  let state = false;
  let mounted = true;
  const mql = window.matchMedia("(hover: none)");
  let isTouch = mql.matches;
  makeEventListener(mql, "change", ({ matches }) => {
    if (isTouch = matches)
      handle(state = false);
  });
  onCleanup(() => {
    mounted = false;
    if (state)
      handle(state = false);
  });
  const onChange = (newState) => {
    if (isTouch || !mounted)
      return;
    state !== newState && handle(state = newState);
  };
  return {
    onMouseEnter: () => onChange(true),
    onMouseLeave: () => setTimeout(() => onChange(false))
  };
}
function createConsumers(initial = []) {
  const [consumers, setConsumers] = createSignal([...initial], { name: "consumers" });
  const enabled = createMemo(() => consumers().some((consumer) => consumer()));
  return [
    enabled,
    (consumer) => {
      setConsumers((p) => [...p, consumer]);
      tryOnCleanup2(() => setConsumers((p) => p.filter((c) => c !== consumer)));
    }
  ];
}
function createDerivedSignal(fallback, options) {
  const [source, setSource] = createSignal();
  return [
    createMemo(
      () => {
        const sourceRef = source();
        return sourceRef ? sourceRef() : fallback;
      },
      void 0,
      options
    ),
    (newSource) => {
      if (newSource && getOwner())
        onCleanup(() => setSource((p) => p === newSource ? void 0 : p));
      return setSource(() => newSource);
    }
  ];
}
function makeHoverElementListener(onHover) {
  let last = null;
  const handleHover = (e) => {
    const { target } = e;
    if (target === last || !(target instanceof HTMLElement) && target !== null)
      return;
    onHover(last = target);
  };
  makeEventListener(window, "mouseover", handleHover);
  makeEventListener(document, "mouseleave", handleHover.bind(void 0, { target: null }));
}
function defer3(deps, fn, initialValue) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let shouldDefer = true;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++)
        input[i] = deps[i]();
    } else
      input = deps();
    if (shouldDefer) {
      shouldDefer = false;
      prevInput = input;
      return initialValue;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function atom(value, options) {
  const [state, setState] = createSignal(value, { internal: true, ...options });
  return (...args) => args.length === 1 ? setState(args[0]) : state();
}
function createPingedSignal(timeout = 400) {
  const [isUpdated, setIsUpdated] = createSignal(false);
  let timeoutId;
  const ping = () => {
    setIsUpdated(true);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => setIsUpdated(false), timeout);
  };
  onCleanup(() => clearTimeout(timeoutId));
  return [isUpdated, ping];
}
function createShallowStore(storeValue) {
  const signals = {};
  const [keys2, setKeys] = createSignal(Object.keys(storeValue), { internal: true });
  let hasKeysChanged = false;
  const setValue = (key, setterParam) => {
    const saved = signals[key];
    const newValue = saved ? saved[1](setterParam) : accessWith2(setterParam, storeValue[key]);
    if (newValue === void 0) {
      delete storeValue[key];
      hasKeysChanged = true;
    } else {
      storeValue[key] = newValue;
    }
  };
  const setter = (a, b) => {
    batch(() => {
      if (typeof a === "object" || typeof a === "function")
        untrack(() => {
          for (const [key, newValue] of entries2(accessWith2(a, store)))
            setValue(key, () => newValue);
        });
      else
        setValue(a, b);
      if (hasKeysChanged) {
        hasKeysChanged = false;
        setKeys(Object.keys(storeValue));
      }
    });
    return store;
  };
  const store = new Proxy(storeValue, {
    get(target, key) {
      if (key === $TRACK) {
        keys2();
        return true;
      }
      let signal = signals[key];
      if (!signal) {
        if (!getListener()) {
          return storeValue[key];
        }
        signal = createSignal(storeValue[key], { internal: true });
        signals[key] = signal;
      }
      return signal[0]();
    },
    has(target, key) {
      if (key === $TRACK)
        return true;
      this.get(target, key, target);
      return key in target;
    },
    set() {
      console.warn("Cannot mutate a Store directly");
      return true;
    },
    deleteProperty() {
      console.warn("Cannot mutate a Store directly");
      return true;
    },
    ownKeys: () => keys2().slice(),
    getOwnPropertyDescriptor() {
      console.warn("getOwnPropertyDescriptor is not yet implemented for shallow stores");
      return void 0;
    }
  });
  return [store, setter];
}
function handleTupleUpdate(handlers) {
  return (update) => handlers[update[0]](update[1]);
}
function handleTupleUpdates(handlers) {
  function runUpdates(updates) {
    for (const [key, value] of updates)
      handlers[key](value);
  }
  return (updates) => batch(runUpdates.bind(void 0, updates));
}

// node_modules/.pnpm/@solid-primitives+keyboard@1.2.0_solid-js@1.7.2/node_modules/@solid-primitives/keyboard/dist/index.js
var useKeyDownEvent = createSingletonRoot(
  () => {
    if (isServer) {
      return () => null;
    }
    const [event, setEvent] = createSignal(null);
    makeEventListener(window, "keydown", (e) => {
      setEvent(e);
      setTimeout(() => setEvent(null));
    });
    return event;
  }
);
var useKeyDownList = createSingletonRoot(() => {
  if (isServer) {
    const keys2 = () => [];
    keys2[0] = keys2;
    keys2[1] = { event: () => null };
    keys2[Symbol.iterator] = function* () {
      yield keys2[0];
      yield keys2[1];
    };
    return keys2;
  }
  const [pressedKeys, setPressedKeys] = createSignal([]), reset = () => setPressedKeys([]), event = useKeyDownEvent();
  makeEventListener(window, "keydown", (e) => {
    if (e.repeat || typeof e.key !== "string")
      return;
    const key = e.key.toUpperCase(), currentKeys = pressedKeys();
    if (currentKeys.includes(key))
      return;
    const keys2 = [...currentKeys, key];
    if (currentKeys.length === 0 && key !== "ALT" && key !== "CONTROL" && key !== "META" && key !== "SHIFT") {
      if (e.shiftKey)
        keys2.unshift("SHIFT");
      if (e.altKey)
        keys2.unshift("ALT");
      if (e.ctrlKey)
        keys2.unshift("CONTROL");
      if (e.metaKey)
        keys2.unshift("META");
    }
    setPressedKeys(keys2);
  });
  makeEventListener(window, "keyup", (e) => {
    if (typeof e.key !== "string")
      return;
    const key = e.key.toUpperCase();
    setPressedKeys((prev) => prev.filter((_key) => _key !== key));
  });
  makeEventListener(window, "blur", reset);
  makeEventListener(window, "contextmenu", (e) => {
    e.defaultPrevented || reset();
  });
  pressedKeys[0] = pressedKeys;
  pressedKeys[1] = { event };
  pressedKeys[Symbol.iterator] = function* () {
    yield pressedKeys[0];
    yield pressedKeys[1];
  };
  return pressedKeys;
});
var useCurrentlyHeldKey = createSingletonRoot(
  () => {
    if (isServer) {
      return () => null;
    }
    const keys2 = useKeyDownList();
    let prevKeys = untrack(keys2);
    return createMemo(() => {
      const _keys = keys2();
      const prev = prevKeys;
      prevKeys = _keys;
      if (prev.length === 0 && _keys.length === 1)
        return _keys[0];
      return null;
    });
  }
);
var useKeyDownSequence = createSingletonRoot(() => {
  if (isServer) {
    return () => [];
  }
  const keys2 = useKeyDownList();
  return createMemo((prev) => {
    if (keys2().length === 0)
      return [];
    return [...prev, keys2()];
  }, []);
});
function createKeyHold(key, options = {}) {
  if (isServer) {
    return () => false;
  }
  key = key.toUpperCase();
  const { preventDefault = true } = options, event = useKeyDownEvent(), heldKey = useCurrentlyHeldKey();
  return createMemo(() => {
    var _a2;
    return heldKey() === key && (preventDefault && ((_a2 = event()) == null ? void 0 : _a2.preventDefault()), true);
  });
}

// node_modules/.pnpm/@solid-primitives+resize-observer@2.0.15_solid-js@1.7.2/node_modules/@solid-primitives/resize-observer/dist/index.js
function makeResizeObserver(callback, options) {
  if (isServer) {
    return { observe: noop, unobserve: noop };
  }
  const observer = new ResizeObserver(callback);
  onCleanup(observer.disconnect.bind(observer));
  return {
    observe: (ref) => observer.observe(ref, options),
    unobserve: observer.unobserve.bind(observer)
  };
}
function createResizeObserver(targets, onResize, options) {
  if (isServer)
    return;
  const previousMap = /* @__PURE__ */ new WeakMap(), { observe, unobserve } = makeResizeObserver((entries3) => {
    for (const entry of entries3) {
      const { contentRect, target } = entry, width = Math.round(contentRect.width), height = Math.round(contentRect.height), previous = previousMap.get(target);
      if (!previous || previous.width !== width || previous.height !== height) {
        onResize(contentRect, target, entry);
        previousMap.set(target, { width, height });
      }
    }
  }, options);
  createEffect((prev) => {
    const refs = filterNonNullable(asArray2(access(targets)));
    handleDiffArray(refs, prev, observe, unobserve);
    return refs;
  }, []);
}
var WINDOW_SIZE_FALLBACK = { width: 0, height: 0 };
function getWindowSize() {
  if (isServer)
    return { ...WINDOW_SIZE_FALLBACK };
  return {
    width: window.innerWidth,
    height: window.innerHeight
  };
}
function createWindowSize() {
  if (isServer) {
    return WINDOW_SIZE_FALLBACK;
  }
  const [size, setSize] = createHydratableStaticStore(WINDOW_SIZE_FALLBACK, getWindowSize);
  makeEventListener(window, "resize", () => setSize(getWindowSize()));
  return size;
}
var useWindowSize = createHydratableSingletonRoot(createWindowSize);

// node_modules/.pnpm/@solid-primitives+bounds@0.0.107_solid-js@1.7.2/node_modules/@solid-primitives/bounds/dist/index.js
var NULLED_BOUNDS = {
  top: null,
  left: null,
  bottom: null,
  right: null,
  width: null,
  height: null
};
function getElementBounds(element) {
  if (!element) {
    return Object.assign({}, NULLED_BOUNDS);
  }
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    left: rect.left,
    bottom: rect.bottom,
    right: rect.right,
    width: rect.width,
    height: rect.height
  };
}
function createElementBounds(target, { trackMutation = true, trackResize = true, trackScroll = true } = {}) {
  const [bounds, setBounds] = createStaticStore2(getElementBounds(access2(target)));
  const updateBounds = () => setBounds(getElementBounds(access2(target)));
  const updateBoundsOf = (el) => setBounds(getElementBounds(el));
  if (typeof target === "function") {
    onMount(() => updateBoundsOf(target()));
    createComputed(on(target, updateBoundsOf, { defer: true }));
  }
  if (trackResize) {
    const resizeHandler = (_, el) => updateBoundsOf(el);
    createResizeObserver(
      typeof target === "function" ? () => target() || [] : target,
      typeof trackResize === "function" ? trackResize(resizeHandler) : resizeHandler
    );
  }
  if (trackScroll) {
    const scrollHandler = typeof target === "function" ? (e) => {
      const el = target();
      if (el && e.target instanceof Node && e.target.contains(el))
        updateBoundsOf(el);
    } : (e) => {
      if (e.target instanceof Node && e.target.contains(target))
        updateBoundsOf(target);
    };
    makeEventListener(
      window,
      "scroll",
      typeof trackScroll === "function" ? trackScroll(scrollHandler) : scrollHandler,
      { capture: true }
    );
  }
  if (trackMutation) {
    const mo = new MutationObserver(
      typeof trackMutation === "function" ? trackMutation(updateBounds) : updateBounds
    );
    mo.observe(document.body, {
      attributeFilter: ["style", "class"],
      subtree: true,
      childList: true
    });
    onCleanup(mo.disconnect.bind(mo));
  }
  return bounds;
}

// node_modules/.pnpm/@solid-primitives+cursor@0.0.105_solid-js@1.7.2/node_modules/@solid-primitives/cursor/dist/index.js
function createElementCursor(target, cursor) {
  createEffect(() => {
    const el = access2(target);
    const cursorValue = access2(cursor);
    if (!el)
      return;
    const overwritten = el.style.cursor;
    el.style.setProperty("cursor", cursorValue, "important");
    onCleanup(() => el.style.cursor = overwritten);
  });
}

// node_modules/.pnpm/@solid-primitives+platform@0.0.103_solid-js@1.7.2/node_modules/@solid-primitives/platform/dist/index.js
var w = window;
var n = w.navigator;
var ua = n.userAgent;
var isAndroid = /Android/.test(ua);
var isWindows = /(win32|win64|windows|wince)/i.test(ua);
var isMac = /(macintosh|macintel|macppc|mac68k|macos)/i.test(ua);
var isIPhone = /iphone/i.test(ua);
var isIPad = /ipad/i.test(ua) && n.maxTouchPoints > 1;
var isIPod = /ipod/i.test(ua);
var isMobile = /Mobi/.test(ua);
var isFirefox = /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(ua);
var isOpera = !!w.opr && !!w.opr.addons || !!w.opera || / OPR\//.test(ua);
var _a;
var isSafari = /constructor/i.test(w.HTMLElement) || ((_a = w.safari) == null ? void 0 : _a.pushNotification) + "" === "[object SafariRemoteNotification]";
var isIE = !!w.document.documentMode;
var isChromium = !!w.chrome;
var isEdge = /Edg/.test(ua) && isChromium;
var isChrome = isChromium && n.vendor === "Google Inc." && !isOpera && !isEdge;
var isGecko = /Gecko\/[0-9.]+/.test(ua);
var isBlink = /Chrome\/[0-9.]+/.test(ua);
var isWebKit = /AppleWebKit\/[0-9.]+/.test(ua) && !isBlink;
var isPresto = /Opera\/[0-9.]+/.test(ua);
var isTrident = /Trident\/[0-9.]+/.test(ua);
var isEdgeHTML = /Edge\/[0-9.]+/.test(ua);

// node_modules/.pnpm/@solid-primitives+event-bus@1.0.5_solid-js@1.7.2/node_modules/@solid-primitives/event-bus/dist/index.js
var EventBusCore = class extends Set {
  emit(payload) {
    for (const cb of this)
      cb(payload);
  }
};
function createEventBus() {
  const bus = new EventBusCore();
  return {
    listen(listener) {
      bus.add(listener);
      return tryOnCleanup(bus.delete.bind(bus, listener));
    },
    emit: bus.emit.bind(bus),
    clear: onCleanup(bus.clear.bind(bus))
  };
}
var EmitterCore = class extends Map {
  on(event, listener) {
    let bus = this.get(event);
    bus || this.set(event, bus = new EventBusCore());
    bus.add(listener);
  }
  off(event, listener) {
    const bus = this.get(event);
    (bus == null ? void 0 : bus.delete(listener)) && !bus.size && this.delete(event);
  }
  emit(event, value) {
    var _a2;
    (_a2 = this.get(event)) == null ? void 0 : _a2.emit(value);
  }
};
function createEmitter() {
  const emitter = new EmitterCore();
  return {
    on(event, listener) {
      emitter.on(event, listener);
      return tryOnCleanup(emitter.off.bind(emitter, event, listener));
    },
    emit: emitter.emit.bind(emitter),
    clear: onCleanup(emitter.clear.bind(emitter))
  };
}
function createGlobalEmitter() {
  const emitter = createEmitter();
  const global = createEventBus();
  return {
    on: emitter.on,
    clear: emitter.clear,
    listen: global.listen,
    emit(name, details) {
      global.emit({ name, details });
      emitter.emit(name, details);
    }
  };
}

// node_modules/.pnpm/@solid-devtools+debugger@0.21.0_solid-js@1.7.2/node_modules/@solid-devtools/debugger/dist/index.js
var STORE_DEV = DEV2;
var getOwner2 = getOwner;
var isSolidComputation = (o) => "fn" in o;
var isSolidMemo = (o) => "sdtType" in o ? o.sdtType === "memo" : isSolidComputation(o) && _isMemo(o);
var isSolidOwner = (o) => "owned" in o;
var isSolidRoot = (o) => o.sdtType === "root" || !isSolidComputation(o);
var isSolidComponent = (o) => "props" in o;
var isStoreNode = (o) => STORE_DEV.$NAME in o;
var isSolidStore = (o) => {
  return !("observers" in o) && STORE_DEV.$NAME in o.value;
};
var _isMemo = (o) => "value" in o && "comparator" in o && o.pure === true;
function getOwnerName(owner) {
  const { name, componentName: component } = owner;
  if (component && typeof component === "string")
    return component.startsWith("_Hot$$") ? component.slice(6) : component;
  return name || "(unnamed)";
}
function getSignalName(signal) {
  return signal.name || "(unnamed)";
}
var getStoreNodeName = (node) => node[STORE_DEV.$NAME] || "(unnamed)";
function getNodeName(o) {
  const name = isSolidOwner(o) ? getOwnerName(o) : isSolidStore(o) ? getStoreNodeName(o) : getSignalName(o);
  return getDisplayName(name);
}
function getDisplayName(name) {
  return trimString(name, 20);
}
function getNodeType(o) {
  if (isSolidOwner(o))
    return getOwnerType(o);
  return isSolidStore(o) ? "store" : "signal";
}
var getOwnerType = (o) => {
  if (typeof o.sdtType !== "undefined")
    return o.sdtType;
  if (!isSolidComputation(o))
    return "root";
  if (isSolidComponent(o))
    return "component";
  if (_isMemo(o)) {
    let parent, parentName;
    if ((parent = o.owner) && isSolidComponent(parent) && (parentName = parent.componentName) && parentName.startsWith("_Hot$$"))
      return "refresh";
    return "memo";
  }
  if (o.pure === false) {
    if (o.user === true)
      return "effect";
    if (o.context !== null)
      return "context";
    return "render";
  }
  return "computation";
};
function markOwnerName(o) {
  if (o.sdtName !== void 0)
    return o.sdtName;
  return o.sdtName = getNodeName(o);
}
function markOwnerType(o) {
  if (o.sdtType !== void 0)
    return o.sdtType;
  return o.sdtType = getOwnerType(o);
}
function isDisposed(o) {
  return !!(isSolidRoot(o) ? o.isDisposed : o.owner && (!o.owner.owned || !o.owner.owned.includes(o)));
}
function getComponentRefreshNode(owner) {
  const { owned } = owner;
  let refresh;
  if (owned && owned.length === 1 && markOwnerType(refresh = owned[0]) === "refresh") {
    return refresh;
  }
  return null;
}
function resolveElements(value) {
  const resolved = getResolvedElements(value);
  if (Array.isArray(resolved))
    return resolved.length ? resolved : null;
  return resolved ? [resolved] : null;
}
function getResolvedElements(value) {
  if (typeof value === "function" && !value.length && value.name === "bound readSignal")
    return getResolvedElements(value());
  if (Array.isArray(value)) {
    const results = [];
    for (const item of value) {
      const result = getResolvedElements(item);
      if (result)
        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return value instanceof HTMLElement ? value : null;
}
var tryOnCleanup3 = (fn) => getOwner2() ? onCleanup(fn) : fn;
function onOwnerCleanup(owner, fn, prepend = false, symbol) {
  if (owner.cleanups === null)
    owner.cleanups = [fn];
  else {
    if (symbol) {
      if (owner.cleanups.some((c) => c[symbol])) {
        return () => {
          var _a2;
          return (_a2 = owner.cleanups) == null ? void 0 : _a2.splice(
            owner.cleanups.findIndex((c) => c[symbol]),
            1
          );
        };
      }
      fn[symbol] = true;
    }
    if (prepend)
      owner.cleanups.unshift(fn);
    else
      owner.cleanups.push(fn);
  }
  return () => {
    var _a2;
    return (_a2 = owner.cleanups) == null ? void 0 : _a2.splice(owner.cleanups.indexOf(fn), 1);
  };
}
function onParentCleanup(owner, fn, prepend = false, symbol) {
  if (owner.owner)
    return onOwnerCleanup(owner.owner, fn, prepend, symbol);
  return () => {
  };
}
function onOwnerDispose(owner, fn, prepend = false, symbol) {
  if (isSolidRoot(owner))
    return onOwnerCleanup(owner, fn, prepend, symbol);
  return onParentCleanup(owner, fn, prepend, symbol);
}
function createBatchedUpdateEmitter(emit) {
  const updates = /* @__PURE__ */ new Set();
  const triggerUpdateEmit = throttle(() => {
    emit([...updates]);
    updates.clear();
  });
  return (update) => {
    updates.add(update);
    triggerUpdateEmit();
  };
}
var $CLEANUP = Symbol("component-registry-cleanup");
var ComponentMap = /* @__PURE__ */ new Map();
var ElementNodeMap = /* @__PURE__ */ new Map();
function cleanupComponent(nodeID) {
  const component = ComponentMap.get(nodeID);
  if (!component)
    return;
  component.cleanup();
  ComponentMap.delete(nodeID);
  for (const element of component.elementNodes)
    ElementNodeMap.delete(element);
}
function registerComponent(data) {
  if ("elementId" in data) {
    const { componentId, elementId, element } = data;
    const component = ComponentMap.get(componentId);
    if (!component)
      return;
    component.elementNodes.add(elementId);
    ElementNodeMap.set(elementId, { el: element, component });
  } else {
    const { owner, id, name, elements: elementsList } = data;
    if (!elementsList)
      return cleanupComponent(id);
    const set = new Set(elementsList);
    const existing = ComponentMap.get(id);
    if (existing) {
      existing.elements = set;
      return;
    }
    const cleanup = onOwnerCleanup(owner, () => cleanupComponent(id), false, $CLEANUP);
    ComponentMap.set(id, {
      id,
      owner,
      name,
      elements: set,
      cleanup,
      elementNodes: /* @__PURE__ */ new Set()
    });
  }
}
function clearComponentRegistry() {
  for (const component of ComponentMap.values())
    component.cleanup();
  ComponentMap.clear();
  ElementNodeMap.clear();
}
function getComponent(id) {
  const component = ComponentMap.get(id);
  if (component)
    return { name: component.name, elements: [...component.elements], id };
  const elData = ElementNodeMap.get(id);
  return elData ? { name: elData.component.name, id: elData.component.id, elements: [elData.el] } : null;
}
function findComponent(el) {
  const including = /* @__PURE__ */ new Map();
  let currEl = el;
  while (currEl) {
    for (const component of ComponentMap.values()) {
      if (component.elements.has(currEl))
        including.set(component.owner, component);
    }
    currEl = including.size === 0 ? currEl.parentElement : null;
  }
  if (including.size > 1) {
    for (const owner of including.keys()) {
      if (!including.has(owner))
        continue;
      let currOwner = owner.owner;
      while (currOwner) {
        const deleted = including.delete(currOwner);
        if (deleted)
          break;
        currOwner = currOwner.owner;
      }
    }
  }
  if (including.size === 0)
    return null;
  const { name, id } = including.values().next().value;
  return { name, id };
}
var LastId = 0;
var getNewSdtId = () => `#${(LastId++).toString(36)}`;
var WeakIdMap = /* @__PURE__ */ new WeakMap();
var RefMapMap = {
  [
    "owner"
    /* Owner */
  ]: /* @__PURE__ */ new Map(),
  [
    "element"
    /* Element */
  ]: /* @__PURE__ */ new Map(),
  [
    "signal"
    /* Signal */
  ]: /* @__PURE__ */ new Map(),
  [
    "store"
    /* Store */
  ]: /* @__PURE__ */ new Map(),
  [
    "store-node"
    /* StoreNode */
  ]: /* @__PURE__ */ new Map()
};
var CleanupRegistry = new FinalizationRegistry((data) => {
  RefMapMap[data.map].delete(data.id);
});
function getSdtId(obj, objType) {
  let id = WeakIdMap.get(obj);
  if (!id) {
    id = getNewSdtId();
    WeakIdMap.set(obj, id);
    RefMapMap[objType].set(id, new WeakRef(obj));
    CleanupRegistry.register(obj, { map: objType, id });
  }
  return id;
}
function getObjectById(id, objType) {
  const ref = RefMapMap[objType].get(id);
  return (ref == null ? void 0 : ref.deref()) ?? null;
}
var RootMap = /* @__PURE__ */ new Map();
var getCurrentRoots = () => RootMap.values();
var OnOwnerNeedsUpdate;
function setOnOwnerNeedsUpdate(fn) {
  OnOwnerNeedsUpdate = fn;
}
var OnRootRemoved;
function setOnRootRemoved(fn) {
  OnRootRemoved = fn;
}
function createTopRoot(owner) {
  const rootId = getSdtId(
    owner,
    "owner"
    /* Owner */
  );
  RootMap.set(rootId, owner);
  OnOwnerNeedsUpdate == null ? void 0 : OnOwnerNeedsUpdate(owner, rootId);
}
function cleanupRoot(root) {
  const rootId = getSdtId(
    root,
    "owner"
    /* Owner */
  );
  root.isDisposed = true;
  changeRootAttachment(root, null);
  const wasTarcked = RootMap.delete(rootId);
  if (wasTarcked)
    OnRootRemoved == null ? void 0 : OnRootRemoved(rootId);
}
function changeRootAttachment(root, newParent) {
  let topRoot;
  if (root.sdtAttached) {
    root.sdtAttached.sdtSubRoots.splice(root.sdtAttached.sdtSubRoots.indexOf(root), 1);
    topRoot = getTopRoot(root.sdtAttached);
    if (topRoot)
      OnOwnerNeedsUpdate == null ? void 0 : OnOwnerNeedsUpdate(root.sdtAttached, getSdtId(
        topRoot,
        "owner"
        /* Owner */
      ));
  }
  if (newParent) {
    root.sdtAttached = newParent;
    if (newParent.sdtSubRoots)
      newParent.sdtSubRoots.push(root);
    else
      newParent.sdtSubRoots = [root];
    if (topRoot === void 0)
      topRoot = getTopRoot(newParent);
    if (topRoot)
      OnOwnerNeedsUpdate == null ? void 0 : OnOwnerNeedsUpdate(newParent, getSdtId(
        topRoot,
        "owner"
        /* Owner */
      ));
  } else {
    delete root.sdtAttached;
  }
}
function attachDebugger(_owner = getOwner2()) {
  let owner = _owner;
  if (!owner)
    return warn("reatachOwner helper should be called synchronously in a reactive owner.");
  const roots = [];
  let isFirstTopLevel = true;
  while (owner) {
    if (isSolidRoot(owner)) {
      if (owner.isInternal || owner.isDisposed)
        return;
      if (RootMap.has(getSdtId(
        owner,
        "owner"
        /* Owner */
      ))) {
        isFirstTopLevel = false;
        break;
      }
      roots.push(owner);
    }
    owner = owner.owner;
  }
  for (let i = roots.length - 1; i >= 0; i--) {
    const root = roots[i];
    root.sdtType = "root";
    onOwnerCleanup(root, () => cleanupRoot(root), true);
    const isTopLevel = isFirstTopLevel && i === 0;
    if (isTopLevel) {
      createTopRoot(root);
      return;
    }
    let parent = findClosestAliveParent(root);
    if (!parent.owner)
      return warn("Parent owner is missing.");
    changeRootAttachment(root, parent.owner);
    const onParentCleanup2 = () => {
      const newParent = findClosestAliveParent(root);
      changeRootAttachment(root, newParent.owner);
      if (newParent.owner) {
        parent = newParent;
        onOwnerCleanup(parent.root, onParentCleanup2);
      } else {
        removeOwnCleanup();
        createTopRoot(root);
      }
    };
    const removeParentCleanup = onOwnerCleanup(parent.root, onParentCleanup2);
    const removeOwnCleanup = onOwnerCleanup(root, removeParentCleanup);
  }
}
var AutoattachEnabled = false;
var InternalRootCount = 0;
function enableRootsAutoattach() {
  if (AutoattachEnabled)
    return;
  AutoattachEnabled = true;
  const autoattach = (root) => {
    if (InternalRootCount)
      return;
    attachDebugger(root);
  };
  if (typeof window._$afterCreateRoot === "function") {
    const old = window._$afterCreateRoot;
    window._$afterCreateRoot = (root) => {
      old(root);
      autoattach(root);
    };
  } else
    window._$afterCreateRoot = autoattach;
}
var createInternalRoot = (fn, detachedOwner) => {
  InternalRootCount++;
  const r = createRoot((dispose) => {
    getOwner2().isInternal = true;
    return fn(dispose);
  }, detachedOwner);
  InternalRootCount--;
  return r;
};
function getTopRoot(owner) {
  let root = null;
  do {
    if (isSolidRoot(owner) && !owner.isInternal && !owner.isDisposed)
      root = owner;
    owner = owner.owner;
  } while (owner);
  return root;
}
function findClosestAliveParent(owner) {
  let disposed = null;
  let closestAliveRoot = null;
  let current = owner;
  while (current.owner && !closestAliveRoot) {
    current = current.owner;
    if (isSolidRoot(current)) {
      if (current.isDisposed)
        disposed = current;
      else
        closestAliveRoot = current;
    }
  }
  if (!closestAliveRoot)
    return { owner: null, root: null };
  return { owner: (disposed ?? owner).owner, root: closestAliveRoot };
}
var _tmpl$ = template(`<style>
.element-overlay {
  position: fixed;
  z-index: 9999;
  top: 0;
  left: 0;
  pointer-events: none;
  transition-duration: 100ms;
  transition-property: transform, width, height;
  --color: 14 116 144;
}
.border {
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border: 2px solid rgb(var(--color) / 0.8);
  background-color: rgb(var(--color) / 0.3);
  border-radius: 0.25rem;
}
.name-container {
  position: absolute;
  z-index: 10000;
  left: 0;
  right: 0;
  display: flex;
  justify-content: center;
  color: white;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
  font-size: 0.875rem;
  line-height: 1rem;
}
.name-container.bottom {
  top: 100%;
}
.name-container.top {
  bottom: 100%;
}
.name-animated-container {
  position: relative;
  margin: 0.5rem auto;
  padding: 0.25rem 0.5rem;
}
.name-background {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgb(var(--color) / 0.8);
  border-radius: 0.25rem;
}
.name-text {
  position: absolute;
}
.name-text span {
  color: #a5f3fc;
}
.name-invisible {
  visibility: hidden;
}
</style>`, 2);
var _tmpl$2 = template(`<div><div class="name-animated-container"><div class="name-background"></div><div class="name-text">: <span></span></div><div class="name-invisible">: </div></div></div>`, 12);
var _tmpl$3 = template(`<div class="element-overlay"><div class="border"></div></div>`, 4);
function attachElementOverlay(selected) {
  return createComponent(Portal, {
    useShadow: true,
    get children() {
      return createComponent(Index, {
        get each() {
          return selected();
        },
        children: (component) => {
          createElementCursor(() => component().element, "pointer");
          const bounds = createElementBounds(() => component().element);
          return createComponent(ElementOverlay, mergeProps(bounds, {
            get tag() {
              return component().element.localName;
            },
            get name() {
              return component().name;
            }
          }));
        }
      });
    }
  });
}
var ElementOverlay = (props) => {
  const left = createMemo((prev) => props.left === null ? prev : props.left, 0);
  const top = createMemo((prev) => props.top === null ? prev : props.top, 0);
  const width = createMemo((prev) => props.width === null ? prev : props.width, 0);
  const height = createMemo((prev) => props.height === null ? prev : props.height, 0);
  const transform = createMemo(() => `translate(${Math.round(left())}px, ${Math.round(top())}px)`);
  const placeOnTop = createMemo(() => top() > window.innerHeight / 2);
  return [_tmpl$.cloneNode(true), (() => {
    const _el$2 = _tmpl$3.cloneNode(true);
    _el$2.firstChild;
    insert(_el$2, createComponent(Show, {
      get when() {
        return !!props.name;
      },
      get children() {
        const _el$4 = _tmpl$2.cloneNode(true), _el$5 = _el$4.firstChild, _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling, _el$10 = _el$7.nextSibling, _el$11 = _el$10.firstChild;
        insert(_el$7, () => props.name, _el$8);
        insert(_el$9, () => props.tag);
        insert(_el$10, () => props.name, _el$11);
        insert(_el$10, () => props.tag, null);
        createRenderEffect(() => className(_el$4, `name-container ${placeOnTop() ? "top" : "bottom"}`));
        return _el$4;
      }
    }), null);
    createRenderEffect((_p$) => {
      const _v$ = transform(), _v$2 = width() + "px", _v$3 = height() + "px";
      _v$ !== _p$._v$ && _el$2.style.setProperty("transform", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && _el$2.style.setProperty("width", _p$._v$2 = _v$2);
      _v$3 !== _p$._v$3 && _el$2.style.setProperty("height", _p$._v$3 = _v$3);
      return _p$;
    }, {
      _v$: void 0,
      _v$2: void 0,
      _v$3: void 0
    });
    return _el$2;
  })()];
};
var LOC_ATTR_REGEX_WIN = /^((?:\\?[^\s][^/\\:\"\?\*<>\|]+)+):([0-9]+):([0-9]+)$/;
var LOC_ATTR_REGEX_UNIX = /^((?:(?:\.\/|\.\.\/|\/)?(?:\.?\w+\/)*)(?:\.?\w+\.?\w+)):([0-9]+):([0-9]+)$/;
var LOC_ATTR_REGEX = isWindows ? LOC_ATTR_REGEX_WIN : LOC_ATTR_REGEX_UNIX;
function getLocationAttr(element) {
  const attr = element.getAttribute(LOCATION_ATTRIBUTE_NAME);
  if (!attr || !LOC_ATTR_REGEX.test(attr))
    return;
  return attr;
}
var targetIDEMap = {
  vscode: ({ projectPath, filePath, line, column }) => `vscode://file/${projectPath}/${filePath}:${line}:${column}`,
  "vscode-insiders": ({ projectPath, filePath, line, column }) => `vscode-insiders://file/${projectPath}/${filePath}:${line}:${column}`,
  atom: ({ projectPath, filePath, line, column }) => `atom://core/open/file?filename=${projectPath}/${filePath}&line=${line}&column=${column}`,
  webstorm: ({ projectPath, filePath, line, column }) => `webstorm://open?file=${projectPath}/${filePath}&line=${line}&column=${column}`
};
function getTargetURL(target, data) {
  if (typeof target === "function")
    return target(data);
  return targetIDEMap[target](data);
}
function getSourceCodeData(location, element) {
  const projectPath = window[WINDOW_PROJECTPATH_PROPERTY];
  if (!projectPath)
    return;
  const match = location.match(LOC_ATTR_REGEX);
  if (!match)
    return;
  const [, filePath, line, column] = match;
  if (!filePath || !line || !column)
    return;
  return { filePath, line: +line, column: +column, projectPath, element };
}
function openSourceCode(target, data) {
  const url = getTargetURL(target, data);
  if (typeof url === "string")
    window.open(url, "_blank");
}
function markComponentLoc(location) {
  const owner = getOwner2();
  if (!owner)
    return;
  const type = getOwnerType(owner);
  if (type === "component")
    owner.location = location;
  else if (type === "refresh")
    owner.owner.location = location;
}
function createLocator(props) {
  const [enabledByPressingSignal, setEnabledByPressingSignal] = createSignal(() => false);
  props.setLocatorEnabledSignal(createMemo(() => enabledByPressingSignal()()));
  props.listenToDebuggerEenable((enabled) => {
    if (!enabled)
      setDevtoolsTarget(null);
  });
  const [hoverTarget, setHoverTarget] = createSignal(null);
  const [devtoolsTarget, setDevtoolsTarget] = createSignal(null);
  const [highlightedComponents, setHighlightedComponents] = createSignal([]);
  const calcHighlightedComponents = (target) => {
    if (!target)
      return [];
    if ("type" in target && target.type === "element") {
      const element = getObjectById(
        target.id,
        "element"
        /* Element */
      );
      if (!(element instanceof HTMLElement))
        return [];
      target = element;
    }
    if (target instanceof HTMLElement) {
      const comp2 = findComponent(target);
      if (!comp2)
        return [];
      return [
        {
          location: getLocationAttr(target),
          element: target,
          id: comp2.id,
          name: comp2.name
        }
      ];
    }
    const comp = getComponent(target.id);
    if (!comp)
      return [];
    return comp.elements.map((element) => ({
      element,
      id: comp.id,
      name: comp.name
    }));
  };
  createEffect(
    defer2(
      () => hoverTarget() ?? devtoolsTarget(),
      scheduleIdle((target) => setHighlightedComponents(() => calcHighlightedComponents(target)))
    )
  );
  setTimeout(() => {
    createInternalRoot(() => attachElementOverlay(highlightedComponents));
  }, 1e3);
  createEffect((prev) => {
    const target = hoverTarget();
    const comp = target && findComponent(target);
    if (prev)
      props.emit("HoveredComponent", { nodeId: prev, state: false });
    if (comp) {
      const { id } = comp;
      props.emit("HoveredComponent", { nodeId: id, state: true });
      return id;
    }
  });
  let targetIDE;
  createEffect(() => {
    if (!props.locatorEnabled())
      return;
    makeHoverElementListener((el) => setHoverTarget(el));
    onCleanup(() => setHoverTarget(null));
    makeEventListener(
      window,
      "click",
      (e) => {
        const { target } = e;
        if (!(target instanceof HTMLElement))
          return;
        const highlighted = highlightedComponents();
        const comp = highlighted.find(({ element }) => target.contains(element)) ?? highlighted[0];
        if (!comp)
          return;
        const sourceCodeData = comp.location && getSourceCodeData(comp.location, comp.element);
        props.onComponentClick(comp.id, () => {
          if (!targetIDE || !sourceCodeData)
            return;
          e.preventDefault();
          e.stopPropagation();
          openSourceCode(targetIDE, sourceCodeData);
        });
      },
      true
    );
  });
  let locatorUsed = false;
  const owner = getOwner();
  function useLocator2(options) {
    runWithOwner(owner, () => {
      enableRootsAutoattach();
      if (locatorUsed)
        return warn("useLocator can be called only once.");
      locatorUsed = true;
      if (options.targetIDE)
        targetIDE = options.targetIDE;
      if (options.key !== false) {
        const isHoldingKey = createKeyHold(options.key ?? "Alt", { preventDefault: true });
        setEnabledByPressingSignal(() => isHoldingKey);
      }
    });
  }
  function openElementSourceCode(location, element) {
    if (!targetIDE)
      return warn("Please set `targetIDE` it in useLocator options.");
    const sourceCodeData = getSourceCodeData(location, element);
    sourceCodeData && openSourceCode(targetIDE, sourceCodeData);
  }
  return {
    useLocator: useLocator2,
    setDevtoolsHighlightTarget: (target) => void setDevtoolsTarget(target),
    openElementSourceCode
  };
}
var GraphUpdateListeners = /* @__PURE__ */ new Set();
{
  const runListeners = () => GraphUpdateListeners.forEach((f) => f());
  if (typeof window._$afterUpdate === "function") {
    GraphUpdateListeners.add(window._$afterUpdate);
  }
  window._$afterUpdate = runListeners;
}
function makeSolidUpdateListener(onUpdate) {
  GraphUpdateListeners.add(onUpdate);
  return tryOnCleanup3(() => {
    GraphUpdateListeners.delete(onUpdate);
  });
}
function interceptComputationRerun(owner, onRun) {
  const _fn = owner.fn;
  let v;
  let prev;
  const fn = () => v = _fn(prev);
  owner.fn = !!owner.fn.length ? (p) => {
    onRun(fn, prev = p);
    return v;
  } : () => {
    onRun(fn, void 0);
    return v;
  };
}
var ComputationUpdateListeners = /* @__PURE__ */ new WeakMap();
function observeComputationUpdate(owner, onRun, symbol = Symbol()) {
  let map = ComputationUpdateListeners.get(owner);
  if (!map)
    ComputationUpdateListeners.set(owner, map = {});
  map[symbol] = onRun;
  interceptComputationRerun(owner, (fn) => {
    fn();
    for (const sym of Object.getOwnPropertySymbols(map))
      map[sym]();
  });
}
function removeComputationUpdateObserver(owner, symbol) {
  const map = ComputationUpdateListeners.get(owner);
  if (map)
    delete map[symbol];
}
function observeValueUpdate(node, onUpdate, symbol) {
  if (node.onValueUpdate) {
    node.onValueUpdate[symbol] = onUpdate;
    return;
  }
  const map = node.onValueUpdate = { [symbol]: onUpdate };
  let value = node.value;
  Object.defineProperty(node, "value", {
    get: () => value,
    set: (newValue) => {
      for (const sym of Object.getOwnPropertySymbols(map))
        map[sym](newValue, value);
      value = newValue;
    }
  });
}
function removeValueUpdateObserver(node, symbol) {
  if (node.onValueUpdate)
    delete node.onValueUpdate[symbol];
}
var $DGRAPH = Symbol("dependency-graph");
var Graph;
var VisitedSources;
var VisitedObservers;
var DepthMap;
var OnNodeUpdate;
function observeNodeUpdate(node, handler) {
  if (isSolidOwner(node))
    observeComputationUpdate(node, handler, $DGRAPH);
  else
    observeValueUpdate(node, handler, $DGRAPH);
}
function unobserveNodeUpdate(node) {
  if (isSolidOwner(node))
    removeComputationUpdateObserver(node, $DGRAPH);
  else
    removeValueUpdateObserver(node, $DGRAPH);
}
function addNodeToGraph(node) {
  const isOwner = isSolidOwner(node);
  const id = getSdtId(
    node,
    isOwner ? "owner" : "signal"
    /* Signal */
  );
  if (Graph[id])
    return;
  const onNodeUpdate = OnNodeUpdate;
  observeNodeUpdate(node, () => onNodeUpdate(id));
  Graph[id] = {
    name: getNodeName(node),
    type: getNodeType(node),
    depth: lookupDepth(node),
    sources: "sources" in node && node.sources ? node.sources.map((n2) => getSdtId(
      n2,
      isSolidOwner(n2) ? "owner" : "signal"
      /* Signal */
    )) : void 0,
    observers: "observers" in node && node.observers ? node.observers.map((n2) => getSdtId(
      n2,
      "owner"
      /* Owner */
    )) : void 0,
    graph: !isOwner && node.graph ? getSdtId(
      node.graph,
      "owner"
      /* Owner */
    ) : void 0
  };
}
function visitSources(node) {
  let n2 = 0;
  if ("sources" in node && node.sources) {
    for (const source of node.sources) {
      const isOwner = isSolidOwner(source);
      if (isOwner && getOwnerType(source) === "refresh")
        continue;
      n2++;
      if (VisitedSources.has(source))
        continue;
      VisitedSources.add(source);
      if (isOwner && visitSources(source) === 0) {
        n2--;
        continue;
      }
      addNodeToGraph(source);
    }
  }
  return n2;
}
function visitObservers(node) {
  if ("observers" in node && node.observers) {
    for (const observer of node.observers) {
      if (VisitedObservers.has(observer) || getOwnerType(observer) === "refresh") {
        continue;
      }
      VisitedObservers.add(observer);
      addNodeToGraph(observer);
      visitObservers(observer);
    }
  }
}
function lookupDepth(node) {
  const id = getSdtId(
    node,
    isSolidOwner(node) ? "owner" : "signal"
    /* Signal */
  );
  if (id in DepthMap)
    return DepthMap[id];
  let owner;
  if (!("owned" in node))
    owner = node.graph;
  else if (!("fn" in node) && !node.owner)
    return 0;
  else
    owner = node.owner;
  return DepthMap[id] = owner ? lookupDepth(owner) + 1 : 0;
}
function collectDependencyGraph(node, config) {
  const graph = Graph = {};
  const visitedSources = VisitedSources = /* @__PURE__ */ new Set();
  const visitedObservers = VisitedObservers = /* @__PURE__ */ new Set();
  DepthMap = {};
  OnNodeUpdate = config.onNodeUpdate;
  addNodeToGraph(node);
  visitSources(node);
  visitObservers(node);
  const clearListeners = () => {
    visitedSources.forEach(unobserveNodeUpdate);
    visitedObservers.forEach(unobserveNodeUpdate);
    unobserveNodeUpdate(node);
  };
  Graph = VisitedObservers = VisitedSources = DepthMap = OnNodeUpdate = void 0;
  return { graph, clearListeners };
}
function createDependencyGraph(props) {
  let clearListeners = null;
  const onNodeUpdate = (id) => {
    queueMicrotask(() => {
      if (!props.enabled())
        return;
      props.onNodeUpdate(id);
      triggerInspect();
    });
  };
  function inspectDGraph() {
    clearListeners == null ? void 0 : clearListeners();
    const state = props.inspectedState();
    let inspectedNode = null;
    let isSignal = false;
    if (state.signalId) {
      inspectedNode = getObjectById(
        state.signalId,
        "signal"
        /* Signal */
      );
      isSignal = true;
    } else if (state.ownerId) {
      inspectedNode = getObjectById(
        state.ownerId,
        "owner"
        /* Owner */
      );
    }
    if (!props.enabled() || !inspectedNode || !isSignal && (!isSolidComputation(inspectedNode) || isSolidComponent(inspectedNode))) {
      clearListeners = null;
      props.emit("DgraphUpdate", null);
      return;
    }
    const dgraph = collectDependencyGraph(inspectedNode, {
      onNodeUpdate
    });
    clearListeners = dgraph.clearListeners;
    props.emit("DgraphUpdate", dgraph.graph);
  }
  const triggerInspect = throttle(inspectDGraph, 200);
  props.listenToInspectedStateChange(() => {
    inspectDGraph();
  });
  props.listenToViewChange(() => {
    inspectDGraph();
  });
  createEffect(() => {
    props.enabled();
    inspectDGraph();
  });
}
var Deep;
var List;
var Seen;
var InStore;
var HandleStore;
var IgnoreNextSeen;
var encodeNonObject = (value) => {
  switch (typeof value) {
    case "number":
      if (value === Infinity)
        return ["number", INFINITY];
      if (value === -Infinity)
        return ["number", NEGATIVE_INFINITY];
      if (isNaN(value))
        return ["number", NAN];
      return ["number", value];
    case "boolean":
      return ["boolean", value];
    case "string":
      return ["string", value];
    case "symbol":
      return ["symbol", value.description || ""];
    case "function":
      return ["function", value.name];
    case "object":
      return ["null", null];
    default:
      return ["null", UNDEFINED];
  }
};
function encode(value) {
  const ignoreNextStore = IgnoreNextSeen;
  if (ignoreNextStore)
    IgnoreNextSeen = false;
  else {
    const seen = Seen.get(value);
    if (seen !== void 0)
      return seen;
  }
  if (!value || typeof value !== "object") {
    const index2 = List.push(encodeNonObject(value)) - 1;
    Seen.set(value, index2);
    return index2;
  }
  const encoded = [];
  const index = List.push(encoded) - 1;
  ignoreNextStore || Seen.set(value, index);
  if (value instanceof Element) {
    encoded[0] = "element";
    encoded[1] = `${getSdtId(
      value,
      "element"
      /* Element */
    )}:${value.localName}`;
  } else if (!ignoreNextStore && isStoreNode(value)) {
    const node = unwrap(value);
    if (node !== value)
      Seen.set(node, index);
    const id = getSdtId(
      node,
      "store-node"
      /* StoreNode */
    );
    !InStore && HandleStore && HandleStore(node, id);
    const wasInStore = InStore;
    InStore = IgnoreNextSeen = true;
    encoded[0] = "store";
    encoded[1] = `${id}:${encode(node)}`;
    InStore = wasInStore;
  } else if (Array.isArray(value)) {
    encoded[0] = "array";
    encoded[1] = Deep ? value.map(encode) : value.length;
  } else {
    const name = Object.prototype.toString.call(value).slice(8, -1);
    if (name === "Object") {
      encoded[0] = "object";
      if (Deep) {
        const data = encoded[1] = {};
        for (const [key, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(value))) {
          data[key] = descriptor.get ? -1 : encode(descriptor.value);
        }
      } else {
        encoded[1] = Object.keys(value).length;
      }
    } else {
      encoded[0] = "instance";
      encoded[1] = name;
    }
  }
  return index;
}
function encodeValue(value, deep, handleStore, inStore = false) {
  Deep = deep;
  List = [];
  Seen = /* @__PURE__ */ new Map();
  InStore = inStore;
  HandleStore = handleStore;
  encode(value);
  const result = List;
  Deep = List = Seen = HandleStore = InStore = void 0;
  return result;
}
var ValueNode = class {
  constructor(getValue) {
    __publicField(this, "trackedStores", []);
    __publicField(this, "selected", false);
    this.getValue = getValue;
  }
  addStoreObserver(unsub) {
    this.trackedStores.push(unsub);
  }
  unsubscribe() {
    for (const unsub of this.trackedStores)
      unsub();
    this.trackedStores = [];
  }
  reset() {
    this.unsubscribe();
    this.selected = false;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(selected) {
    this.selected = selected;
    if (!selected)
      this.unsubscribe();
  }
};
var ValueNodeMap = class {
  constructor() {
    __publicField(this, "record", {});
  }
  get(id) {
    return this.record[id];
  }
  add(id, getValue) {
    this.record[id] = new ValueNode(getValue);
  }
  reset() {
    for (const signal of Object.values(this.record))
      signal.reset();
  }
};
var $NOT_SET = Symbol("not-set");
var ObservedProps = class {
  constructor(props) {
    __publicField(this, "onPropStateChange");
    __publicField(this, "onValueUpdate");
    __publicField(this, "observedGetters", {});
    this.props = props;
  }
  observe(onPropStateChange, onValueUpdate) {
    this.onPropStateChange = onPropStateChange;
    this.onValueUpdate = onValueUpdate;
  }
  unobserve() {
    this.onPropStateChange = void 0;
    this.onValueUpdate = void 0;
  }
  observeProp(key, id, get) {
    if (this.observedGetters[key]) {
      const o2 = this.observedGetters[key];
      return { getValue: () => o2.v, isStale: o2.n === 0 };
    }
    const self = this;
    const o = this.observedGetters[key] = {
      v: $NOT_SET,
      n: 0
    };
    Object.defineProperty(this.props, key, {
      get() {
        var _a2, _b;
        const value = get();
        if (getListener()) {
          onCleanup(() => {
            var _a3;
            return --o.n === 0 && ((_a3 = self.onPropStateChange) == null ? void 0 : _a3.call(self, key, "stale"));
          });
        }
        ++o.n === 1 && ((_a2 = self.onPropStateChange) == null ? void 0 : _a2.call(self, key, "live"));
        if (value !== o.v)
          (_b = self.onValueUpdate) == null ? void 0 : _b.call(self, id);
        return o.v = value;
      },
      enumerable: true
    });
    return { getValue: () => o.v, isStale: true };
  }
};
var compareProxyPropKeys = (oldKeys, newKeys) => {
  const added = new Set(newKeys);
  const removed = [];
  let changed = false;
  for (const key of oldKeys) {
    if (added.has(key))
      added.delete(key);
    else {
      changed = true;
      removed.push(key);
    }
  }
  if (!changed && !added.size)
    return null;
  return { added: Array.from(added), removed };
};
function clearOwnerObservers(owner, observedPropsMap) {
  var _a2;
  if (isSolidComputation(owner)) {
    removeValueUpdateObserver(owner, $INSPECTOR);
    if (isSolidComponent(owner)) {
      (_a2 = observedPropsMap.get(owner.props)) == null ? void 0 : _a2.unobserve();
    }
  }
  if (owner.sourceMap) {
    for (const node of Object.values(owner.sourceMap))
      removeValueUpdateObserver(node, $INSPECTOR);
  }
  if (owner.owned) {
    for (const node of owner.owned)
      removeValueUpdateObserver(node, $INSPECTOR);
  }
}
var ValueMap;
var OnValueUpdate;
var OnPropStateChange;
var PropsMap;
var $INSPECTOR = Symbol("inspector");
function mapSourceValue(node, handler) {
  const { value } = node;
  const isStore = isSolidStore(node);
  const id = getSdtId(
    node,
    isStore ? "store" : isSolidOwner(node) ? "owner" : "signal"
    /* Signal */
  );
  let name;
  ValueMap.add(`${"signal"}:${id}`, () => node.value);
  if (isStore) {
    name = getDisplayName(getStoreNodeName(value));
  } else {
    name = getNodeName(node);
    observeValueUpdate(node, (v) => handler(id, v), $INSPECTOR);
  }
  return {
    type: getNodeType(node),
    name,
    id,
    value: encodeValue(value, false)
  };
}
function mapProps(props) {
  const isProxy = !!props[$PROXY];
  const record = {};
  let checkProxyProps;
  if (isProxy) {
    let propsKeys = Object.keys(props);
    for (const key of propsKeys)
      record[key] = { getter: "stale", value: null };
    checkProxyProps = () => {
      const _oldKeys = propsKeys;
      return compareProxyPropKeys(_oldKeys, propsKeys = Object.keys(props));
    };
  } else {
    let observed = PropsMap.get(props);
    if (!observed)
      PropsMap.set(props, observed = new ObservedProps(props));
    observed.observe(OnPropStateChange, OnValueUpdate);
    for (const [key, desc] of Object.entries(Object.getOwnPropertyDescriptors(props))) {
      const id = `prop:${key}`;
      if (desc.get) {
        const { getValue, isStale } = observed.observeProp(key, id, desc.get);
        ValueMap.add(id, getValue);
        const lastValue = getValue();
        record[key] = {
          getter: isStale ? "stale" : "live",
          value: lastValue !== $NOT_SET ? encodeValue(getValue(), false) : null
        };
      } else {
        record[key] = {
          getter: false,
          value: encodeValue(desc.value, false)
        };
        if (Array.isArray(desc.value) || isRecord(desc.value))
          ValueMap.add(id, () => desc.value);
      }
    }
  }
  return { props: { proxy: isProxy, record }, checkProxyProps };
}
var collectOwnerDetails = untrackedCallback(function(owner, config) {
  const { onValueUpdate } = config;
  ValueMap = new ValueNodeMap();
  OnValueUpdate = onValueUpdate;
  OnPropStateChange = config.onPropStateChange;
  PropsMap = config.observedPropsMap;
  const id = getSdtId(
    owner,
    "owner"
    /* Owner */
  );
  const type = markOwnerType(owner);
  const name = markOwnerName(owner);
  let { sourceMap, owned } = owner;
  let getValue = () => owner.value;
  const details = { id, name, type };
  if (type === "context") {
    sourceMap = void 0;
    owned = null;
    const symbols = Object.getOwnPropertySymbols(owner.context);
    if (symbols.length !== 1) {
      throw new Error("Context field has more than one symbol. This is not expected.");
    } else {
      const contextValue = owner.context[symbols[0]];
      getValue = () => contextValue;
    }
  }
  let checkProxyProps;
  if (isSolidComputation(owner)) {
    if (isSolidComponent(owner)) {
      const refresh = getComponentRefreshNode(owner);
      if (refresh) {
        sourceMap = refresh.sourceMap;
        owned = refresh.owned;
        getValue = () => refresh.value;
      }
      ({ checkProxyProps, props: details.props } = mapProps(owner.props));
      if (owner.location)
        details.location = owner.location;
    } else {
      observeValueUpdate(owner, () => onValueUpdate(
        "value"
        /* Value */
      ), $INSPECTOR);
    }
    details.value = encodeValue(getValue(), false);
  }
  const onSignalUpdate = (signalId) => onValueUpdate(`${"signal"}:${signalId}`);
  if (sourceMap) {
    const signalNodes = Object.values(sourceMap);
    details.signals = Array(signalNodes.length);
    for (let i = 0; i < signalNodes.length; i++) {
      details.signals[i] = mapSourceValue(signalNodes[i], onSignalUpdate);
    }
  } else
    details.signals = [];
  if (owned) {
    for (const node of owned) {
      isSolidMemo(node) && details.signals.push(mapSourceValue(node, onSignalUpdate));
    }
  }
  ValueMap.add("value", getValue);
  const result = {
    details,
    valueMap: ValueMap,
    checkProxyProps
  };
  ValueMap = OnValueUpdate = OnPropStateChange = PropsMap = void 0;
  return result;
});
var DEV3 = DEV2;
var Nodes = /* @__PURE__ */ new WeakMap();
var OnNodeUpdate3 = null;
function setOnStoreNodeUpdate(fn) {
  OnNodeUpdate3 = fn;
}
globalThis._$onStoreNodeUpdate = (node, property, value, prev) => untrack(() => {
  if (!OnNodeUpdate3 || !Nodes.has(node) || typeof property === "symbol")
    return;
  property = property.toString();
  const storeProperty = `${getSdtId(
    node,
    "store-node"
    /* StoreNode */
  )}:${property}`;
  if (property === "length" && typeof value === "number" && Array.isArray(node)) {
    return OnNodeUpdate3(storeProperty, value);
  }
  DEV3.isWrappable(prev) && untrackStore(prev, storeProperty);
  if (value === void 0) {
    OnNodeUpdate3(storeProperty, void 0);
  } else {
    OnNodeUpdate3(storeProperty, { value });
    DEV3.isWrappable(value) && trackStore(value, storeProperty);
  }
});
function observeStoreNode(rootNode) {
  rootNode = unwrap(rootNode);
  const symbol = Symbol("inspect-store");
  return untrack(() => {
    trackStore(rootNode, symbol);
    return () => untrackStore(rootNode, symbol);
  });
}
function trackStore(node, parent) {
  const data = Nodes.get(node);
  if (data)
    data.add(parent);
  else {
    Nodes.set(node, /* @__PURE__ */ new Set([parent]));
    const id = getSdtId(
      node,
      "store-node"
      /* StoreNode */
    );
    forEachStoreProp(node, (key, child) => trackStore(child, `${id}:${key}`));
  }
}
function untrackStore(node, parent) {
  const data = Nodes.get(node);
  if (data && data.delete(parent)) {
    data.size === 0 && Nodes.delete(node);
    const id = getSdtId(
      node,
      "store-node"
      /* StoreNode */
    );
    forEachStoreProp(node, (key, child) => untrackStore(child, `${id}:${key}`));
  }
}
function forEachStoreProp(node, fn) {
  if (Array.isArray(node)) {
    for (let i = 0; i < node.length; i++) {
      const child = node[i];
      DEV3.isWrappable(child) && fn(i.toString(), child);
    }
  } else {
    for (const key in node) {
      const { value, get } = Object.getOwnPropertyDescriptor(node, key);
      if (!get && DEV3.isWrappable(value))
        fn(key, value);
    }
  }
}
function createInspector(props) {
  let lastDetails;
  let inspectedOwner;
  let valueMap = new ValueNodeMap();
  const propsMap = /* @__PURE__ */ new WeakMap();
  let checkProxyProps;
  const { pushPropState, pushValueUpdate, pushInspectToggle, triggerPropsCheck, clearUpdates } = (() => {
    const valueUpdates = /* @__PURE__ */ new Map();
    let storeUpdates = [];
    let checkProps = false;
    let propStates = {};
    const flush = scheduleIdle(() => {
      const batchedUpdates = [];
      for (const [id, toggleChange] of valueUpdates) {
        const node = valueMap.get(id);
        if (!node || !node.getValue)
          continue;
        const selected = node.isSelected();
        const encoded = encodeValue(
          node.getValue(),
          selected,
          selected && ((storeNode) => node.addStoreObserver(observeStoreNode(storeNode)))
        );
        batchedUpdates.push([toggleChange === null ? "value" : "inspectToggle", [id, encoded]]);
      }
      valueUpdates.clear();
      for (const [storeProperty, data] of storeUpdates)
        batchedUpdates.push([
          "store",
          [
            storeProperty,
            typeof data === "object" ? encodeValue(data.value, true, void 0, true) : data ?? null
          ]
        ]);
      storeUpdates = [];
      if (checkProps && checkProxyProps) {
        const keys2 = checkProxyProps();
        if (keys2)
          batchedUpdates.push(["propKeys", keys2]);
        checkProps = false;
      }
      if (Object.keys(propStates).length) {
        batchedUpdates.push(["propState", propStates]);
        propStates = {};
      }
      batchedUpdates.length && props.emit("InspectorUpdate", batchedUpdates);
    });
    const flushPropsCheck = throttle(flush, 200);
    setOnStoreNodeUpdate((...payload) => {
      storeUpdates.push(payload);
      flush();
    });
    return {
      pushValueUpdate(id) {
        valueUpdates.set(id, null);
        flush();
      },
      pushInspectToggle(id, selected) {
        const current = valueUpdates.get(id);
        if (current === selected || current === null)
          return;
        else if (current === !selected)
          valueUpdates.delete(id);
        else
          valueUpdates.set(id, selected);
        flush();
      },
      triggerPropsCheck() {
        checkProps = true;
        flushPropsCheck();
      },
      pushPropState(key, state) {
        propStates[key] = state;
        flush();
      },
      // since the updates are emitten on timeout, we need to make sure that
      // switching off the debugger or unselecting the owner will clear the updates
      clearUpdates() {
        valueUpdates.clear();
        storeUpdates = [];
        checkProps = false;
        flush.clear();
        flushPropsCheck.clear();
      }
    };
  })();
  let clearPrevDisposeListener;
  props.listenToInspectedOwnerChange((id) => {
    const owner = id && getObjectById(
      id,
      "owner"
      /* Owner */
    );
    inspectedOwner && clearOwnerObservers(inspectedOwner, propsMap);
    inspectedOwner = owner;
    valueMap.reset();
    clearUpdates();
    if (owner) {
      const result = collectOwnerDetails(owner, {
        onValueUpdate: pushValueUpdate,
        onPropStateChange: pushPropState,
        observedPropsMap: propsMap
      });
      props.emit("InspectedNodeDetails", result.details);
      valueMap = result.valueMap;
      lastDetails = result.details;
      checkProxyProps = result.checkProxyProps || null;
    } else {
      lastDetails = void 0;
      checkProxyProps = null;
    }
    clearPrevDisposeListener == null ? void 0 : clearPrevDisposeListener();
    clearPrevDisposeListener = owner ? onOwnerDispose(owner, props.resetInspectedNode) : void 0;
  });
  createEffect(() => {
    if (!props.enabled())
      return;
    makeSolidUpdateListener(() => checkProxyProps && triggerPropsCheck());
  });
  return {
    getLastDetails: () => lastDetails,
    toggleValueNode({ id, selected }) {
      const node = valueMap.get(id);
      if (!node)
        return warn("Could not find value node:", id);
      node.setSelected(selected);
      pushInspectToggle(id, selected);
    }
  };
}
var Mode;
var RootId;
var OnComputationUpdate;
var RegisterComponent;
var ElementsMap = /* @__PURE__ */ new Map();
var $WALKER = Symbol("tree-walker");
function observeComputation(owner, attachedData) {
  let isLeaf = !owner.owned || owner.owned.length === 0;
  const boundHandler = OnComputationUpdate.bind(
    void 0,
    RootId,
    attachedData,
    getSdtId(
      attachedData,
      "owner"
      /* Owner */
    )
  );
  const handler = isLeaf && Mode !== "dom" ? () => {
    if (isLeaf && (!owner.owned || owner.owned.length === 0)) {
      boundHandler(false);
    } else {
      isLeaf = false;
      boundHandler(true);
    }
  } : boundHandler.bind(void 0, true);
  observeComputationUpdate(owner, handler, $WALKER);
}
function mapChildren(owner, mappedOwner) {
  const children = [];
  const rawChildren = owner.owned ? owner.owned.slice() : [];
  if (owner.sdtSubRoots)
    rawChildren.push.apply(rawChildren, owner.sdtSubRoots);
  if (Mode === "owners") {
    for (const child of rawChildren) {
      const mappedChild = mapOwner(child, mappedOwner);
      if (mappedChild)
        children.push(mappedChild);
    }
  } else {
    for (const child of rawChildren) {
      const type = markOwnerType(child);
      if (type === "component") {
        const mappedChild = mapOwner(child, mappedOwner);
        if (mappedChild)
          children.push(mappedChild);
      } else {
        if (type !== "context" && type !== "root")
          observeComputation(child, owner);
        children.push.apply(children, mapChildren(child, mappedOwner));
      }
    }
  }
  return children;
}
var MappedOwnerNode;
var AddedToParentElements = false;
function mapElements(els, parentChildren) {
  const r = [];
  els:
    for (const el of els) {
      if (!(el instanceof HTMLElement))
        continue;
      if (parentChildren) {
        const toCheck = [parentChildren];
        let index = 0;
        let elNodes = toCheck[index++];
        while (elNodes) {
          for (let i = 0; i < elNodes.length; i++) {
            const elNode = elNodes[i];
            const elNodeData = ElementsMap.get(elNode);
            if (elNodeData && elNodeData.el === el) {
              if (AddedToParentElements) {
                elNodes.splice(i, 1);
              } else {
                elNodes[i] = MappedOwnerNode;
                AddedToParentElements = true;
              }
              r.push(elNode);
              elNodeData.component = MappedOwnerNode;
              continue els;
            }
            if (elNode.children.length)
              toCheck.push(elNode.children);
          }
          elNodes = toCheck[index++];
        }
      }
      const mappedEl = {
        id: getSdtId(
          el,
          "element"
          /* Element */
        ),
        type: "element",
        name: el.localName,
        children: []
      };
      r.push(mappedEl);
      ElementsMap.set(mappedEl, { el, component: MappedOwnerNode });
      if (el.children.length)
        mappedEl.children = mapElements(el.children, parentChildren);
    }
  return r;
}
function mapOwner(owner, parent, overwriteType) {
  const id = getSdtId(
    owner,
    "owner"
    /* Owner */
  );
  const type = overwriteType ?? markOwnerType(owner);
  const name = type === "component" || type === "memo" || type === "effect" || type === "computation" ? markOwnerName(owner) : void 0;
  const mapped = { id, type };
  if (name)
    mapped.name = name;
  let resolvedElements;
  if (type === "component") {
    let contextNode;
    if (name === "provider" && owner.owned && owner.owned.length === 1 && markOwnerType(contextNode = owner.owned[0]) === "context") {
      return mapOwner(
        contextNode,
        parent,
        "context"
        /* Context */
      );
    }
    RegisterComponent({
      owner,
      id,
      name,
      elements: resolvedElements = resolveElements(owner.value)
    });
    const refresh = getComponentRefreshNode(owner);
    if (refresh) {
      mapped.hmr = true;
      owner = refresh;
    }
  } else if (type !== "context" && type !== "root") {
    observeComputation(owner, owner);
    if (!owner.sources || owner.sources.length === 0)
      mapped.frozen = true;
  }
  const children = [];
  mapped.children = children;
  AddedToParentElements = false;
  MappedOwnerNode = mapped;
  if (Mode === "dom" && (resolvedElements = resolvedElements === void 0 ? resolveElements(owner.value) : resolvedElements)) {
    children.push.apply(
      children,
      mapElements(
        Array.isArray(resolvedElements) ? resolvedElements : [resolvedElements],
        parent == null ? void 0 : parent.children
      )
    );
  }
  const addedToParent = AddedToParentElements;
  children.push.apply(children, mapChildren(owner, mapped));
  return addedToParent ? void 0 : mapped;
}
var walkSolidTree = untrackedCallback(function(owner, config) {
  Mode = config.mode;
  RootId = config.rootId;
  OnComputationUpdate = config.onComputationUpdate;
  RegisterComponent = config.registerComponent;
  const r = mapOwner(owner, null);
  if (Mode === "dom") {
    for (const [elNode, { el, component }] of ElementsMap) {
      RegisterComponent({
        element: el,
        componentId: component.id,
        elementId: elNode.id
      });
    }
    ElementsMap.clear();
  }
  Mode = RootId = OnComputationUpdate = RegisterComponent = void 0;
  return r;
});
function getClosestIncludedOwner(owner, mode) {
  let closest = null;
  let current = owner;
  do {
    if (isDisposed(current))
      closest = current.owner;
    current = current.owner;
  } while (current);
  owner = closest ?? owner;
  if (mode === "owners")
    return owner;
  let root = null;
  do {
    const type = markOwnerType(owner);
    if (type === "component" || type === "context")
      return owner;
    if (type === "root")
      root = owner;
    owner = owner.owner;
  } while (owner);
  return root;
}
function createStructure(props) {
  let treeWalkerMode = DEFAULT_WALKER_MODE;
  const updateQueue = /* @__PURE__ */ new Set();
  const ownerRoots = /* @__PURE__ */ new Map();
  const removedRoots = /* @__PURE__ */ new Set();
  let shouldUpdateAllRoots = false;
  const onComputationUpdate = (rootId, owner, ownerId, changedStructure) => {
    queueMicrotask(() => {
      if (!props.enabled())
        return;
      changedStructure && updateOwner(owner, rootId);
      props.onNodeUpdate(ownerId);
    });
  };
  function forceFlushRootUpdateQueue() {
    if (props.enabled()) {
      const updated = {};
      const partial = !shouldUpdateAllRoots;
      shouldUpdateAllRoots = false;
      const [owners, getRootId] = partial ? [updateQueue, (owner) => ownerRoots.get(owner)] : [getCurrentRoots(), (owner) => getSdtId(
        owner,
        "owner"
        /* Owner */
      )];
      for (const owner of owners) {
        const rootId = getRootId(owner);
        const tree = walkSolidTree(owner, {
          rootId,
          mode: treeWalkerMode,
          onComputationUpdate,
          registerComponent
        });
        const map = updated[rootId];
        if (map)
          map[tree.id] = tree;
        else
          updated[rootId] = { [tree.id]: tree };
      }
      props.onStructureUpdate({ partial, updated, removed: [...removedRoots] });
    }
    updateQueue.clear();
    flushRootUpdateQueue.clear();
    removedRoots.clear();
    ownerRoots.clear();
  }
  const flushRootUpdateQueue = throttle(forceFlushRootUpdateQueue, 250);
  function updateOwner(node, topRootId) {
    updateQueue.add(node);
    ownerRoots.set(node, topRootId);
    flushRootUpdateQueue();
  }
  setOnOwnerNeedsUpdate((node, topRootId) => {
    const closestIncludedOwner = getClosestIncludedOwner(node, treeWalkerMode);
    closestIncludedOwner && updateOwner(closestIncludedOwner, topRootId);
  });
  setOnRootRemoved((rootId) => {
    removedRoots.add(rootId);
    flushRootUpdateQueue();
  });
  props.listenToViewChange((view) => {
    if (view === "structure") {
      updateAllRoots();
    }
  });
  function updateAllRoots() {
    shouldUpdateAllRoots = true;
    flushRootUpdateQueue();
  }
  function forceUpdateAllRoots() {
    shouldUpdateAllRoots = true;
    queueMicrotask(forceFlushRootUpdateQueue);
  }
  function setTreeWalkerMode(mode) {
    treeWalkerMode = mode;
    updateAllRoots();
    clearComponentRegistry();
  }
  return {
    updateAllRoots,
    forceUpdateAllRoots,
    setTreeWalkerMode,
    resetTreeWalkerMode: () => setTreeWalkerMode(DEFAULT_WALKER_MODE),
    getClosestIncludedOwner(owner) {
      return getClosestIncludedOwner(owner, treeWalkerMode);
    }
  };
}
var plugin = createInternalRoot(() => {
  const hub = {
    output: createGlobalEmitter(),
    input: createGlobalEmitter()
  };
  const [modules, toggleModules] = createStaticStore2({
    debugger: false,
    locator: false,
    dgraph: false,
    locatorKeyPressSignal: () => false
  });
  const debuggerEnabled = createMemo(() => modules.debugger || modules.locatorKeyPressSignal());
  const dgraphEnabled = createMemo(() => modules.dgraph && debuggerEnabled());
  const locatorEnabled = createMemo(
    () => (modules.locatorKeyPressSignal() || modules.locator) && debuggerEnabled()
  );
  const debuggerEnabledBus = createEventBus();
  createEffect(() => {
    if (!debuggerEnabled())
      debuggerEnabledBus.emit(false);
  });
  const viewChange = createEventBus();
  function setView(view) {
    batch(() => {
      viewChange.emit(view);
    });
  }
  function toggleModule(data) {
    switch (data.module) {
      case "structure":
        break;
      case "dgraph":
        toggleModules("dgraph", data.enabled);
        break;
      case "locator":
        toggleModules("locator", data.enabled);
        break;
    }
  }
  const INITIAL_INSPECTED_STATE = {
    ownerId: null,
    signalId: null,
    treeWalkerOwnerId: null
  };
  const [inspectedState, setInspectedState] = createSignal(INITIAL_INSPECTED_STATE, { equals: false });
  createEffect(() => {
    const state = inspectedState();
    queueMicrotask(() => hub.output.emit("InspectedState", state));
  });
  function getTreeWalkerOwnerId(ownerId) {
    const owner = ownerId && getObjectById(
      ownerId,
      "owner"
      /* Owner */
    );
    const treeWalkerOwner = owner && structure.getClosestIncludedOwner(owner);
    return treeWalkerOwner ? getSdtId(
      treeWalkerOwner,
      "owner"
      /* Owner */
    ) : null;
  }
  function updateInspectedNode() {
    setInspectedState((p) => ({ ...p, treeWalkerOwnerId: getTreeWalkerOwnerId(p.treeWalkerOwnerId) }));
  }
  function resetInspectedNode() {
    setInspectedState(INITIAL_INSPECTED_STATE);
  }
  function setInspectedNode(data) {
    let { ownerId, signalId } = data ?? { ownerId: null, signalId: null };
    if (ownerId && !getObjectById(
      ownerId,
      "owner"
      /* Owner */
    ))
      ownerId = null;
    if (signalId && !getObjectById(
      signalId,
      "signal"
      /* Signal */
    ))
      signalId = null;
    setInspectedState({
      ownerId,
      signalId,
      treeWalkerOwnerId: getTreeWalkerOwnerId(ownerId)
    });
  }
  createComputed(
    defer2(debuggerEnabled, (enabled) => {
      if (!enabled)
        resetInspectedNode();
    })
  );
  const pushNodeUpdate = createBatchedUpdateEmitter((updates) => {
    hub.output.emit("NodeUpdates", updates);
  });
  const structure = createStructure({
    onStructureUpdate(updates) {
      hub.output.emit("StructureUpdates", updates);
      updateInspectedNode();
    },
    onNodeUpdate: pushNodeUpdate,
    enabled: debuggerEnabled,
    listenToViewChange: viewChange.listen
  });
  const inspector = createInspector({
    emit: hub.output.emit,
    enabled: debuggerEnabled,
    listenToInspectedOwnerChange: (l) => hub.output.on("InspectedState", (s) => l(s.ownerId)),
    resetInspectedNode
  });
  createDependencyGraph({
    emit: hub.output.emit,
    enabled: dgraphEnabled,
    listenToViewChange: viewChange.listen,
    onNodeUpdate: pushNodeUpdate,
    inspectedState,
    listenToInspectedStateChange: (l) => hub.output.on("InspectedState", l)
  });
  const locator = createLocator({
    emit: hub.output.emit,
    listenToDebuggerEenable: debuggerEnabledBus.listen,
    locatorEnabled,
    setLocatorEnabledSignal: (signal) => toggleModules("locatorKeyPressSignal", () => signal),
    onComponentClick(componentId, next) {
      modules.debugger ? hub.output.emit("InspectedComponent", componentId) : next();
    }
  });
  function openInspectedNodeLocation() {
    const details = inspector.getLastDetails();
    (details == null ? void 0 : details.location) && locator.openElementSourceCode(details.location, details.name);
  }
  createEffect(
    defer2(modules.locatorKeyPressSignal, (state) => hub.output.emit("LocatorModeChange", state))
  );
  hub.input.listen((e) => {
    switch (e.name) {
      case "ResetState": {
        resetInspectedNode();
        structure.resetTreeWalkerMode();
        break;
      }
      case "HighlightElementChange":
        return locator.setDevtoolsHighlightTarget(e.details);
      case "InspectNode":
        return setInspectedNode(e.details);
      case "InspectValue":
        return inspector.toggleValueNode(e.details);
      case "OpenLocation":
        return openInspectedNodeLocation();
      case "TreeViewModeChange":
        return structure.setTreeWalkerMode(e.details);
      case "ViewChange":
        return setView(e.details);
      case "ToggleModule":
        return toggleModule(e.details);
    }
  });
  function useDebugger2() {
    return {
      enabled: debuggerEnabled,
      toggleEnabled: (enabled) => void toggleModules("debugger", enabled),
      on: hub.output.on,
      listen: hub.output.listen,
      emit: hub.input.emit
    };
  }
  return {
    useDebugger: useDebugger2,
    useLocator: locator.useLocator
  };
});
var { useDebugger, useLocator } = plugin;
var Debugger = (props) => {
  attachDebugger();
  return props.children;
};

// node_modules/.pnpm/solid-devtools@0.26.0_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.1.4/node_modules/solid-devtools/dist/index.js
startListeningWindowMessages();
var _fromContent = makeMessageListener();
var fromContent = (...args) => onCleanup(_fromContent(...args));
var toContent = makePostMessage();
toContent("ResetPanel");
toContent("ClientConnected", "0.26.0");
var loadedBefore = false;
createInternalRoot(() => {
  const debug = useDebugger();
  fromContent("DevtoolsOpened", () => debug.toggleEnabled(true));
  fromContent("DevtoolsClosed", () => debug.toggleEnabled(false));
  createEffect(() => {
    if (!debug.enabled())
      return;
    if (loadedBefore)
      debug.emit("ResetState");
    else
      loadedBefore = true;
    fromContent((e) => debug.emit(e.name, e.details));
    debug.listen((e) => toContent(e.name, e.details));
  });
});
enableRootsAutoattach();
export {
  Debugger,
  attachDebugger,
  makeSolidUpdateListener,
  markComponentLoc,
  useDebugger,
  useLocator
};
//# sourceMappingURL=solid-devtools.js.map
