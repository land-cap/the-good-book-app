{
  "version": 3,
  "sources": ["../../.pnpm/@zag-js+anatomy@0.1.4/node_modules/@zag-js/anatomy/dist/chunk-JKTBQDTH.mjs", "../../.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-53AIL37A.mjs", "../../.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-ZZ5TA5X3.mjs", "../../.pnpm/@floating-ui+core@1.2.6/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs", "../../.pnpm/@floating-ui+dom@1.2.5/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs", "../../.pnpm/@zag-js+element-rect@0.3.0/node_modules/@zag-js/element-rect/dist/index.mjs", "../../.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-AVEWKGZP.mjs", "../../.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-X5LLREVI.mjs", "../../.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-6B3BV5TE.mjs", "../../.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-V4C4UQPN.mjs", "../../.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-55HRYHCU.mjs", "../../.pnpm/@zag-js+aria-hidden@0.2.2/node_modules/@zag-js/aria-hidden/dist/index.mjs", "../../.pnpm/@zag-js+mutation-observer@0.0.1/node_modules/@zag-js/mutation-observer/dist/chunk-I3WGVGYR.mjs", "../../.pnpm/@zag-js+mutation-observer@0.0.1/node_modules/@zag-js/mutation-observer/dist/chunk-6YRAYXUX.mjs", "../../.pnpm/@zag-js+interact-outside@0.6.0/node_modules/@zag-js/interact-outside/dist/chunk-UQ6OADW7.mjs", "../../.pnpm/@zag-js+tabbable@0.1.1/node_modules/@zag-js/tabbable/dist/index.mjs", "../../.pnpm/@zag-js+interact-outside@0.6.0/node_modules/@zag-js/interact-outside/dist/index.mjs", "../../.pnpm/@zag-js+visually-hidden@0.0.1/node_modules/@zag-js/visually-hidden/dist/index.mjs", "../../.pnpm/@zag-js+live-region@0.2.3/node_modules/@zag-js/live-region/dist/index.mjs", "../../.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-WVULFYY5.mjs"],
  "sourcesContent": ["// src/create-anatomy.ts\nvar createAnatomy = (name, parts = []) => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values);\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\");\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  build: () => [...new Set(parts)].reduce(\n    (prev, part) => Object.assign(prev, {\n      [part]: {\n        selector: [\n          `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n          `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`\n        ].join(\", \"),\n        attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) }\n      }\n    }),\n    {}\n  )\n});\nvar toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, \"$1-$2\").replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[\\s_]+/g, \"-\").toLowerCase();\nvar isEmpty = (v) => v.length === 0;\n\nexport {\n  createAnatomy\n};\n", "// src/combobox.anatomy.ts\nimport { createAnatomy } from \"@zag-js/anatomy\";\nvar anatomy = createAnatomy(\"combobox\").parts(\n  \"root\",\n  \"label\",\n  \"input\",\n  \"positioner\",\n  \"control\",\n  \"trigger\",\n  \"content\",\n  \"clearTrigger\",\n  \"option\",\n  \"optionGroup\"\n);\nvar parts = anatomy.build();\n\nexport {\n  anatomy,\n  parts\n};\n", "// src/combobox.dom.ts\nimport { createScope, nextById, prevById, queryAll } from \"@zag-js/dom-query\";\nimport { first, last } from \"@zag-js/utils\";\nvar dom = createScope({\n  getRootId: (ctx) => ctx.ids?.root ?? `combobox:${ctx.id}`,\n  getLabelId: (ctx) => ctx.ids?.label ?? `combobox:${ctx.id}:label`,\n  getControlId: (ctx) => ctx.ids?.control ?? `combobox:${ctx.id}:control`,\n  getInputId: (ctx) => ctx.ids?.input ?? `combobox:${ctx.id}:input`,\n  getContentId: (ctx) => ctx.ids?.content ?? `combobox:${ctx.id}:listbox`,\n  getPositionerId: (ctx) => `combobox:${ctx.id}:popper`,\n  getTriggerId: (ctx) => ctx.ids?.trigger ?? `combobox:${ctx.id}:toggle-btn`,\n  getClearTriggerId: (ctx) => ctx.ids?.clearTrigger ?? `combobox:${ctx.id}:clear-btn`,\n  getOptionId: (ctx, id, index) => ctx.ids?.option?.(id, index) ?? [`combobox:${ctx.id}:option:${id}`, index].filter((v) => v != null).join(\":\"),\n  getActiveOptionEl: (ctx) => ctx.focusedId ? dom.getById(ctx, ctx.focusedId) : null,\n  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),\n  getInputEl: (ctx) => dom.getById(ctx, dom.getInputId(ctx)),\n  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),\n  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getClearTriggerEl: (ctx) => dom.getById(ctx, dom.getClearTriggerId(ctx)),\n  getElements: (ctx) => queryAll(dom.getContentEl(ctx), \"[role=option]:not([aria-disabled=true])\"),\n  getFocusedOptionEl: (ctx) => {\n    if (!ctx.focusedId)\n      return null;\n    const selector = `[role=option][id=${CSS.escape(ctx.focusedId)}]`;\n    return dom.getContentEl(ctx)?.querySelector(selector);\n  },\n  getFirstEl: (ctx) => first(dom.getElements(ctx)),\n  getLastEl: (ctx) => last(dom.getElements(ctx)),\n  getPrevEl: (ctx, id) => prevById(dom.getElements(ctx), id, ctx.loop),\n  getNextEl: (ctx, id) => nextById(dom.getElements(ctx), id, ctx.loop),\n  isInputFocused: (ctx) => dom.getDoc(ctx).activeElement === dom.getInputEl(ctx),\n  getOptionData: (el) => ({\n    value: el?.getAttribute(\"data-value\") ?? \"\",\n    label: el?.getAttribute(\"data-label\") ?? \"\"\n  }),\n  getOptionCount: (ctx) => {\n    const listbox = dom.getContentEl(ctx);\n    const count = listbox?.querySelector(\"[role=option]\")?.getAttribute(\"aria-setsize\");\n    if (count != null)\n      return parseInt(count);\n    return listbox?.querySelectorAll(\"[role=option]\").length ?? 0;\n  },\n  getMatchingOptionEl: (ctx, value) => {\n    if (!value)\n      return null;\n    const selector = `[role=option][data-value=\"${CSS.escape(value)}\"`;\n    const listbox = dom.getContentEl(ctx);\n    if (!listbox)\n      return null;\n    return listbox.querySelector(selector);\n  },\n  focusInput: (ctx) => {\n    const input = dom.getInputEl(ctx);\n    if (dom.getDoc(ctx).activeElement !== input) {\n      input?.focus();\n    }\n    if (ctx.selectInputOnFocus) {\n      input?.select();\n    }\n  },\n  getClosestSectionLabel(ctx) {\n    if (!ctx.focusedId)\n      return;\n    const group = dom.getActiveOptionEl(ctx)?.closest(\"[data-part=option-group]\");\n    return group?.getAttribute(\"aria-label\");\n  },\n  getValueLabel: (ctx, value) => {\n    const el = dom.getMatchingOptionEl(ctx, value);\n    return dom.getOptionData(el).label;\n  }\n});\n\nexport {\n  dom\n};\n", "function getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = options || {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = options;\n      const {\n        rects\n      } = state;\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getSideObjectFromPadding(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nasync function convertValueToCoords(state, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(state) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(state) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const axis = getMainAxisFromPlacement(placement);\n      const isXAxis = axis === 'x';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isXAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isXAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try to use feature detection here instead.\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => {\n    // Add type check for old browsers.\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\n/**\n * Determines whether or not `.getBoundingClientRect()` is affected by visual\n * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the\n * visual viewport, while in other engines, they are values relative to the\n * layout viewport.\n */\nfunction isClientRectVisualViewportBased() {\n  // TODO: Try to use feature detection here instead. Feature detection for\n  // this can fail in various ways, making the userAgent check the most\n  // reliable:\n  // • Always-visible scrollbar or not\n  // • Width of <html>\n\n  // Is Safari.\n  return /^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // `getParentNode` will never return a `Document` due to the fallback\n    // check, so it's either the <html> or <body> element.\n    return parentNode.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isClientRectVisualViewportBased();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const mutableRect = {\n      ...clippingAncestor\n    };\n    if (isClientRectVisualViewportBased()) {\n      var _win$visualViewport, _win$visualViewport2;\n      const win = getWindow(element);\n      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;\n      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;\n    }\n    rect = mutableRect;\n  }\n  return rectToClientRect(rect);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldIgnoreCurrentNode = computedStyle.position === 'fixed';\n    if (shouldIgnoreCurrentNode) {\n      currentContainingBlockComputedStyle = null;\n    } else {\n      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(ancestor => ancestor !== currentNode);\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n  if (elementResize) {\n    observer = new ResizeObserver(() => {\n      update();\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, getOverflowAncestors, platform };\n", "// src/index.ts\nvar rafId;\nvar observedElements = /* @__PURE__ */ new Map();\nfunction trackElementRect(el, fn, options = {}) {\n  const { scope = \"rect\" } = options;\n  const loop = getLoopFn(scope);\n  const data = observedElements.get(el);\n  if (!data) {\n    observedElements.set(el, {\n      rect: {},\n      callbacks: [fn]\n    });\n    if (observedElements.size === 1) {\n      rafId = requestAnimationFrame(loop);\n    }\n  } else {\n    data.callbacks.push(fn);\n    fn(el.getBoundingClientRect());\n  }\n  return function unobserve() {\n    const data2 = observedElements.get(el);\n    if (!data2)\n      return;\n    const index = data2.callbacks.indexOf(fn);\n    if (index > -1) {\n      data2.callbacks.splice(index, 1);\n    }\n    if (data2.callbacks.length === 0) {\n      observedElements.delete(el);\n      if (observedElements.size === 0) {\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\nfunction getLoopFn(scope) {\n  const isEqual = getEqualityFn(scope);\n  return function loop() {\n    const changedRectsData = [];\n    observedElements.forEach((data, element) => {\n      const newRect = element.getBoundingClientRect();\n      if (!isEqual(data.rect, newRect)) {\n        data.rect = newRect;\n        changedRectsData.push(data);\n      }\n    });\n    changedRectsData.forEach((data) => {\n      data.callbacks.forEach((callback) => callback(data.rect));\n    });\n    rafId = requestAnimationFrame(loop);\n  };\n}\nvar isEqualSize = (a, b) => a.width === b.width && a.height === b.height;\nvar isEqualPosition = (a, b) => a.top === b.top && a.right === b.right && a.bottom === b.bottom && a.left === b.left;\nvar isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);\nfunction getEqualityFn(scope) {\n  if (scope === \"size\")\n    return isEqualSize;\n  if (scope === \"position\")\n    return isEqualPosition;\n  return isEqualRect;\n}\nexport {\n  trackElementRect\n};\n", "// src/auto-update.ts\nimport { getOverflowAncestors } from \"@floating-ui/dom\";\nimport { trackElementRect } from \"@zag-js/element-rect\";\nvar callAll = (...fns) => () => fns.forEach((fn) => fn());\nvar isHTMLElement = (el) => {\n  return typeof el === \"object\" && el !== null && el.nodeType === 1;\n};\nvar addDomEvent = (el, type, fn, options) => {\n  el.addEventListener(type, fn, options);\n  return () => el.removeEventListener(type, fn, options);\n};\nfunction resolveOptions(option) {\n  const bool = typeof option === \"boolean\";\n  return {\n    ancestorResize: bool ? option : option.ancestorResize ?? true,\n    ancestorScroll: bool ? option : option.ancestorScroll ?? true,\n    referenceResize: bool ? option : option.referenceResize ?? true\n  };\n}\nfunction autoUpdate(reference, floating, update, options = false) {\n  const { ancestorScroll, ancestorResize, referenceResize } = resolveOptions(options);\n  const useAncestors = ancestorScroll || ancestorResize;\n  const ancestors = [];\n  if (useAncestors && isHTMLElement(reference)) {\n    ancestors.push(...getOverflowAncestors(reference));\n  }\n  function addResizeListeners() {\n    let cleanups = [trackElementRect(floating, update, { scope: \"size\" })];\n    if (referenceResize && isHTMLElement(reference)) {\n      cleanups.push(trackElementRect(reference, update));\n    }\n    cleanups.push(callAll(...ancestors.map((el) => addDomEvent(el, \"resize\", update))));\n    return () => cleanups.forEach((fn) => fn());\n  }\n  function addScrollListeners() {\n    return callAll(...ancestors.map((el) => addDomEvent(el, \"scroll\", update, { passive: true })));\n  }\n  return callAll(addResizeListeners(), addScrollListeners());\n}\n\nexport {\n  autoUpdate\n};\n", "// src/middleware.ts\nvar toVar = (value) => ({ variable: value, reference: `var(${value})` });\nvar cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\")\n};\nvar getTransformOrigin = (arrow) => ({\n  top: \"bottom center\",\n  \"top-start\": arrow ? `${arrow.x}px bottom` : \"left bottom\",\n  \"top-end\": arrow ? `${arrow.x}px bottom` : \"right bottom\",\n  bottom: \"top center\",\n  \"bottom-start\": arrow ? `${arrow.x}px top` : \"top left\",\n  \"bottom-end\": arrow ? `${arrow.x}px top` : \"top right\",\n  left: \"right center\",\n  \"left-start\": arrow ? `right ${arrow.y}px` : \"right top\",\n  \"left-end\": arrow ? `right ${arrow.y}px` : \"right bottom\",\n  right: \"left center\",\n  \"right-start\": arrow ? `left ${arrow.y}px` : \"left top\",\n  \"right-end\": arrow ? `left ${arrow.y}px` : \"left bottom\"\n});\nvar transformOrigin = {\n  name: \"transformOrigin\",\n  fn({ placement, elements, middlewareData }) {\n    const { arrow } = middlewareData;\n    const transformOrigin2 = getTransformOrigin(arrow)[placement];\n    const { floating } = elements;\n    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin2);\n    return {\n      data: { transformOrigin: transformOrigin2 }\n    };\n  }\n};\nvar shiftArrow = (opts) => ({\n  name: \"shiftArrow\",\n  fn({ placement, middlewareData }) {\n    const { element: arrow } = opts;\n    if (middlewareData.arrow) {\n      const { x, y } = middlewareData.arrow;\n      const dir = placement.split(\"-\")[0];\n      Object.assign(arrow.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`\n      });\n    }\n    return {};\n  }\n});\n\nexport {\n  cssVars,\n  transformOrigin,\n  shiftArrow\n};\n", "import {\n  autoUpdate\n} from \"./chunk-AVEWKGZP.mjs\";\nimport {\n  shiftArrow,\n  transformOrigin\n} from \"./chunk-X5LLREVI.mjs\";\n\n// src/get-placement.ts\nimport { arrow, computePosition, flip, offset, shift, size } from \"@floating-ui/dom\";\nimport { callAll } from \"@zag-js/utils\";\nvar defaultOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  sameWidth: false,\n  overflowPadding: 8\n};\nfunction getPlacement(reference, floating, opts = {}) {\n  if (!floating || !reference)\n    return;\n  const options = Object.assign({}, defaultOptions, opts);\n  const arrowEl = floating.querySelector(\"[data-part=arrow]\");\n  const middleware = [];\n  const boundary = typeof options.boundary === \"function\" ? options.boundary() : options.boundary;\n  if (options.flip) {\n    middleware.push(\n      flip({\n        boundary,\n        padding: options.overflowPadding\n      })\n    );\n  }\n  if (options.gutter || options.offset) {\n    const arrowOffset = arrowEl ? arrowEl.offsetHeight / 2 : 0;\n    const data = options.gutter ? { mainAxis: options.gutter } : options.offset;\n    if (data?.mainAxis != null)\n      data.mainAxis += arrowOffset;\n    middleware.push(offset(data));\n  }\n  middleware.push(\n    shift({\n      boundary,\n      crossAxis: options.overlap,\n      padding: options.overflowPadding\n    })\n  );\n  if (arrowEl) {\n    middleware.push(\n      arrow({ element: arrowEl, padding: 8 }),\n      shiftArrow({ element: arrowEl })\n    );\n  }\n  middleware.push(transformOrigin);\n  middleware.push(\n    size({\n      padding: options.overflowPadding,\n      apply({ rects, availableHeight, availableWidth }) {\n        const referenceWidth = Math.round(rects.reference.width);\n        floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`);\n        floating.style.setProperty(\"--available-width\", `${availableWidth}px`);\n        floating.style.setProperty(\"--available-height\", `${availableHeight}px`);\n        if (options.sameWidth) {\n          Object.assign(floating.style, {\n            width: `${referenceWidth}px`,\n            minWidth: \"unset\"\n          });\n        }\n        if (options.fitViewport) {\n          Object.assign(floating.style, {\n            maxWidth: `${availableWidth}px`,\n            maxHeight: `${availableHeight}px`\n          });\n        }\n      }\n    })\n  );\n  function compute(config = {}) {\n    if (!reference || !floating)\n      return;\n    const { placement, strategy, onComplete } = options;\n    computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy,\n      ...config\n    }).then((data) => {\n      const x = Math.round(data.x);\n      const y = Math.round(data.y);\n      Object.assign(floating.style, {\n        position: data.strategy,\n        top: \"0px\",\n        left: \"0px\",\n        transform: `translate3d(${x}px, ${y}px, 0)`\n      });\n      onComplete?.(data);\n    });\n  }\n  compute();\n  return callAll(\n    options.listeners ? autoUpdate(reference, floating, compute, options.listeners) : void 0,\n    options.onCleanup\n  );\n}\nfunction getBasePlacement(placement) {\n  return placement.split(\"-\")[0];\n}\n\nexport {\n  getPlacement,\n  getBasePlacement\n};\n", "import {\n  cssVars\n} from \"./chunk-X5LLREVI.mjs\";\n\n// src/get-styles.ts\nvar ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\"\n};\nfunction getPlacementStyles(options) {\n  const { placement = \"bottom\" } = options;\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`\n    },\n    arrowTip: {\n      transform: ARROW_FLOATING_STYLE[placement.split(\"-\")[0]],\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\"\n    },\n    floating: {\n      position: \"absolute\",\n      minWidth: \"max-content\",\n      top: \"0px\",\n      left: \"0px\"\n    }\n  };\n}\n\nexport {\n  getPlacementStyles\n};\n", "import {\n  parts\n} from \"./chunk-53AIL37A.mjs\";\nimport {\n  dom\n} from \"./chunk-ZZ5TA5X3.mjs\";\n\n// src/combobox.connect.ts\nimport { getEventKey, getNativeEvent, isLeftClick } from \"@zag-js/dom-event\";\nimport { ariaAttr, dataAttr } from \"@zag-js/dom-query\";\nimport { getPlacementStyles } from \"@zag-js/popper\";\nfunction connect(state, send, normalize) {\n  const translations = state.context.translations;\n  const isDisabled = state.context.disabled;\n  const isInteractive = state.context.isInteractive;\n  const isInvalid = state.context.invalid;\n  const isReadOnly = state.context.readOnly;\n  const isOpen = state.hasTag(\"open\");\n  const isFocused = state.hasTag(\"focused\");\n  const isIdle = state.hasTag(\"idle\");\n  const autofill = isOpen && state.context.navigationData && state.context.autoComplete;\n  const showClearButton = (!isIdle || state.context.isHovering) && !state.context.isInputValueEmpty;\n  const value = autofill ? state.context.navigationData?.label : state.context.inputValue;\n  const popperStyles = getPlacementStyles({\n    placement: state.context.currentPlacement\n  });\n  const api = {\n    /**\n     * Whether the combobox is focused\n     */\n    isFocused,\n    /**\n     * Whether the combobox content or listbox is open\n     */\n    isOpen,\n    /**\n     * Whether the combobox input is empty\n     */\n    isInputValueEmpty: state.context.isInputValueEmpty,\n    /**\n     * The current value of the combobox input\n     */\n    inputValue: state.context.inputValue,\n    /**\n     * The currently focused option (by pointer or keyboard)\n     */\n    focusedOption: state.context.focusedOptionData,\n    /**\n     * The currently selected option value\n     */\n    selectedValue: state.context.selectionData?.value,\n    /**\n     * Function to set the combobox value\n     */\n    setValue(value2) {\n      let data;\n      if (typeof value2 === \"string\") {\n        data = { value: value2, label: dom.getValueLabel(state.context, value2) };\n      } else {\n        data = value2;\n      }\n      send({ type: \"SET_VALUE\", ...data });\n    },\n    /**\n     * Function to set the combobox input value\n     */\n    setInputValue(value2) {\n      send({ type: \"SET_INPUT_VALUE\", value: value2 });\n    },\n    /**\n     * Function to clear the combobox input value and selected value\n     */\n    clearValue() {\n      send(\"CLEAR_VALUE\");\n    },\n    /**\n     * Function to focus the combobox input\n     */\n    focus() {\n      dom.getInputEl(state.context)?.focus();\n    },\n    rootProps: normalize.element({\n      ...parts.root.attrs,\n      id: dom.getRootId(state.context),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-readonly\": dataAttr(isReadOnly)\n    }),\n    labelProps: normalize.label({\n      ...parts.label.attrs,\n      htmlFor: dom.getInputId(state.context),\n      id: dom.getLabelId(state.context),\n      \"data-readonly\": dataAttr(isReadOnly),\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-focus\": dataAttr(isFocused)\n    }),\n    controlProps: normalize.element({\n      ...parts.control.attrs,\n      id: dom.getControlId(state.context),\n      \"data-expanded\": dataAttr(isOpen),\n      \"data-focus\": dataAttr(isFocused),\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(isInvalid),\n      onPointerOver() {\n        if (!isInteractive)\n          return;\n        send(\"POINTER_OVER\");\n      },\n      onPointerLeave() {\n        if (!isInteractive)\n          return;\n        send(\"POINTER_LEAVE\");\n      }\n    }),\n    positionerProps: normalize.element({\n      ...parts.positioner.attrs,\n      id: dom.getPositionerId(state.context),\n      \"data-expanded\": dataAttr(isOpen),\n      hidden: !isOpen,\n      style: popperStyles.floating\n    }),\n    inputProps: normalize.input({\n      ...parts.input.attrs,\n      \"aria-invalid\": ariaAttr(isInvalid),\n      \"data-invalid\": dataAttr(isInvalid),\n      name: state.context.name,\n      form: state.context.form,\n      disabled: isDisabled,\n      autoFocus: state.context.autoFocus,\n      autoComplete: \"off\",\n      autoCorrect: \"off\",\n      autoCapitalize: \"none\",\n      spellCheck: \"false\",\n      readOnly: isReadOnly,\n      placeholder: state.context.placeholder,\n      id: dom.getInputId(state.context),\n      type: \"text\",\n      role: \"combobox\",\n      defaultValue: value,\n      \"data-value\": value,\n      \"aria-autocomplete\": state.context.autoComplete ? \"both\" : \"list\",\n      \"aria-controls\": isOpen ? dom.getContentId(state.context) : void 0,\n      \"aria-expanded\": isOpen,\n      \"aria-activedescendant\": state.context.focusedId ?? void 0,\n      onClick() {\n        if (!isInteractive)\n          return;\n        send(\"CLICK_INPUT\");\n      },\n      onFocus() {\n        if (isDisabled)\n          return;\n        send(\"FOCUS\");\n      },\n      onChange(event) {\n        const evt = getNativeEvent(event);\n        if (evt.isComposing)\n          return;\n        send({ type: \"CHANGE\", value: event.currentTarget.value });\n      },\n      onKeyDown(event) {\n        if (!isInteractive)\n          return;\n        const evt = getNativeEvent(event);\n        if (evt.ctrlKey || evt.shiftKey || evt.isComposing)\n          return;\n        let prevent = false;\n        const keymap = {\n          ArrowDown(event2) {\n            send(event2.altKey ? \"ALT_ARROW_DOWN\" : \"ARROW_DOWN\");\n            prevent = true;\n          },\n          ArrowUp() {\n            send(event.altKey ? \"ALT_ARROW_UP\" : \"ARROW_UP\");\n            prevent = true;\n          },\n          Home(event2) {\n            const isCtrlKey = event2.ctrlKey || event2.metaKey;\n            if (isCtrlKey)\n              return;\n            send({ type: \"HOME\", preventDefault: () => event2.preventDefault() });\n          },\n          End(event2) {\n            const isCtrlKey = event2.ctrlKey || event2.metaKey;\n            if (isCtrlKey)\n              return;\n            send({ type: \"END\", preventDefault: () => event2.preventDefault() });\n          },\n          Enter() {\n            send(\"ENTER\");\n            prevent = true;\n          },\n          Escape() {\n            send(\"ESCAPE\");\n            prevent = true;\n          },\n          Tab() {\n            send(\"TAB\");\n          }\n        };\n        const key = getEventKey(event, state.context);\n        const exec = keymap[key];\n        exec?.(event);\n        if (prevent) {\n          event.preventDefault();\n        }\n      }\n    }),\n    triggerProps: normalize.button({\n      ...parts.trigger.attrs,\n      id: dom.getTriggerId(state.context),\n      \"aria-haspopup\": \"listbox\",\n      type: \"button\",\n      tabIndex: -1,\n      \"aria-label\": translations.triggerLabel,\n      \"aria-expanded\": isOpen,\n      \"aria-controls\": isOpen ? dom.getContentId(state.context) : void 0,\n      disabled: isDisabled,\n      \"data-readonly\": dataAttr(isReadOnly),\n      \"data-disabled\": dataAttr(isDisabled),\n      onPointerDown(event) {\n        const evt = getNativeEvent(event);\n        if (!isInteractive || !isLeftClick(evt) || evt.pointerType === \"touch\")\n          return;\n        send(\"CLICK_BUTTON\");\n        event.preventDefault();\n      },\n      onPointerUp(event) {\n        if (event.pointerType !== \"touch\")\n          return;\n        send(\"CLICK_BUTTON\");\n      }\n    }),\n    contentProps: normalize.element({\n      ...parts.content.attrs,\n      id: dom.getContentId(state.context),\n      role: \"listbox\",\n      hidden: !isOpen,\n      \"aria-labelledby\": dom.getLabelId(state.context),\n      onPointerDown(event) {\n        event.preventDefault();\n      }\n    }),\n    clearTriggerProps: normalize.button({\n      ...parts.clearTrigger.attrs,\n      id: dom.getClearTriggerId(state.context),\n      type: \"button\",\n      tabIndex: -1,\n      disabled: isDisabled,\n      \"aria-label\": translations.clearTriggerLabel,\n      hidden: !showClearButton,\n      onPointerDown(event) {\n        const evt = getNativeEvent(event);\n        if (!isInteractive || !isLeftClick(evt))\n          return;\n        send(\"CLEAR_VALUE\");\n        event.preventDefault();\n      }\n    }),\n    getOptionState(props) {\n      const { value: value2, index, disabled } = props;\n      const id = dom.getOptionId(state.context, value2, index);\n      const focused = state.context.focusedId === id;\n      const checked = state.context.selectionData?.value === value2;\n      return { disabled, focused, checked };\n    },\n    getOptionProps(props) {\n      const { value: value2, label, index, count } = props;\n      const id = dom.getOptionId(state.context, value2, index);\n      const optionState = api.getOptionState(props);\n      return normalize.element({\n        ...parts.option.attrs,\n        id,\n        role: \"option\",\n        tabIndex: -1,\n        \"data-highlighted\": dataAttr(optionState.focused),\n        \"data-disabled\": dataAttr(optionState.disabled),\n        \"data-checked\": dataAttr(optionState.checked),\n        \"aria-selected\": optionState.focused,\n        \"aria-disabled\": optionState.disabled,\n        \"aria-posinset\": count && index != null ? index + 1 : void 0,\n        \"aria-setsize\": count,\n        \"data-value\": value2,\n        \"data-label\": label,\n        // Prefer `pointermove` to `pointerenter` to avoid interrupting the keyboard navigation\n        // NOTE: for perf, we may want to move these handlers to the listbox\n        onPointerMove() {\n          if (optionState.disabled)\n            return;\n          send({ type: \"POINTEROVER_OPTION\", id, value: value2, label });\n        },\n        onPointerUp() {\n          if (optionState.disabled)\n            return;\n          send({ type: \"CLICK_OPTION\", src: \"pointerup\", id, value: value2, label });\n        },\n        onClick() {\n          if (optionState.disabled)\n            return;\n          send({ type: \"CLICK_OPTION\", src: \"click\", id, value: value2, label });\n        },\n        onAuxClick(event) {\n          if (optionState.disabled)\n            return;\n          event.preventDefault();\n          send({ type: \"CLICK_OPTION\", src: \"auxclick\", id, value: value2, label });\n        }\n      });\n    },\n    getOptionGroupProps(props) {\n      const { label } = props;\n      return normalize.element({\n        ...parts.optionGroup.attrs,\n        role: \"group\",\n        \"aria-label\": label\n      });\n    }\n  };\n  return api;\n}\n\nexport {\n  connect\n};\n", "// src/index.ts\nvar elementCountMap = /* @__PURE__ */ new WeakMap();\nfunction isLiveRegion(node, win) {\n  return node instanceof win.HTMLElement && node.dataset.liveAnnouncer === \"true\";\n}\nfunction ariaHidden(targets, rootEl) {\n  const exclude = targets.filter(Boolean);\n  if (exclude.length === 0)\n    return;\n  const doc = exclude[0].ownerDocument || document;\n  const win = doc.defaultView ?? window;\n  const visibleNodes = new Set(exclude);\n  const hiddenNodes = /* @__PURE__ */ new Set();\n  const root = rootEl ?? doc.body;\n  const walker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n    acceptNode(node2) {\n      if (isLiveRegion(node2, win)) {\n        visibleNodes.add(node2);\n      }\n      if (visibleNodes.has(node2) || hiddenNodes.has(node2.parentElement)) {\n        return NodeFilter.FILTER_REJECT;\n      }\n      if (node2 instanceof win.HTMLElement && node2.getAttribute(\"role\") === \"row\") {\n        return NodeFilter.FILTER_SKIP;\n      }\n      if (exclude.some((target) => node2.contains(target))) {\n        return NodeFilter.FILTER_SKIP;\n      }\n      return NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  const hide = (node2) => {\n    let refCount = elementCountMap.get(node2) ?? 0;\n    if (node2.getAttribute(\"aria-hidden\") === \"true\" && refCount === 0) {\n      return;\n    }\n    if (refCount === 0) {\n      node2.setAttribute(\"aria-hidden\", \"true\");\n    }\n    hiddenNodes.add(node2);\n    elementCountMap.set(node2, refCount + 1);\n  };\n  let node = walker.nextNode();\n  while (node != null) {\n    hide(node);\n    node = walker.nextNode();\n  }\n  const observer = new win.MutationObserver((changes) => {\n    for (let change of changes) {\n      if (change.type !== \"childList\" || change.addedNodes.length === 0)\n        continue;\n      if (![...visibleNodes, ...hiddenNodes].some((node2) => node2.contains(change.target))) {\n        for (const node2 of change.addedNodes) {\n          if (isLiveRegion(node2, win)) {\n            visibleNodes.add(node2);\n          } else if (node2 instanceof win.Element) {\n            hide(node2);\n          }\n        }\n      }\n    }\n  });\n  observer.observe(root, { childList: true, subtree: true });\n  return () => {\n    observer.disconnect();\n    for (let node2 of hiddenNodes) {\n      let count = elementCountMap.get(node2);\n      if (count === 1) {\n        node2.removeAttribute(\"aria-hidden\");\n        elementCountMap.delete(node2);\n        continue;\n      }\n      if (count !== void 0) {\n        elementCountMap.set(node2, count - 1);\n      }\n    }\n  };\n}\nexport {\n  ariaHidden\n};\n", "// src/observe-attributes.ts\nfunction observeAttributes(node, attributes, fn) {\n  if (!node)\n    return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, { attributes: true, attributeFilter: attributes });\n  return () => obs.disconnect();\n}\n\nexport {\n  observeAttributes\n};\n", "// src/observe-children.ts\nfunction observeChildren(node, fn) {\n  if (!node)\n    return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, { childList: true, subtree: true });\n  return () => obs.disconnect();\n}\n\nexport {\n  observeChildren\n};\n", "// src/get-window-frames.ts\nfunction getWindowFrames(win) {\n  const frames = {\n    each(cb) {\n      for (let i = 0; i < win.frames?.length; i += 1) {\n        const frame = win.frames[i];\n        if (frame)\n          cb(frame);\n      }\n    },\n    addEventListener(event, listener, options) {\n      frames.each((frame) => {\n        try {\n          frame.document.addEventListener(event, listener, options);\n        } catch (err) {\n          console.warn(err);\n        }\n      });\n      return () => {\n        try {\n          frames.removeEventListener(event, listener, options);\n        } catch (err) {\n          console.warn(err);\n        }\n      };\n    },\n    removeEventListener(event, listener, options) {\n      frames.each((frame) => {\n        try {\n          frame.document.removeEventListener(event, listener, options);\n        } catch (err) {\n          console.warn(err);\n        }\n      });\n    }\n  };\n  return frames;\n}\n\nexport {\n  getWindowFrames\n};\n", "// src/index.ts\nvar isHTMLElement = (element) => typeof element === \"object\" && element !== null && element.nodeType === 1;\nvar isFrame = (element) => isHTMLElement(element) && element.tagName === \"IFRAME\";\nfunction isVisible(el) {\n  if (!isHTMLElement(el))\n    return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n}\nfunction hasNegativeTabIndex(element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10);\n  return tabIndex < 0;\n}\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, includeContainer = false) => {\n  if (!container)\n    return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = elements.filter(isFocusable);\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.splice(i, 1, ...getFocusables(frameBody));\n    }\n  });\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!element)\n    return false;\n  return element.matches(focusableSelector) && isVisible(element);\n}\nfunction getFirstFocusable(container, includeContainer) {\n  const [first] = getFocusables(container, includeContainer);\n  return first || null;\n}\nfunction getTabbables(container, includeContainer) {\n  if (!container)\n    return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const tabbableElements = elements.filter(isTabbable);\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container);\n  }\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      const allFrameTabbable = getTabbables(frameBody);\n      tabbableElements.splice(i, 1, ...allFrameTabbable);\n    }\n  });\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, includeContainer) {\n  const [first] = getTabbables(container, includeContainer);\n  return first || null;\n}\nfunction getLastTabbable(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, current) {\n  const tabbables = getTabbables(container);\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? doc.activeElement;\n  if (!currentElement)\n    return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\nfunction proxyTabFocus(container, reference, cb) {\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\")\n      return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = reference;\n    } else if (!event.shiftKey && doc.activeElement === reference) {\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      elementToFocus = getNextTabbable(body, reference);\n    }\n    if (!elementToFocus)\n      return;\n    event.preventDefault();\n    cb(elementToFocus);\n  }\n  doc?.addEventListener(\"keydown\", onKeyDown, true);\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true);\n  };\n}\nexport {\n  focusableSelector,\n  getFirstFocusable,\n  getFirstTabbable,\n  getFocusables,\n  getLastTabbable,\n  getNextTabbable,\n  getTabbableEdges,\n  getTabbables,\n  isFocusable,\n  isTabbable,\n  proxyTabFocus\n};\n", "import {\n  getWindowFrames\n} from \"./chunk-UQ6OADW7.mjs\";\n\n// src/index.ts\nimport { addDomEvent, fireCustomEvent, isContextMenuEvent } from \"@zag-js/dom-event\";\nimport { contains, getDocument, getEventTarget, getWindow, isHTMLElement } from \"@zag-js/dom-query\";\nimport { isFocusable } from \"@zag-js/tabbable\";\nimport { callAll } from \"@zag-js/utils\";\nvar POINTER_OUTSIDE_EVENT = \"pointerdown.outside\";\nvar FOCUS_OUTSIDE_EVENT = \"focus.outside\";\nfunction isComposedPathFocusable(event) {\n  const composedPath = event.composedPath() ?? [event.target];\n  for (const node of composedPath) {\n    if (isHTMLElement(node) && isFocusable(node))\n      return true;\n  }\n  return false;\n}\nfunction trackInteractOutside(node, options) {\n  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside } = options;\n  if (!node)\n    return;\n  const doc = getDocument(node);\n  const win = getWindow(node);\n  const frames = getWindowFrames(win);\n  function isEventOutside(event) {\n    const target = getEventTarget(event);\n    if (!isHTMLElement(target)) {\n      return false;\n    }\n    if (contains(node, target)) {\n      return false;\n    }\n    return !exclude?.(target);\n  }\n  let clickHandler;\n  function onPointerDown(event) {\n    function handler() {\n      if (!node || !isEventOutside(event))\n        return;\n      if (onPointerDownOutside || onInteractOutside) {\n        const handler2 = callAll(onPointerDownOutside, onInteractOutside);\n        node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });\n      }\n      fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n          originalEvent: event,\n          contextmenu: isContextMenuEvent(event),\n          focusable: isComposedPathFocusable(event)\n        }\n      });\n    }\n    if (event.pointerType === \"touch\") {\n      frames.removeEventListener(\"click\", handler);\n      doc.removeEventListener(\"click\", handler);\n      clickHandler = handler;\n      doc.addEventListener(\"click\", handler, { once: true });\n      frames.addEventListener(\"click\", handler, { once: true });\n    } else {\n      handler();\n    }\n  }\n  const cleanups = /* @__PURE__ */ new Set();\n  const timer = setTimeout(() => {\n    cleanups.add(frames.addEventListener(\"pointerdown\", onPointerDown, true));\n    cleanups.add(addDomEvent(doc, \"pointerdown\", onPointerDown, true));\n  }, 0);\n  function onFocusin(event) {\n    if (!node || !isEventOutside(event))\n      return;\n    if (onFocusOutside || onInteractOutside) {\n      const handler = callAll(onFocusOutside, onInteractOutside);\n      node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });\n    }\n    fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {\n      bubbles: false,\n      cancelable: true,\n      detail: {\n        originalEvent: event,\n        contextmenu: false,\n        focusable: isFocusable(getEventTarget(event))\n      }\n    });\n  }\n  cleanups.add(addDomEvent(doc, \"focusin\", onFocusin, true));\n  cleanups.add(frames.addEventListener(\"focusin\", onFocusin, true));\n  return () => {\n    clearTimeout(timer);\n    if (clickHandler) {\n      frames.removeEventListener(\"click\", clickHandler);\n      doc.removeEventListener(\"click\", clickHandler);\n    }\n    cleanups.forEach((fn) => fn());\n  };\n}\nexport {\n  trackInteractOutside\n};\n", "// src/index.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\nfunction setVisuallyHidden(el) {\n  Object.assign(el.style, visuallyHiddenStyle);\n}\nexport {\n  setVisuallyHidden,\n  visuallyHiddenStyle\n};\n", "// src/index.ts\nimport { setVisuallyHidden } from \"@zag-js/visually-hidden\";\nvar ID = \"__live-region__\";\nfunction createLiveRegion(opts = {}) {\n  const { level = \"polite\", document: doc = document, root, delay: _delay = 0 } = opts;\n  const win = doc.defaultView ?? window;\n  const parent = root ?? doc.body;\n  function announce(message, delay) {\n    const oldRegion = doc.getElementById(ID);\n    oldRegion?.remove();\n    delay = delay ?? _delay;\n    const region = doc.createElement(\"span\");\n    region.id = ID;\n    region.dataset.liveAnnouncer = \"true\";\n    const role = level !== \"assertive\" ? \"status\" : \"alert\";\n    region.setAttribute(\"aria-live\", level);\n    region.setAttribute(\"role\", role);\n    setVisuallyHidden(region);\n    parent.appendChild(region);\n    win.setTimeout(() => {\n      region.textContent = message;\n    }, delay);\n  }\n  function destroy() {\n    const oldRegion = doc.getElementById(ID);\n    oldRegion?.remove();\n  }\n  return {\n    announce,\n    destroy,\n    toJSON() {\n      return ID;\n    }\n  };\n}\nexport {\n  createLiveRegion\n};\n", "import {\n  dom\n} from \"./chunk-ZZ5TA5X3.mjs\";\n\n// src/combobox.machine.ts\nimport { ariaHidden } from \"@zag-js/aria-hidden\";\nimport { createMachine, guards } from \"@zag-js/core\";\nimport { contains, raf } from \"@zag-js/dom-query\";\nimport { observeAttributes, observeChildren } from \"@zag-js/mutation-observer\";\nimport { trackInteractOutside } from \"@zag-js/interact-outside\";\nimport { createLiveRegion } from \"@zag-js/live-region\";\nimport { getPlacement } from \"@zag-js/popper\";\nimport { compact } from \"@zag-js/utils\";\nvar { and, not } = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine(\n    {\n      id: \"combobox\",\n      initial: ctx.autoFocus ? \"focused\" : \"idle\",\n      context: {\n        loop: true,\n        openOnClick: false,\n        ariaHidden: true,\n        focusedId: null,\n        focusedOptionData: null,\n        navigationData: null,\n        selectionData: null,\n        inputValue: \"\",\n        liveRegion: null,\n        focusOnClear: true,\n        selectInputOnFocus: false,\n        selectOnTab: true,\n        isHovering: false,\n        isKeyboardEvent: false,\n        allowCustomValue: false,\n        isCustomValue: (data) => data.inputValue !== data.previousValue,\n        inputBehavior: \"none\",\n        selectionBehavior: \"set\",\n        ...ctx,\n        positioning: {\n          placement: \"bottom\",\n          flip: false,\n          sameWidth: true,\n          ...ctx.positioning\n        },\n        translations: {\n          triggerLabel: \"Toggle suggestions\",\n          clearTriggerLabel: \"Clear value\",\n          navigationHint: \"use the up and down keys to navigate. Press the enter key to select\",\n          countAnnouncement: (count) => `${count} ${count === 1 ? \"option\" : \"options\"} available`,\n          ...ctx.translations\n        }\n      },\n      computed: {\n        isInputValueEmpty: (ctx2) => ctx2.inputValue.length === 0,\n        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),\n        autoComplete: (ctx2) => ctx2.inputBehavior === \"autocomplete\",\n        autoHighlight: (ctx2) => ctx2.inputBehavior === \"autohighlight\"\n      },\n      watch: {\n        inputValue: \"invokeOnInputChange\",\n        navigationData: \"invokeOnHighlight\",\n        selectionData: [\"invokeOnSelect\", \"blurInputIfNeeded\"],\n        focusedId: \"setSectionLabel\"\n      },\n      entry: [\"setupLiveRegion\"],\n      exit: [\"removeLiveRegion\"],\n      activities: [\"syncInputValue\"],\n      on: {\n        SET_VALUE: {\n          actions: [\"setInputValue\", \"setSelectionData\"]\n        },\n        SET_INPUT_VALUE: {\n          actions: \"setInputValue\"\n        },\n        CLEAR_VALUE: [\n          {\n            guard: \"focusOnClear\",\n            target: \"focused\",\n            actions: [\"clearInputValue\", \"clearSelectedValue\"]\n          },\n          {\n            actions: [\"clearInputValue\", \"clearSelectedValue\"]\n          }\n        ],\n        POINTER_OVER: {\n          actions: \"setIsHovering\"\n        },\n        POINTER_LEAVE: {\n          actions: \"clearIsHovering\"\n        }\n      },\n      states: {\n        idle: {\n          tags: [\"idle\"],\n          entry: [\"scrollToTop\", \"clearFocusedOption\"],\n          on: {\n            CLICK_BUTTON: {\n              target: \"interacting\",\n              actions: [\"focusInput\", \"invokeOnOpen\"]\n            },\n            CLICK_INPUT: {\n              guard: \"openOnClick\",\n              target: \"interacting\",\n              actions: \"invokeOnOpen\"\n            },\n            FOCUS: \"focused\"\n          }\n        },\n        focused: {\n          tags: [\"focused\"],\n          entry: [\"focusInput\", \"scrollToTop\", \"clearFocusedOption\"],\n          activities: [\"trackInteractOutside\"],\n          on: {\n            CHANGE: {\n              target: \"suggesting\",\n              actions: \"setInputValue\"\n            },\n            BLUR: \"idle\",\n            ESCAPE: {\n              guard: and(\"isCustomValue\", not(\"allowCustomValue\")),\n              actions: \"revertInputValue\"\n            },\n            CLICK_INPUT: {\n              guard: \"openOnClick\",\n              target: \"interacting\",\n              actions: [\"focusInput\", \"invokeOnOpen\"]\n            },\n            CLICK_BUTTON: {\n              target: \"interacting\",\n              actions: [\"focusInput\", \"invokeOnOpen\"]\n            },\n            POINTER_OVER: {\n              actions: \"setIsHovering\"\n            },\n            ARROW_UP: [\n              {\n                guard: \"autoComplete\",\n                target: \"interacting\",\n                actions: \"invokeOnOpen\"\n              },\n              {\n                target: \"interacting\",\n                actions: [\"focusLastOption\", \"invokeOnOpen\"]\n              }\n            ],\n            ARROW_DOWN: [\n              {\n                guard: \"autoComplete\",\n                target: \"interacting\",\n                actions: \"invokeOnOpen\"\n              },\n              {\n                target: \"interacting\",\n                actions: [\"focusFirstOption\", \"invokeOnOpen\"]\n              }\n            ],\n            ALT_ARROW_DOWN: {\n              target: \"interacting\",\n              actions: [\"focusInput\", \"invokeOnOpen\"]\n            }\n          }\n        },\n        suggesting: {\n          tags: [\"open\", \"focused\"],\n          activities: [\n            \"trackInteractOutside\",\n            \"scrollOptionIntoView\",\n            \"computePlacement\",\n            \"trackOptionNodes\",\n            \"hideOtherElements\"\n          ],\n          entry: [\"focusInput\", \"invokeOnOpen\"],\n          on: {\n            ARROW_DOWN: {\n              target: \"interacting\",\n              actions: \"focusNextOption\"\n            },\n            ARROW_UP: {\n              target: \"interacting\",\n              actions: \"focusPrevOption\"\n            },\n            ALT_ARROW_UP: \"focused\",\n            HOME: {\n              target: \"interacting\",\n              actions: [\"focusFirstOption\", \"preventDefault\"]\n            },\n            END: {\n              target: \"interacting\",\n              actions: [\"focusLastOption\", \"preventDefault\"]\n            },\n            ENTER: [\n              {\n                guard: and(\"hasFocusedOption\", \"autoComplete\"),\n                target: \"focused\",\n                actions: \"selectActiveOption\"\n              },\n              {\n                guard: \"hasFocusedOption\",\n                target: \"focused\",\n                actions: \"selectOption\"\n              }\n            ],\n            CHANGE: [\n              {\n                guard: \"autoHighlight\",\n                actions: [\"clearFocusedOption\", \"setInputValue\", \"focusFirstOption\"]\n              },\n              {\n                actions: [\"clearFocusedOption\", \"setInputValue\"]\n              }\n            ],\n            ESCAPE: {\n              target: \"focused\",\n              actions: \"invokeOnClose\"\n            },\n            POINTEROVER_OPTION: [\n              {\n                guard: \"autoComplete\",\n                target: \"interacting\",\n                actions: \"setActiveOption\"\n              },\n              {\n                target: \"interacting\",\n                actions: [\"setActiveOption\", \"setNavigationData\"]\n              }\n            ],\n            BLUR: {\n              target: \"idle\",\n              actions: \"invokeOnClose\"\n            },\n            CLICK_BUTTON: {\n              target: \"focused\",\n              actions: \"invokeOnClose\"\n            },\n            CLICK_OPTION: {\n              target: \"focused\",\n              actions: [\"selectOption\", \"invokeOnClose\"]\n            }\n          }\n        },\n        interacting: {\n          tags: [\"open\", \"focused\"],\n          activities: [\"scrollOptionIntoView\", \"trackInteractOutside\", \"computePlacement\", \"hideOtherElements\"],\n          entry: \"focusMatchingOption\",\n          on: {\n            HOME: {\n              actions: [\"focusFirstOption\", \"preventDefault\"]\n            },\n            END: {\n              actions: [\"focusLastOption\", \"preventDefault\"]\n            },\n            ARROW_DOWN: [\n              {\n                guard: and(\"autoComplete\", \"isLastOptionFocused\"),\n                actions: [\"clearFocusedOption\", \"scrollToTop\"]\n              },\n              { actions: \"focusNextOption\" }\n            ],\n            ARROW_UP: [\n              {\n                guard: and(\"autoComplete\", \"isFirstOptionFocused\"),\n                actions: \"clearFocusedOption\"\n              },\n              {\n                actions: \"focusPrevOption\"\n              }\n            ],\n            ALT_UP: {\n              target: \"focused\",\n              actions: [\"selectOption\", \"invokeOnClose\"]\n            },\n            CLEAR_FOCUS: {\n              actions: \"clearFocusedOption\"\n            },\n            TAB: {\n              guard: \"selectOnTab\",\n              target: \"idle\",\n              actions: [\"selectOption\", \"invokeOnClose\"]\n            },\n            ENTER: {\n              target: \"focused\",\n              actions: [\"selectOption\", \"invokeOnClose\"]\n            },\n            CHANGE: [\n              {\n                guard: \"autoComplete\",\n                target: \"suggesting\",\n                actions: [\"commitNavigationData\", \"setInputValue\"]\n              },\n              {\n                target: \"suggesting\",\n                actions: [\"clearFocusedOption\", \"setInputValue\"]\n              }\n            ],\n            POINTEROVER_OPTION: [\n              {\n                guard: \"autoComplete\",\n                actions: \"setActiveOption\"\n              },\n              {\n                actions: [\"setActiveOption\", \"setNavigationData\"]\n              }\n            ],\n            CLICK_OPTION: {\n              target: \"focused\",\n              actions: [\"selectOption\", \"invokeOnClose\"]\n            },\n            ESCAPE: {\n              target: \"focused\",\n              actions: \"invokeOnClose\"\n            },\n            CLICK_BUTTON: {\n              target: \"focused\",\n              actions: \"invokeOnClose\"\n            },\n            BLUR: {\n              target: \"idle\",\n              actions: \"invokeOnClose\"\n            }\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        openOnClick: (ctx2) => !!ctx2.openOnClick,\n        isInputValueEmpty: (ctx2) => ctx2.isInputValueEmpty,\n        focusOnClear: (ctx2) => !!ctx2.focusOnClear,\n        autoFocus: (ctx2) => !!ctx2.autoFocus,\n        autoComplete: (ctx2) => ctx2.autoComplete,\n        autoHighlight: (ctx2) => ctx2.autoHighlight,\n        isFirstOptionFocused: (ctx2) => dom.getFirstEl(ctx2)?.id === ctx2.focusedId,\n        isLastOptionFocused: (ctx2) => dom.getLastEl(ctx2)?.id === ctx2.focusedId,\n        isCustomValue: (ctx2) => !!ctx2.isCustomValue?.({ inputValue: ctx2.inputValue, previousValue: ctx2.selectionData?.value }),\n        allowCustomValue: (ctx2) => !!ctx2.allowCustomValue,\n        hasFocusedOption: (ctx2) => !!ctx2.focusedId,\n        selectOnTab: (ctx2) => !!ctx2.selectOnTab\n      },\n      activities: {\n        syncInputValue: (ctx2) => {\n          const input = dom.getInputEl(ctx2);\n          return observeAttributes(input, [\"data-value\"], () => {\n            if (!input)\n              return;\n            const value = input.dataset.value || \"\";\n            input.value = value;\n            input.selectionStart = value.length;\n            input.selectionEnd = value.length;\n          });\n        },\n        trackInteractOutside(ctx2, _evt, { send }) {\n          return trackInteractOutside(dom.getInputEl(ctx2), {\n            exclude(target) {\n              const ignore = [dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)];\n              return ignore.some((el) => contains(el, target));\n            },\n            onInteractOutside(event) {\n              ctx2.onInteractOutside?.(event);\n              if (event.defaultPrevented)\n                return;\n              send({ type: \"BLUR\", src: \"interact-outside\" });\n            }\n          });\n        },\n        hideOtherElements(ctx2) {\n          if (!ctx2.ariaHidden)\n            return;\n          return ariaHidden([dom.getInputEl(ctx2), dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)]);\n        },\n        computePlacement(ctx2) {\n          ctx2.currentPlacement = ctx2.positioning.placement;\n          return getPlacement(dom.getControlEl(ctx2), dom.getPositionerEl(ctx2), {\n            ...ctx2.positioning,\n            onComplete(data) {\n              ctx2.currentPlacement = data.placement;\n            },\n            onCleanup() {\n              ctx2.currentPlacement = void 0;\n            }\n          });\n        },\n        // in event the options are fetched (async), we still want to auto-highlight the first option\n        trackOptionNodes(ctx2, evt, meta) {\n          if (!ctx2.autoHighlight)\n            return;\n          const focusFirstOption = meta.getAction(\"focusFirstOption\");\n          const exec = () => focusFirstOption(ctx2, evt, meta);\n          exec();\n          return observeChildren(dom.getContentEl(ctx2), exec);\n        },\n        scrollOptionIntoView(ctx2, _evt, { getState }) {\n          const input = dom.getInputEl(ctx2);\n          return observeAttributes(input, [\"aria-activedescendant\"], () => {\n            const evt = getState().event;\n            const isKeyboardEvent = /(ARROW_UP|ARROW_DOWN|HOME|END|TAB)/.test(evt.type);\n            if (!isKeyboardEvent)\n              return;\n            const option = dom.getActiveOptionEl(ctx2);\n            option?.scrollIntoView({ block: \"nearest\" });\n            if (ctx2.autoComplete) {\n              dom.focusInput(ctx2);\n            }\n          });\n        }\n      },\n      actions: {\n        setupLiveRegion(ctx2) {\n          ctx2.liveRegion = createLiveRegion({\n            level: \"assertive\",\n            document: dom.getDoc(ctx2)\n          });\n        },\n        removeLiveRegion(ctx2) {\n          ctx2.liveRegion?.destroy();\n        },\n        setActiveOption(ctx2, evt) {\n          const { label, id, value } = evt;\n          ctx2.focusedId = id;\n          ctx2.focusedOptionData = { label, value };\n        },\n        setNavigationData(ctx2, evt) {\n          const { label, value } = evt;\n          ctx2.navigationData = { label, value };\n        },\n        clearNavigationData(ctx2) {\n          ctx2.navigationData = null;\n        },\n        commitNavigationData(ctx2) {\n          if (!ctx2.navigationData)\n            return;\n          ctx2.inputValue = ctx2.navigationData.label;\n          ctx2.navigationData = null;\n        },\n        clearFocusedOption(ctx2) {\n          ctx2.focusedId = null;\n          ctx2.focusedOptionData = null;\n          ctx2.navigationData = null;\n        },\n        selectActiveOption(ctx2) {\n          if (!ctx2.focusedOptionData)\n            return;\n          ctx2.selectionData = ctx2.focusedOptionData;\n          ctx2.inputValue = ctx2.focusedOptionData.label;\n        },\n        selectOption(ctx2, evt) {\n          const isOptionEvent = !!evt.value && !!evt.label;\n          ctx2.selectionData = isOptionEvent ? {\n            label: evt.label,\n            value: evt.value\n          } : ctx2.navigationData;\n          let value;\n          if (!ctx2.selectionData)\n            return;\n          if (ctx2.selectionBehavior === \"set\") {\n            value = ctx2.selectionData.label;\n          }\n          if (ctx2.selectionBehavior === \"clear\") {\n            value = \"\";\n          }\n          if (value != null) {\n            ctx2.inputValue = value;\n          }\n        },\n        blurInputIfNeeded(ctx2) {\n          if (ctx2.autoComplete || !ctx2.blurOnSelect)\n            return;\n          raf(() => {\n            dom.getInputEl(ctx2)?.blur();\n          });\n        },\n        focusInput(ctx2, evt) {\n          if (evt.type === \"CHANGE\")\n            return;\n          dom.focusInput(ctx2);\n        },\n        setInputValue(ctx2, evt) {\n          const value = evt.type === \"SET_VALUE\" ? evt.label : evt.value;\n          ctx2.inputValue = value;\n        },\n        clearInputValue(ctx2) {\n          ctx2.inputValue = \"\";\n        },\n        revertInputValue(ctx2) {\n          if (!ctx2.selectionData)\n            return;\n          ctx2.inputValue = ctx2.selectionData.label;\n        },\n        setSelectionData(ctx2, evt) {\n          const { label, value } = evt;\n          ctx2.selectionData = { label, value };\n        },\n        clearSelectedValue(ctx2) {\n          ctx2.selectionData = null;\n        },\n        scrollToTop(ctx2) {\n          const listbox = dom.getContentEl(ctx2);\n          if (!listbox)\n            return;\n          listbox.scrollTop = 0;\n        },\n        invokeOnInputChange(ctx2) {\n          ctx2.onInputChange?.({ value: ctx2.inputValue });\n        },\n        invokeOnHighlight(ctx2) {\n          const { label, value } = ctx2.navigationData ?? {};\n          const relatedTarget = dom.getMatchingOptionEl(ctx2, value);\n          ctx2.onHighlight?.({ label, value, relatedTarget });\n        },\n        invokeOnSelect(ctx2) {\n          const { label, value } = ctx2.selectionData ?? {};\n          const relatedTarget = dom.getMatchingOptionEl(ctx2, value);\n          ctx2.onSelect?.({ label, value, relatedTarget });\n        },\n        invokeOnOpen(ctx2) {\n          ctx2.onOpen?.();\n        },\n        invokeOnClose(ctx2) {\n          ctx2.onClose?.();\n        },\n        highlightFirstOption(ctx2) {\n          raf(() => {\n            setHighlight(ctx2, dom.getFirstEl(ctx2));\n          });\n        },\n        focusFirstOption(ctx2) {\n          raf(() => {\n            setFocus(ctx2, dom.getFirstEl(ctx2));\n          });\n        },\n        focusLastOption(ctx2) {\n          raf(() => {\n            setFocus(ctx2, dom.getLastEl(ctx2));\n          });\n        },\n        focusNextOption(ctx2) {\n          raf(() => {\n            const option = dom.getNextEl(ctx2, ctx2.focusedId ?? \"\");\n            setFocus(ctx2, option);\n          });\n        },\n        focusPrevOption(ctx2) {\n          raf(() => {\n            let option = dom.getPrevEl(ctx2, ctx2.focusedId ?? \"\");\n            setFocus(ctx2, option);\n          });\n        },\n        focusMatchingOption(ctx2) {\n          raf(() => {\n            const option = dom.getMatchingOptionEl(ctx2, ctx2.selectionData?.value);\n            option?.scrollIntoView({ block: \"nearest\" });\n            setFocus(ctx2, option);\n          });\n        },\n        announceOptionCount(ctx2) {\n          raf(() => {\n            const count = dom.getOptionCount(ctx2);\n            if (!count)\n              return;\n            const text = ctx2.translations.countAnnouncement(count);\n            ctx2.liveRegion?.announce(text);\n          });\n        },\n        setIsHovering(ctx2) {\n          ctx2.isHovering = true;\n        },\n        clearIsHovering(ctx2) {\n          ctx2.isHovering = false;\n        },\n        preventDefault(_ctx, evt) {\n          evt.preventDefault();\n        },\n        setSectionLabel(ctx2) {\n          const label = dom.getClosestSectionLabel(ctx2);\n          if (!label)\n            return;\n          ctx2.sectionLabel = label;\n        }\n      }\n    }\n  );\n}\nfunction setHighlight(ctx, option) {\n  if (!option)\n    return;\n  const data = dom.getOptionData(option);\n  ctx.focusedId = option.id;\n  ctx.focusedOptionData = data;\n  return data;\n}\nfunction setFocus(ctx, option) {\n  if (!option || option.id === ctx.focusedId)\n    return;\n  const data = setHighlight(ctx, option);\n  ctx.navigationData = data;\n}\n\nexport {\n  machine\n};\n"],
  "mappings": "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",
  "names": ["parts", "platform", "min", "max", "offset", "platform", "side", "placement", "overflow", "platform", "x", "y", "min", "max", "platform", "getWindow", "isHTMLElement", "min", "max", "win", "window", "computePosition", "callAll", "isHTMLElement", "addDomEvent", "arrow", "computePosition", "_a", "hide", "isHTMLElement", "isHTMLElement"]
}
