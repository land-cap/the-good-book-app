import {
  addDomEvent,
  ariaAttr,
  callAll,
  compact,
  contains,
  createScope,
  dataAttr,
  fireCustomEvent,
  first,
  getDocument,
  getEventKey,
  getEventTarget,
  getNativeEvent,
  getWindow,
  isContextMenuEvent,
  isHTMLElement,
  isLeftClick,
  last,
  nextById,
  prevById,
  queryAll,
  raf
} from "./chunk-7NVEAXV7.js";
import {
  createMachine,
  guards
} from "./chunk-MYDS4API.js";
import "./chunk-ENY474MH.js";

// node_modules/.pnpm/@zag-js+anatomy@0.1.4/node_modules/@zag-js/anatomy/dist/chunk-JKTBQDTH.mjs
var createAnatomy = (name, parts2 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts2)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts2, ...values]),
  build: () => [...new Set(parts2)].reduce(
    (prev, part) => Object.assign(prev, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-53AIL37A.mjs
var anatomy = createAnatomy("combobox").parts(
  "root",
  "label",
  "input",
  "positioner",
  "control",
  "trigger",
  "content",
  "clearTrigger",
  "option",
  "optionGroup"
);
var parts = anatomy.build();

// node_modules/.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-ZZ5TA5X3.mjs
var dom = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `combobox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `combobox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `combobox:${ctx.id}:control`;
  },
  getInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `combobox:${ctx.id}:input`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `combobox:${ctx.id}:listbox`;
  },
  getPositionerId: (ctx) => `combobox:${ctx.id}:popper`,
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `combobox:${ctx.id}:toggle-btn`;
  },
  getClearTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.clearTrigger) ?? `combobox:${ctx.id}:clear-btn`;
  },
  getOptionId: (ctx, id, index) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.option) == null ? void 0 : _b.call(_a, id, index)) ?? [`combobox:${ctx.id}:option:${id}`, index].filter((v) => v != null).join(":");
  },
  getActiveOptionEl: (ctx) => ctx.focusedId ? dom.getById(ctx, ctx.focusedId) : null,
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getInputEl: (ctx) => dom.getById(ctx, dom.getInputId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom.getById(ctx, dom.getClearTriggerId(ctx)),
  getElements: (ctx) => queryAll(dom.getContentEl(ctx), "[role=option]:not([aria-disabled=true])"),
  getFocusedOptionEl: (ctx) => {
    var _a;
    if (!ctx.focusedId)
      return null;
    const selector = `[role=option][id=${CSS.escape(ctx.focusedId)}]`;
    return (_a = dom.getContentEl(ctx)) == null ? void 0 : _a.querySelector(selector);
  },
  getFirstEl: (ctx) => first(dom.getElements(ctx)),
  getLastEl: (ctx) => last(dom.getElements(ctx)),
  getPrevEl: (ctx, id) => prevById(dom.getElements(ctx), id, ctx.loop),
  getNextEl: (ctx, id) => nextById(dom.getElements(ctx), id, ctx.loop),
  isInputFocused: (ctx) => dom.getDoc(ctx).activeElement === dom.getInputEl(ctx),
  getOptionData: (el) => ({
    value: (el == null ? void 0 : el.getAttribute("data-value")) ?? "",
    label: (el == null ? void 0 : el.getAttribute("data-label")) ?? ""
  }),
  getOptionCount: (ctx) => {
    var _a;
    const listbox = dom.getContentEl(ctx);
    const count = (_a = listbox == null ? void 0 : listbox.querySelector("[role=option]")) == null ? void 0 : _a.getAttribute("aria-setsize");
    if (count != null)
      return parseInt(count);
    return (listbox == null ? void 0 : listbox.querySelectorAll("[role=option]").length) ?? 0;
  },
  getMatchingOptionEl: (ctx, value) => {
    if (!value)
      return null;
    const selector = `[role=option][data-value="${CSS.escape(value)}"`;
    const listbox = dom.getContentEl(ctx);
    if (!listbox)
      return null;
    return listbox.querySelector(selector);
  },
  focusInput: (ctx) => {
    const input = dom.getInputEl(ctx);
    if (dom.getDoc(ctx).activeElement !== input) {
      input == null ? void 0 : input.focus();
    }
    if (ctx.selectInputOnFocus) {
      input == null ? void 0 : input.select();
    }
  },
  getClosestSectionLabel(ctx) {
    var _a;
    if (!ctx.focusedId)
      return;
    const group = (_a = dom.getActiveOptionEl(ctx)) == null ? void 0 : _a.closest("[data-part=option-group]");
    return group == null ? void 0 : group.getAttribute("aria-label");
  },
  getValueLabel: (ctx, value) => {
    const el = dom.getMatchingOptionEl(ctx, value);
    return dom.getOptionData(el).label;
  }
});

// node_modules/.pnpm/@floating-ui+core@1.2.6/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      element,
      padding = 0
    } = options || {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min3, center, max3);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min3 ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min3 ? min3 - center : max3 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(state) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = options;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const axis = getMainAxisFromPlacement(placement);
      const isXAxis = axis === "x";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isXAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isXAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/.pnpm/@floating-ui+dom@1.2.5/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs
function getWindow2(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getComputedStyle$1(element) {
  return getWindow2(element).getComputedStyle(element);
}
function isNode(value) {
  return value instanceof getWindow2(value).Node;
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || "").toLowerCase() : "";
}
var uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
    return uaString;
  }
  return navigator.userAgent;
}
function isHTMLElement2(value) {
  return value instanceof getWindow2(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow2(value).Element;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow2(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;
  return css.transform !== "none" || css.perspective !== "none" || (backdropFilter ? backdropFilter !== "none" : false) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective"].some((value) => css.willChange.includes(value)) || ["paint", "layout", "strict", "content"].some((value) => {
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}
function isClientRectVisualViewportBased() {
  return /^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width);
  let height = parseFloat(css.height);
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
var FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x = (fallback ? round(rect.width) : rect.width) / width;
  let y = (fallback ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow2(domElement) : window;
  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win2 = getWindow2(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentIFrame = win2.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win2) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow2(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return parentNode.ownerDocument.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isClientRectVisualViewportBased();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const mutableRect = {
      ...clippingAncestor
    };
    if (isClientRectVisualViewportBased()) {
      var _win$visualViewport, _win$visualViewport2;
      const win = getWindow2(element);
      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;
      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;
    }
    rect = mutableRect;
  }
  return rectToClientRect(rect);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const containingBlock = isContainingBlock(currentNode);
    const shouldIgnoreCurrentNode = computedStyle.position === "fixed";
    if (shouldIgnoreCurrentNode) {
      currentContainingBlockComputedStyle = null;
    } else {
      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow2(element);
  if (!isHTMLElement2(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === "fixed", offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...await getDimensionsFn(floating)
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/.pnpm/@zag-js+element-rect@0.3.0/node_modules/@zag-js/element-rect/dist/index.mjs
var rafId;
var observedElements = /* @__PURE__ */ new Map();
function trackElementRect(el, fn, options = {}) {
  const { scope = "rect" } = options;
  const loop = getLoopFn(scope);
  const data = observedElements.get(el);
  if (!data) {
    observedElements.set(el, {
      rect: {},
      callbacks: [fn]
    });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(loop);
    }
  } else {
    data.callbacks.push(fn);
    fn(el.getBoundingClientRect());
  }
  return function unobserve() {
    const data2 = observedElements.get(el);
    if (!data2)
      return;
    const index = data2.callbacks.indexOf(fn);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
function getLoopFn(scope) {
  const isEqual = getEqualityFn(scope);
  return function loop() {
    const changedRectsData = [];
    observedElements.forEach((data, element) => {
      const newRect = element.getBoundingClientRect();
      if (!isEqual(data.rect, newRect)) {
        data.rect = newRect;
        changedRectsData.push(data);
      }
    });
    changedRectsData.forEach((data) => {
      data.callbacks.forEach((callback) => callback(data.rect));
    });
    rafId = requestAnimationFrame(loop);
  };
}
var isEqualSize = (a, b) => a.width === b.width && a.height === b.height;
var isEqualPosition = (a, b) => a.top === b.top && a.right === b.right && a.bottom === b.bottom && a.left === b.left;
var isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);
function getEqualityFn(scope) {
  if (scope === "size")
    return isEqualSize;
  if (scope === "position")
    return isEqualPosition;
  return isEqualRect;
}

// node_modules/.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-AVEWKGZP.mjs
var callAll2 = (...fns) => () => fns.forEach((fn) => fn());
var isHTMLElement3 = (el) => {
  return typeof el === "object" && el !== null && el.nodeType === 1;
};
var addDomEvent2 = (el, type, fn, options) => {
  el.addEventListener(type, fn, options);
  return () => el.removeEventListener(type, fn, options);
};
function resolveOptions(option) {
  const bool = typeof option === "boolean";
  return {
    ancestorResize: bool ? option : option.ancestorResize ?? true,
    ancestorScroll: bool ? option : option.ancestorScroll ?? true,
    referenceResize: bool ? option : option.referenceResize ?? true
  };
}
function autoUpdate(reference, floating, update, options = false) {
  const { ancestorScroll, ancestorResize, referenceResize } = resolveOptions(options);
  const useAncestors = ancestorScroll || ancestorResize;
  const ancestors = [];
  if (useAncestors && isHTMLElement3(reference)) {
    ancestors.push(...getOverflowAncestors(reference));
  }
  function addResizeListeners() {
    let cleanups = [trackElementRect(floating, update, { scope: "size" })];
    if (referenceResize && isHTMLElement3(reference)) {
      cleanups.push(trackElementRect(reference, update));
    }
    cleanups.push(callAll2(...ancestors.map((el) => addDomEvent2(el, "resize", update))));
    return () => cleanups.forEach((fn) => fn());
  }
  function addScrollListeners() {
    return callAll2(...ancestors.map((el) => addDomEvent2(el, "scroll", update, { passive: true })));
  }
  return callAll2(addResizeListeners(), addScrollListeners());
}

// node_modules/.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-X5LLREVI.mjs
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2) => ({
  top: "bottom center",
  "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
  "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
  "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
  left: "right center",
  "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
  "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
  "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
});
var transformOrigin = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow2 } = middlewareData;
    const transformOrigin2 = getTransformOrigin(arrow2)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin2);
    return {
      data: { transformOrigin: transformOrigin2 }
    };
  }
};
var shiftArrow = (opts) => ({
  name: "shiftArrow",
  fn({ placement, middlewareData }) {
    const { element: arrow2 } = opts;
    if (middlewareData.arrow) {
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrow2.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
    }
    return {};
  }
});

// node_modules/.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-6B3BV5TE.mjs
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
function getPlacement(reference, floating, opts = {}) {
  if (!floating || !reference)
    return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [];
  const boundary = typeof options.boundary === "function" ? options.boundary() : options.boundary;
  if (options.flip) {
    middleware.push(
      flip({
        boundary,
        padding: options.overflowPadding
      })
    );
  }
  if (options.gutter || options.offset) {
    const arrowOffset = arrowEl ? arrowEl.offsetHeight / 2 : 0;
    const data = options.gutter ? { mainAxis: options.gutter } : options.offset;
    if ((data == null ? void 0 : data.mainAxis) != null)
      data.mainAxis += arrowOffset;
    middleware.push(offset(data));
  }
  middleware.push(
    shift({
      boundary,
      crossAxis: options.overlap,
      padding: options.overflowPadding
    })
  );
  if (arrowEl) {
    middleware.push(
      arrow({ element: arrowEl, padding: 8 }),
      shiftArrow({ element: arrowEl })
    );
  }
  middleware.push(transformOrigin);
  middleware.push(
    size({
      padding: options.overflowPadding,
      apply({ rects, availableHeight, availableWidth }) {
        const referenceWidth = Math.round(rects.reference.width);
        floating.style.setProperty("--reference-width", `${referenceWidth}px`);
        floating.style.setProperty("--available-width", `${availableWidth}px`);
        floating.style.setProperty("--available-height", `${availableHeight}px`);
        if (options.sameWidth) {
          Object.assign(floating.style, {
            width: `${referenceWidth}px`,
            minWidth: "unset"
          });
        }
        if (options.fitViewport) {
          Object.assign(floating.style, {
            maxWidth: `${availableWidth}px`,
            maxHeight: `${availableHeight}px`
          });
        }
      }
    })
  );
  function compute(config = {}) {
    if (!reference || !floating)
      return;
    const { placement, strategy, onComplete } = options;
    computePosition2(reference, floating, {
      placement,
      middleware,
      strategy,
      ...config
    }).then((data) => {
      const x = Math.round(data.x);
      const y = Math.round(data.y);
      Object.assign(floating.style, {
        position: data.strategy,
        top: "0px",
        left: "0px",
        transform: `translate3d(${x}px, ${y}px, 0)`
      });
      onComplete == null ? void 0 : onComplete(data);
    });
  }
  compute();
  return callAll(
    options.listeners ? autoUpdate(reference, floating, compute, options.listeners) : void 0,
    options.onCleanup
  );
}

// node_modules/.pnpm/@zag-js+popper@0.2.7/node_modules/@zag-js/popper/dist/chunk-V4C4UQPN.mjs
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options) {
  const { placement = "bottom" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      transform: ARROW_FLOATING_STYLE[placement.split("-")[0]],
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: "absolute",
      minWidth: "max-content",
      top: "0px",
      left: "0px"
    }
  };
}

// node_modules/.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-55HRYHCU.mjs
function connect(state, send, normalize) {
  var _a, _b;
  const translations = state.context.translations;
  const isDisabled = state.context.disabled;
  const isInteractive = state.context.isInteractive;
  const isInvalid = state.context.invalid;
  const isReadOnly = state.context.readOnly;
  const isOpen = state.hasTag("open");
  const isFocused = state.hasTag("focused");
  const isIdle = state.hasTag("idle");
  const autofill = isOpen && state.context.navigationData && state.context.autoComplete;
  const showClearButton = (!isIdle || state.context.isHovering) && !state.context.isInputValueEmpty;
  const value = autofill ? (_a = state.context.navigationData) == null ? void 0 : _a.label : state.context.inputValue;
  const popperStyles = getPlacementStyles({
    placement: state.context.currentPlacement
  });
  const api = {
    /**
     * Whether the combobox is focused
     */
    isFocused,
    /**
     * Whether the combobox content or listbox is open
     */
    isOpen,
    /**
     * Whether the combobox input is empty
     */
    isInputValueEmpty: state.context.isInputValueEmpty,
    /**
     * The current value of the combobox input
     */
    inputValue: state.context.inputValue,
    /**
     * The currently focused option (by pointer or keyboard)
     */
    focusedOption: state.context.focusedOptionData,
    /**
     * The currently selected option value
     */
    selectedValue: (_b = state.context.selectionData) == null ? void 0 : _b.value,
    /**
     * Function to set the combobox value
     */
    setValue(value2) {
      let data;
      if (typeof value2 === "string") {
        data = { value: value2, label: dom.getValueLabel(state.context, value2) };
      } else {
        data = value2;
      }
      send({ type: "SET_VALUE", ...data });
    },
    /**
     * Function to set the combobox input value
     */
    setInputValue(value2) {
      send({ type: "SET_INPUT_VALUE", value: value2 });
    },
    /**
     * Function to clear the combobox input value and selected value
     */
    clearValue() {
      send("CLEAR_VALUE");
    },
    /**
     * Function to focus the combobox input
     */
    focus() {
      var _a2;
      (_a2 = dom.getInputEl(state.context)) == null ? void 0 : _a2.focus();
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      id: dom.getRootId(state.context),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly)
    }),
    labelProps: normalize.label({
      ...parts.label.attrs,
      htmlFor: dom.getInputId(state.context),
      id: dom.getLabelId(state.context),
      "data-readonly": dataAttr(isReadOnly),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-focus": dataAttr(isFocused)
    }),
    controlProps: normalize.element({
      ...parts.control.attrs,
      id: dom.getControlId(state.context),
      "data-expanded": dataAttr(isOpen),
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      onPointerOver() {
        if (!isInteractive)
          return;
        send("POINTER_OVER");
      },
      onPointerLeave() {
        if (!isInteractive)
          return;
        send("POINTER_LEAVE");
      }
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      id: dom.getPositionerId(state.context),
      "data-expanded": dataAttr(isOpen),
      hidden: !isOpen,
      style: popperStyles.floating
    }),
    inputProps: normalize.input({
      ...parts.input.attrs,
      "aria-invalid": ariaAttr(isInvalid),
      "data-invalid": dataAttr(isInvalid),
      name: state.context.name,
      form: state.context.form,
      disabled: isDisabled,
      autoFocus: state.context.autoFocus,
      autoComplete: "off",
      autoCorrect: "off",
      autoCapitalize: "none",
      spellCheck: "false",
      readOnly: isReadOnly,
      placeholder: state.context.placeholder,
      id: dom.getInputId(state.context),
      type: "text",
      role: "combobox",
      defaultValue: value,
      "data-value": value,
      "aria-autocomplete": state.context.autoComplete ? "both" : "list",
      "aria-controls": isOpen ? dom.getContentId(state.context) : void 0,
      "aria-expanded": isOpen,
      "aria-activedescendant": state.context.focusedId ?? void 0,
      onClick() {
        if (!isInteractive)
          return;
        send("CLICK_INPUT");
      },
      onFocus() {
        if (isDisabled)
          return;
        send("FOCUS");
      },
      onChange(event) {
        const evt = getNativeEvent(event);
        if (evt.isComposing)
          return;
        send({ type: "CHANGE", value: event.currentTarget.value });
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const evt = getNativeEvent(event);
        if (evt.ctrlKey || evt.shiftKey || evt.isComposing)
          return;
        let prevent = false;
        const keymap = {
          ArrowDown(event2) {
            send(event2.altKey ? "ALT_ARROW_DOWN" : "ARROW_DOWN");
            prevent = true;
          },
          ArrowUp() {
            send(event.altKey ? "ALT_ARROW_UP" : "ARROW_UP");
            prevent = true;
          },
          Home(event2) {
            const isCtrlKey = event2.ctrlKey || event2.metaKey;
            if (isCtrlKey)
              return;
            send({ type: "HOME", preventDefault: () => event2.preventDefault() });
          },
          End(event2) {
            const isCtrlKey = event2.ctrlKey || event2.metaKey;
            if (isCtrlKey)
              return;
            send({ type: "END", preventDefault: () => event2.preventDefault() });
          },
          Enter() {
            send("ENTER");
            prevent = true;
          },
          Escape() {
            send("ESCAPE");
            prevent = true;
          },
          Tab() {
            send("TAB");
          }
        };
        const key = getEventKey(event, state.context);
        const exec = keymap[key];
        exec == null ? void 0 : exec(event);
        if (prevent) {
          event.preventDefault();
        }
      }
    }),
    triggerProps: normalize.button({
      ...parts.trigger.attrs,
      id: dom.getTriggerId(state.context),
      "aria-haspopup": "listbox",
      type: "button",
      tabIndex: -1,
      "aria-label": translations.triggerLabel,
      "aria-expanded": isOpen,
      "aria-controls": isOpen ? dom.getContentId(state.context) : void 0,
      disabled: isDisabled,
      "data-readonly": dataAttr(isReadOnly),
      "data-disabled": dataAttr(isDisabled),
      onPointerDown(event) {
        const evt = getNativeEvent(event);
        if (!isInteractive || !isLeftClick(evt) || evt.pointerType === "touch")
          return;
        send("CLICK_BUTTON");
        event.preventDefault();
      },
      onPointerUp(event) {
        if (event.pointerType !== "touch")
          return;
        send("CLICK_BUTTON");
      }
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      id: dom.getContentId(state.context),
      role: "listbox",
      hidden: !isOpen,
      "aria-labelledby": dom.getLabelId(state.context),
      onPointerDown(event) {
        event.preventDefault();
      }
    }),
    clearTriggerProps: normalize.button({
      ...parts.clearTrigger.attrs,
      id: dom.getClearTriggerId(state.context),
      type: "button",
      tabIndex: -1,
      disabled: isDisabled,
      "aria-label": translations.clearTriggerLabel,
      hidden: !showClearButton,
      onPointerDown(event) {
        const evt = getNativeEvent(event);
        if (!isInteractive || !isLeftClick(evt))
          return;
        send("CLEAR_VALUE");
        event.preventDefault();
      }
    }),
    getOptionState(props) {
      var _a2;
      const { value: value2, index, disabled } = props;
      const id = dom.getOptionId(state.context, value2, index);
      const focused = state.context.focusedId === id;
      const checked = ((_a2 = state.context.selectionData) == null ? void 0 : _a2.value) === value2;
      return { disabled, focused, checked };
    },
    getOptionProps(props) {
      const { value: value2, label, index, count } = props;
      const id = dom.getOptionId(state.context, value2, index);
      const optionState = api.getOptionState(props);
      return normalize.element({
        ...parts.option.attrs,
        id,
        role: "option",
        tabIndex: -1,
        "data-highlighted": dataAttr(optionState.focused),
        "data-disabled": dataAttr(optionState.disabled),
        "data-checked": dataAttr(optionState.checked),
        "aria-selected": optionState.focused,
        "aria-disabled": optionState.disabled,
        "aria-posinset": count && index != null ? index + 1 : void 0,
        "aria-setsize": count,
        "data-value": value2,
        "data-label": label,
        // Prefer `pointermove` to `pointerenter` to avoid interrupting the keyboard navigation
        // NOTE: for perf, we may want to move these handlers to the listbox
        onPointerMove() {
          if (optionState.disabled)
            return;
          send({ type: "POINTEROVER_OPTION", id, value: value2, label });
        },
        onPointerUp() {
          if (optionState.disabled)
            return;
          send({ type: "CLICK_OPTION", src: "pointerup", id, value: value2, label });
        },
        onClick() {
          if (optionState.disabled)
            return;
          send({ type: "CLICK_OPTION", src: "click", id, value: value2, label });
        },
        onAuxClick(event) {
          if (optionState.disabled)
            return;
          event.preventDefault();
          send({ type: "CLICK_OPTION", src: "auxclick", id, value: value2, label });
        }
      });
    },
    getOptionGroupProps(props) {
      const { label } = props;
      return normalize.element({
        ...parts.optionGroup.attrs,
        role: "group",
        "aria-label": label
      });
    }
  };
  return api;
}

// node_modules/.pnpm/@zag-js+aria-hidden@0.2.2/node_modules/@zag-js/aria-hidden/dist/index.mjs
var elementCountMap = /* @__PURE__ */ new WeakMap();
function isLiveRegion(node, win) {
  return node instanceof win.HTMLElement && node.dataset.liveAnnouncer === "true";
}
function ariaHidden(targets, rootEl) {
  const exclude = targets.filter(Boolean);
  if (exclude.length === 0)
    return;
  const doc = exclude[0].ownerDocument || document;
  const win = doc.defaultView ?? window;
  const visibleNodes = new Set(exclude);
  const hiddenNodes = /* @__PURE__ */ new Set();
  const root = rootEl ?? doc.body;
  const walker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node2) {
      if (isLiveRegion(node2, win)) {
        visibleNodes.add(node2);
      }
      if (visibleNodes.has(node2) || hiddenNodes.has(node2.parentElement)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (node2 instanceof win.HTMLElement && node2.getAttribute("role") === "row") {
        return NodeFilter.FILTER_SKIP;
      }
      if (exclude.some((target) => node2.contains(target))) {
        return NodeFilter.FILTER_SKIP;
      }
      return NodeFilter.FILTER_ACCEPT;
    }
  });
  const hide2 = (node2) => {
    let refCount = elementCountMap.get(node2) ?? 0;
    if (node2.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node2.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node2);
    elementCountMap.set(node2, refCount + 1);
  };
  let node = walker.nextNode();
  while (node != null) {
    hide2(node);
    node = walker.nextNode();
  }
  const observer = new win.MutationObserver((changes) => {
    for (let change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0)
        continue;
      if (![...visibleNodes, ...hiddenNodes].some((node2) => node2.contains(change.target))) {
        for (const node2 of change.addedNodes) {
          if (isLiveRegion(node2, win)) {
            visibleNodes.add(node2);
          } else if (node2 instanceof win.Element) {
            hide2(node2);
          }
        }
      }
    }
  });
  observer.observe(root, { childList: true, subtree: true });
  return () => {
    observer.disconnect();
    for (let node2 of hiddenNodes) {
      let count = elementCountMap.get(node2);
      if (count === 1) {
        node2.removeAttribute("aria-hidden");
        elementCountMap.delete(node2);
        continue;
      }
      if (count !== void 0) {
        elementCountMap.set(node2, count - 1);
      }
    }
  };
}

// node_modules/.pnpm/@zag-js+mutation-observer@0.0.1/node_modules/@zag-js/mutation-observer/dist/chunk-I3WGVGYR.mjs
function observeAttributes(node, attributes, fn) {
  if (!node)
    return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}

// node_modules/.pnpm/@zag-js+mutation-observer@0.0.1/node_modules/@zag-js/mutation-observer/dist/chunk-6YRAYXUX.mjs
function observeChildren(node, fn) {
  if (!node)
    return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node, { childList: true, subtree: true });
  return () => obs.disconnect();
}

// node_modules/.pnpm/@zag-js+interact-outside@0.6.0/node_modules/@zag-js/interact-outside/dist/chunk-UQ6OADW7.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      var _a;
      for (let i = 0; i < ((_a = win.frames) == null ? void 0 : _a.length); i += 1) {
        const frame = win.frames[i];
        if (frame)
          cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch (err) {
          console.warn(err);
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch (err) {
          console.warn(err);
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch (err) {
          console.warn(err);
        }
      });
    }
  };
  return frames;
}

// node_modules/.pnpm/@zag-js+tabbable@0.1.1/node_modules/@zag-js/tabbable/dist/index.mjs
var isHTMLElement4 = (element) => typeof element === "object" && element !== null && element.nodeType === 1;
function isVisible(el) {
  if (!isHTMLElement4(el))
    return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
function isFocusable(element) {
  if (!element)
    return false;
  return element.matches(focusableSelector) && isVisible(element);
}

// node_modules/.pnpm/@zag-js+interact-outside@0.6.0/node_modules/@zag-js/interact-outside/dist/index.mjs
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(event) {
  const composedPath = event.composedPath() ?? [event.target];
  for (const node of composedPath) {
    if (isHTMLElement(node) && isFocusable(node))
      return true;
  }
  return false;
}
function trackInteractOutside(node, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside } = options;
  if (!node)
    return;
  const doc = getDocument(node);
  const win = getWindow(node);
  const frames = getWindowFrames(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement(target)) {
      return false;
    }
    if (contains(node, target)) {
      return false;
    }
    return !(exclude == null ? void 0 : exclude(target));
  }
  let clickHandler;
  function onPointerDown(event) {
    function handler() {
      if (!node || !isEventOutside(event))
        return;
      if (onPointerDownOutside || onInteractOutside) {
        const handler2 = callAll(onPointerDownOutside, onInteractOutside);
        node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
      }
      fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: isContextMenuEvent(event),
          focusable: isComposedPathFocusable(event)
        }
      });
    }
    if (event.pointerType === "touch") {
      frames.removeEventListener("click", handler);
      doc.removeEventListener("click", handler);
      clickHandler = handler;
      doc.addEventListener("click", handler, { once: true });
      frames.addEventListener("click", handler, { once: true });
    } else {
      handler();
    }
  }
  const cleanups = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
    cleanups.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    if (!node || !isEventOutside(event))
      return;
    if (onFocusOutside || onInteractOutside) {
      const handler = callAll(onFocusOutside, onInteractOutside);
      node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
    }
    fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: event,
        contextmenu: false,
        focusable: isFocusable(getEventTarget(event))
      }
    });
  }
  cleanups.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    if (clickHandler) {
      frames.removeEventListener("click", clickHandler);
      doc.removeEventListener("click", clickHandler);
    }
    cleanups.forEach((fn) => fn());
  };
}

// node_modules/.pnpm/@zag-js+visually-hidden@0.0.1/node_modules/@zag-js/visually-hidden/dist/index.mjs
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
function setVisuallyHidden(el) {
  Object.assign(el.style, visuallyHiddenStyle);
}

// node_modules/.pnpm/@zag-js+live-region@0.2.3/node_modules/@zag-js/live-region/dist/index.mjs
var ID = "__live-region__";
function createLiveRegion(opts = {}) {
  const { level = "polite", document: doc = document, root, delay: _delay = 0 } = opts;
  const win = doc.defaultView ?? window;
  const parent = root ?? doc.body;
  function announce(message, delay) {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
    delay = delay ?? _delay;
    const region = doc.createElement("span");
    region.id = ID;
    region.dataset.liveAnnouncer = "true";
    const role = level !== "assertive" ? "status" : "alert";
    region.setAttribute("aria-live", level);
    region.setAttribute("role", role);
    setVisuallyHidden(region);
    parent.appendChild(region);
    win.setTimeout(() => {
      region.textContent = message;
    }, delay);
  }
  function destroy() {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
  }
  return {
    announce,
    destroy,
    toJSON() {
      return ID;
    }
  };
}

// node_modules/.pnpm/@zag-js+combobox@0.6.0/node_modules/@zag-js/combobox/dist/chunk-WVULFYY5.mjs
var { and, not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "combobox",
      initial: ctx.autoFocus ? "focused" : "idle",
      context: {
        loop: true,
        openOnClick: false,
        ariaHidden: true,
        focusedId: null,
        focusedOptionData: null,
        navigationData: null,
        selectionData: null,
        inputValue: "",
        liveRegion: null,
        focusOnClear: true,
        selectInputOnFocus: false,
        selectOnTab: true,
        isHovering: false,
        isKeyboardEvent: false,
        allowCustomValue: false,
        isCustomValue: (data) => data.inputValue !== data.previousValue,
        inputBehavior: "none",
        selectionBehavior: "set",
        ...ctx,
        positioning: {
          placement: "bottom",
          flip: false,
          sameWidth: true,
          ...ctx.positioning
        },
        translations: {
          triggerLabel: "Toggle suggestions",
          clearTriggerLabel: "Clear value",
          navigationHint: "use the up and down keys to navigate. Press the enter key to select",
          countAnnouncement: (count) => `${count} ${count === 1 ? "option" : "options"} available`,
          ...ctx.translations
        }
      },
      computed: {
        isInputValueEmpty: (ctx2) => ctx2.inputValue.length === 0,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),
        autoComplete: (ctx2) => ctx2.inputBehavior === "autocomplete",
        autoHighlight: (ctx2) => ctx2.inputBehavior === "autohighlight"
      },
      watch: {
        inputValue: "invokeOnInputChange",
        navigationData: "invokeOnHighlight",
        selectionData: ["invokeOnSelect", "blurInputIfNeeded"],
        focusedId: "setSectionLabel"
      },
      entry: ["setupLiveRegion"],
      exit: ["removeLiveRegion"],
      activities: ["syncInputValue"],
      on: {
        SET_VALUE: {
          actions: ["setInputValue", "setSelectionData"]
        },
        SET_INPUT_VALUE: {
          actions: "setInputValue"
        },
        CLEAR_VALUE: [
          {
            guard: "focusOnClear",
            target: "focused",
            actions: ["clearInputValue", "clearSelectedValue"]
          },
          {
            actions: ["clearInputValue", "clearSelectedValue"]
          }
        ],
        POINTER_OVER: {
          actions: "setIsHovering"
        },
        POINTER_LEAVE: {
          actions: "clearIsHovering"
        }
      },
      states: {
        idle: {
          tags: ["idle"],
          entry: ["scrollToTop", "clearFocusedOption"],
          on: {
            CLICK_BUTTON: {
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            },
            CLICK_INPUT: {
              guard: "openOnClick",
              target: "interacting",
              actions: "invokeOnOpen"
            },
            FOCUS: "focused"
          }
        },
        focused: {
          tags: ["focused"],
          entry: ["focusInput", "scrollToTop", "clearFocusedOption"],
          activities: ["trackInteractOutside"],
          on: {
            CHANGE: {
              target: "suggesting",
              actions: "setInputValue"
            },
            BLUR: "idle",
            ESCAPE: {
              guard: and("isCustomValue", not("allowCustomValue")),
              actions: "revertInputValue"
            },
            CLICK_INPUT: {
              guard: "openOnClick",
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            },
            CLICK_BUTTON: {
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            },
            POINTER_OVER: {
              actions: "setIsHovering"
            },
            ARROW_UP: [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              {
                target: "interacting",
                actions: ["focusLastOption", "invokeOnOpen"]
              }
            ],
            ARROW_DOWN: [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              {
                target: "interacting",
                actions: ["focusFirstOption", "invokeOnOpen"]
              }
            ],
            ALT_ARROW_DOWN: {
              target: "interacting",
              actions: ["focusInput", "invokeOnOpen"]
            }
          }
        },
        suggesting: {
          tags: ["open", "focused"],
          activities: [
            "trackInteractOutside",
            "scrollOptionIntoView",
            "computePlacement",
            "trackOptionNodes",
            "hideOtherElements"
          ],
          entry: ["focusInput", "invokeOnOpen"],
          on: {
            ARROW_DOWN: {
              target: "interacting",
              actions: "focusNextOption"
            },
            ARROW_UP: {
              target: "interacting",
              actions: "focusPrevOption"
            },
            ALT_ARROW_UP: "focused",
            HOME: {
              target: "interacting",
              actions: ["focusFirstOption", "preventDefault"]
            },
            END: {
              target: "interacting",
              actions: ["focusLastOption", "preventDefault"]
            },
            ENTER: [
              {
                guard: and("hasFocusedOption", "autoComplete"),
                target: "focused",
                actions: "selectActiveOption"
              },
              {
                guard: "hasFocusedOption",
                target: "focused",
                actions: "selectOption"
              }
            ],
            CHANGE: [
              {
                guard: "autoHighlight",
                actions: ["clearFocusedOption", "setInputValue", "focusFirstOption"]
              },
              {
                actions: ["clearFocusedOption", "setInputValue"]
              }
            ],
            ESCAPE: {
              target: "focused",
              actions: "invokeOnClose"
            },
            POINTEROVER_OPTION: [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "setActiveOption"
              },
              {
                target: "interacting",
                actions: ["setActiveOption", "setNavigationData"]
              }
            ],
            BLUR: {
              target: "idle",
              actions: "invokeOnClose"
            },
            CLICK_BUTTON: {
              target: "focused",
              actions: "invokeOnClose"
            },
            CLICK_OPTION: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            }
          }
        },
        interacting: {
          tags: ["open", "focused"],
          activities: ["scrollOptionIntoView", "trackInteractOutside", "computePlacement", "hideOtherElements"],
          entry: "focusMatchingOption",
          on: {
            HOME: {
              actions: ["focusFirstOption", "preventDefault"]
            },
            END: {
              actions: ["focusLastOption", "preventDefault"]
            },
            ARROW_DOWN: [
              {
                guard: and("autoComplete", "isLastOptionFocused"),
                actions: ["clearFocusedOption", "scrollToTop"]
              },
              { actions: "focusNextOption" }
            ],
            ARROW_UP: [
              {
                guard: and("autoComplete", "isFirstOptionFocused"),
                actions: "clearFocusedOption"
              },
              {
                actions: "focusPrevOption"
              }
            ],
            ALT_UP: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            },
            CLEAR_FOCUS: {
              actions: "clearFocusedOption"
            },
            TAB: {
              guard: "selectOnTab",
              target: "idle",
              actions: ["selectOption", "invokeOnClose"]
            },
            ENTER: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            },
            CHANGE: [
              {
                guard: "autoComplete",
                target: "suggesting",
                actions: ["commitNavigationData", "setInputValue"]
              },
              {
                target: "suggesting",
                actions: ["clearFocusedOption", "setInputValue"]
              }
            ],
            POINTEROVER_OPTION: [
              {
                guard: "autoComplete",
                actions: "setActiveOption"
              },
              {
                actions: ["setActiveOption", "setNavigationData"]
              }
            ],
            CLICK_OPTION: {
              target: "focused",
              actions: ["selectOption", "invokeOnClose"]
            },
            ESCAPE: {
              target: "focused",
              actions: "invokeOnClose"
            },
            CLICK_BUTTON: {
              target: "focused",
              actions: "invokeOnClose"
            },
            BLUR: {
              target: "idle",
              actions: "invokeOnClose"
            }
          }
        }
      }
    },
    {
      guards: {
        openOnClick: (ctx2) => !!ctx2.openOnClick,
        isInputValueEmpty: (ctx2) => ctx2.isInputValueEmpty,
        focusOnClear: (ctx2) => !!ctx2.focusOnClear,
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        autoComplete: (ctx2) => ctx2.autoComplete,
        autoHighlight: (ctx2) => ctx2.autoHighlight,
        isFirstOptionFocused: (ctx2) => {
          var _a;
          return ((_a = dom.getFirstEl(ctx2)) == null ? void 0 : _a.id) === ctx2.focusedId;
        },
        isLastOptionFocused: (ctx2) => {
          var _a;
          return ((_a = dom.getLastEl(ctx2)) == null ? void 0 : _a.id) === ctx2.focusedId;
        },
        isCustomValue: (ctx2) => {
          var _a, _b;
          return !!((_b = ctx2.isCustomValue) == null ? void 0 : _b.call(ctx2, { inputValue: ctx2.inputValue, previousValue: (_a = ctx2.selectionData) == null ? void 0 : _a.value }));
        },
        allowCustomValue: (ctx2) => !!ctx2.allowCustomValue,
        hasFocusedOption: (ctx2) => !!ctx2.focusedId,
        selectOnTab: (ctx2) => !!ctx2.selectOnTab
      },
      activities: {
        syncInputValue: (ctx2) => {
          const input = dom.getInputEl(ctx2);
          return observeAttributes(input, ["data-value"], () => {
            if (!input)
              return;
            const value = input.dataset.value || "";
            input.value = value;
            input.selectionStart = value.length;
            input.selectionEnd = value.length;
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onInteractOutside(event) {
              var _a;
              (_a = ctx2.onInteractOutside) == null ? void 0 : _a.call(ctx2, event);
              if (event.defaultPrevented)
                return;
              send({ type: "BLUR", src: "interact-outside" });
            }
          });
        },
        hideOtherElements(ctx2) {
          if (!ctx2.ariaHidden)
            return;
          return ariaHidden([dom.getInputEl(ctx2), dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)]);
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          return getPlacement(dom.getControlEl(ctx2), dom.getPositionerEl(ctx2), {
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        // in event the options are fetched (async), we still want to auto-highlight the first option
        trackOptionNodes(ctx2, evt, meta) {
          if (!ctx2.autoHighlight)
            return;
          const focusFirstOption = meta.getAction("focusFirstOption");
          const exec = () => focusFirstOption(ctx2, evt, meta);
          exec();
          return observeChildren(dom.getContentEl(ctx2), exec);
        },
        scrollOptionIntoView(ctx2, _evt, { getState }) {
          const input = dom.getInputEl(ctx2);
          return observeAttributes(input, ["aria-activedescendant"], () => {
            const evt = getState().event;
            const isKeyboardEvent = /(ARROW_UP|ARROW_DOWN|HOME|END|TAB)/.test(evt.type);
            if (!isKeyboardEvent)
              return;
            const option = dom.getActiveOptionEl(ctx2);
            option == null ? void 0 : option.scrollIntoView({ block: "nearest" });
            if (ctx2.autoComplete) {
              dom.focusInput(ctx2);
            }
          });
        }
      },
      actions: {
        setupLiveRegion(ctx2) {
          ctx2.liveRegion = createLiveRegion({
            level: "assertive",
            document: dom.getDoc(ctx2)
          });
        },
        removeLiveRegion(ctx2) {
          var _a;
          (_a = ctx2.liveRegion) == null ? void 0 : _a.destroy();
        },
        setActiveOption(ctx2, evt) {
          const { label, id, value } = evt;
          ctx2.focusedId = id;
          ctx2.focusedOptionData = { label, value };
        },
        setNavigationData(ctx2, evt) {
          const { label, value } = evt;
          ctx2.navigationData = { label, value };
        },
        clearNavigationData(ctx2) {
          ctx2.navigationData = null;
        },
        commitNavigationData(ctx2) {
          if (!ctx2.navigationData)
            return;
          ctx2.inputValue = ctx2.navigationData.label;
          ctx2.navigationData = null;
        },
        clearFocusedOption(ctx2) {
          ctx2.focusedId = null;
          ctx2.focusedOptionData = null;
          ctx2.navigationData = null;
        },
        selectActiveOption(ctx2) {
          if (!ctx2.focusedOptionData)
            return;
          ctx2.selectionData = ctx2.focusedOptionData;
          ctx2.inputValue = ctx2.focusedOptionData.label;
        },
        selectOption(ctx2, evt) {
          const isOptionEvent = !!evt.value && !!evt.label;
          ctx2.selectionData = isOptionEvent ? {
            label: evt.label,
            value: evt.value
          } : ctx2.navigationData;
          let value;
          if (!ctx2.selectionData)
            return;
          if (ctx2.selectionBehavior === "set") {
            value = ctx2.selectionData.label;
          }
          if (ctx2.selectionBehavior === "clear") {
            value = "";
          }
          if (value != null) {
            ctx2.inputValue = value;
          }
        },
        blurInputIfNeeded(ctx2) {
          if (ctx2.autoComplete || !ctx2.blurOnSelect)
            return;
          raf(() => {
            var _a;
            (_a = dom.getInputEl(ctx2)) == null ? void 0 : _a.blur();
          });
        },
        focusInput(ctx2, evt) {
          if (evt.type === "CHANGE")
            return;
          dom.focusInput(ctx2);
        },
        setInputValue(ctx2, evt) {
          const value = evt.type === "SET_VALUE" ? evt.label : evt.value;
          ctx2.inputValue = value;
        },
        clearInputValue(ctx2) {
          ctx2.inputValue = "";
        },
        revertInputValue(ctx2) {
          if (!ctx2.selectionData)
            return;
          ctx2.inputValue = ctx2.selectionData.label;
        },
        setSelectionData(ctx2, evt) {
          const { label, value } = evt;
          ctx2.selectionData = { label, value };
        },
        clearSelectedValue(ctx2) {
          ctx2.selectionData = null;
        },
        scrollToTop(ctx2) {
          const listbox = dom.getContentEl(ctx2);
          if (!listbox)
            return;
          listbox.scrollTop = 0;
        },
        invokeOnInputChange(ctx2) {
          var _a;
          (_a = ctx2.onInputChange) == null ? void 0 : _a.call(ctx2, { value: ctx2.inputValue });
        },
        invokeOnHighlight(ctx2) {
          var _a;
          const { label, value } = ctx2.navigationData ?? {};
          const relatedTarget = dom.getMatchingOptionEl(ctx2, value);
          (_a = ctx2.onHighlight) == null ? void 0 : _a.call(ctx2, { label, value, relatedTarget });
        },
        invokeOnSelect(ctx2) {
          var _a;
          const { label, value } = ctx2.selectionData ?? {};
          const relatedTarget = dom.getMatchingOptionEl(ctx2, value);
          (_a = ctx2.onSelect) == null ? void 0 : _a.call(ctx2, { label, value, relatedTarget });
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpen) == null ? void 0 : _a.call(ctx2);
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onClose) == null ? void 0 : _a.call(ctx2);
        },
        highlightFirstOption(ctx2) {
          raf(() => {
            setHighlight(ctx2, dom.getFirstEl(ctx2));
          });
        },
        focusFirstOption(ctx2) {
          raf(() => {
            setFocus(ctx2, dom.getFirstEl(ctx2));
          });
        },
        focusLastOption(ctx2) {
          raf(() => {
            setFocus(ctx2, dom.getLastEl(ctx2));
          });
        },
        focusNextOption(ctx2) {
          raf(() => {
            const option = dom.getNextEl(ctx2, ctx2.focusedId ?? "");
            setFocus(ctx2, option);
          });
        },
        focusPrevOption(ctx2) {
          raf(() => {
            let option = dom.getPrevEl(ctx2, ctx2.focusedId ?? "");
            setFocus(ctx2, option);
          });
        },
        focusMatchingOption(ctx2) {
          raf(() => {
            var _a;
            const option = dom.getMatchingOptionEl(ctx2, (_a = ctx2.selectionData) == null ? void 0 : _a.value);
            option == null ? void 0 : option.scrollIntoView({ block: "nearest" });
            setFocus(ctx2, option);
          });
        },
        announceOptionCount(ctx2) {
          raf(() => {
            var _a;
            const count = dom.getOptionCount(ctx2);
            if (!count)
              return;
            const text = ctx2.translations.countAnnouncement(count);
            (_a = ctx2.liveRegion) == null ? void 0 : _a.announce(text);
          });
        },
        setIsHovering(ctx2) {
          ctx2.isHovering = true;
        },
        clearIsHovering(ctx2) {
          ctx2.isHovering = false;
        },
        preventDefault(_ctx, evt) {
          evt.preventDefault();
        },
        setSectionLabel(ctx2) {
          const label = dom.getClosestSectionLabel(ctx2);
          if (!label)
            return;
          ctx2.sectionLabel = label;
        }
      }
    }
  );
}
function setHighlight(ctx, option) {
  if (!option)
    return;
  const data = dom.getOptionData(option);
  ctx.focusedId = option.id;
  ctx.focusedOptionData = data;
  return data;
}
function setFocus(ctx, option) {
  if (!option || option.id === ctx.focusedId)
    return;
  const data = setHighlight(ctx, option);
  ctx.navigationData = data;
}
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=@zag-js_combobox.js.map
